/**
 *****************************************************************************************************
  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
  * @file	         main.c
  * @author	 
  * @version 	
  * @date	
  * @brief	         
  * @details         Contains the MCU initialization function and its H file
 *****************************************************************************************************
 * @attention
 *
 *****************************************************************************************************
 */
/*******************Includes************************************************************************/

#include "SC_Init.h"
#include "SC_it.h"
#include "..\Drivers\SCDriver_list.h"
#include "HeadFiles\SysFunVarDefine.h"
#include "sc32f12xx_TK_DynamicDebug.h"
#include <stdio.h>

extern volatile FlagStatus ADC_Flag;

/**************************************Generated by EasyCodeCube*************************************/
//Forbid editing areas between the labels !!!

/*************************************.Generated by EasyCodeCube.************************************/

// 数码管段码表 (0-9)，基于共阴数码管和提供的硬件连接
// 段码顺序: a, f, b, g, c, dp, d, e (对应PB2-PB9)
const unsigned char digitSegments[10] = {
    0xD7, // 0: a,b,c,d,e,f亮 (PB2=0,PB3=0,PB4=0,PB5=1,PB6=0,PB7=1,PB8=0,PB9=0) 0001 0100
    0x14, // 1: b,c亮 (PB2=1,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xCD, // 2: a,b,d,e,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=1,PB7=1,PB8=0,PB9=0)
    0x5D, // 3: a,b,c,d,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0x1E, // 4: b,c,f,g亮 (PB2=1,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=1,PB9=1)
    0x5B, // 5: a,c,d,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0xDB, // 6: a,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x15, // 7: a,b,c亮 (PB2=0,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xDF, // 8: a,b,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x5F  // 9: a,b,c,d,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
};

// 数码管位选表，对应4个数码管
const unsigned char digitSelect[4] = {
    0xEF, // 第1位数码管: PA6=0(选中), PA7=1, PA8=1, PA9=1
    0xDF, // 第2位数码管: PA6=1, PA7=0(选中), PA8=1, PA9=1
    0xBF, // 第3位数码管: PA6=1, PA7=1, PA8=0(选中), PA9=1
    0x7F  // 第4位数码管: PA6=1, PA7=1, PA8=1, PA9=0(选中)
};

// 全局变量，存储要显示的数字
unsigned int displayNumber;
unsigned char digits[4]; // 存储4位数字

/**
  * @brief 分解数字为4个单独的数字
  * @param num: 要显示的数字(0-9999)
  */
void decomposeNumber(unsigned int num)
{
    digits[0] = num % 10;            // 千位
    digits[1] = (num % 100) / 10; // 百位
    digits[2] = (num % 1000) / 100;     // 十位
    digits[3] =  num / 1000;         // 个位
}

/**
  * @brief 在指定数码管位置显示数字
  * @param digit: 要显示的数字(0-9)
  * @param position: 数码管位置(0-3)
  */
void displayDigit(unsigned char digit, unsigned char position)
{
    if (digit > 9) return; // 数字范围检查
    
    // 设置位选
	
	PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
    PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
    PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
    PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
    
    // 设置段选
    unsigned char seg = digitSegments[digit];
    PB_BIT(2) = (seg >> 0) & 0x01;  // a
    PB_BIT(3) = (seg >> 1) & 0x01;  // f
    PB_BIT(4) = (seg >> 2) & 0x01;  // b
    PB_BIT(5) = (seg >> 3) & 0x01;  // g
    PB_BIT(6) = (seg >> 4) & 0x01;  // c
    PB_BIT(7) = (seg >> 5) & 0x01;  // dp
    PB_BIT(8) = (seg >> 6) & 0x01;  // d
    PB_BIT(9) = (seg >> 7) & 0x01;  // e
}

/**
  * @brief 在4位数码管上显示数字
  * @param num: 要显示的数字(0-9999)
  */
void displayNumberOnTube(unsigned int num)
{
    decomposeNumber(num);
    
    // 动态扫描显示4位数码管
    static unsigned char currentPosition = 0;
    
    displayDigit(digits[currentPosition], currentPosition);
    
    currentPosition++;
    if (currentPosition >= 4) {
        currentPosition = 0;
    }
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



uint32_t TK_exKeyValueFlag = 0; //当前轮按键标志
uint8_t exKeyValue = 0;
// 消抖相关变量
uint32_t lastKeyValue = 0;      // 上次按键值
uint32_t stableKeyValue = 0;    // 稳定按键值
uint8_t debounceCount = 0;      // 消抖计数器
uint8_t keyPressed = 0;         // 按键已确认按下标志

//函数声明
void Sys_Scan(void);
void ChangeTouchKeyvalue(void);
void DebounceTouchKey(void);    // 新增消抖函数

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

volatile FlagStatus ADC_Flag;
//读ADC
uint16_t read_adc()
{
		uint16_t	adcData ;
		ADC_SoftwareStartConv(ADC);             //软件触发	
		while(ADC_Flag == RESET);               //等待
		ADC_Flag = RESET;
		adcData =  ADC_GetConversionValue(ADC);  //采集ADC	
	return adcData;
}
#define WINDOW_SIZE 1024  // 滑动窗口大小
typedef struct {
	  uint32_t sum;                  // 窗口内数据的累加和
    uint16_t buffer[WINDOW_SIZE];  // 数据缓冲区  
    uint16_t index;                // 当前写入位置
    uint8_t is_window_filled;     // 窗口是否已填满标志
	  
} MovingAverageFilter;
// 初始化滤波器
void filter_init(MovingAverageFilter *filter) {
    for (int i = 0; i < WINDOW_SIZE; i++) 
	  {
        filter->buffer[i] = 0;
    }
    filter->sum = 0;
    filter->index = 0;
    filter->is_window_filled = 0;
}
//滑动窗口
uint32_t filter_update(MovingAverageFilter *filter, uint16_t new_sample) {
	  uint32_t adcDataOver;
    // 1. 减去即将被覆盖的旧数据（如果窗口已填满）
    if (filter->is_window_filled) {
        filter->sum -= filter->buffer[filter->index];
    }

    // 2. 添加新数据到窗口
    filter->buffer[filter->index] = new_sample;
    filter->sum += new_sample;

    // 3. 更新索引和窗口状态
    filter->index++;
    if (filter->index >= WINDOW_SIZE) {
        filter->index = 0;
        filter->is_window_filled = 1;
    }

    // 4-1 计算当前过采样值 过采样5位
		if(filter->is_window_filled == 1)
		{
			adcDataOver = filter->sum >> 5;
		}
	  else
		{
			adcDataOver = new_sample << 5;//第一个窗口按照源数据输出			
		}			
    return adcDataOver;
		
//    // 4-2 计算当前均值（注意窗口未填满时除数不同）
//    uint16_t valid_samples = filter->is_window_filled ? WINDOW_SIZE : filter->index;
//    return (uint16_t)(filter->sum / valid_samples);
}
MovingAverageFilter filter;



int main(void)
{
	
    IcResourceInit();
    TK_Init();
	
	uint16_t raw_adc;
    uint32_t filtered_adc;
	
	filter_init(&filter);
    OP_OffsetSet(OP);  
	
	PB_BIT(10)=0;
	PB_BIT(13)=0;
	PB_BIT(14)=0;
	PB_BIT(15)=0;
    
    // ====== 参数调整部分 ======
    // 1. 增加中值滤波窗口大小
    #define MEDIAN_FILTER_SIZE 7  // 从5增加到7，更稳定但响应稍慢
    
    // 2. 添加IIR低通滤波参数
    #define IIR_ALPHA 0.5f        // 低通滤波系数 (0.1-0.5之间，越小越平滑)
    
    // 3. 调整显示阈值参数
    #define DISPLAY_THRESHOLD 300 // 从157增加到200，减少频繁更新
    #define DISPLAY_TIMEOUT 3000  // 超时时间稍作增加
    
    // ====== 变量定义部分 ======
    static uint32_t median_buffer[MEDIAN_FILTER_SIZE] = {0};
    static uint8_t median_index = 0;
    static uint8_t median_initialized = 0;
    
    static int32_t accumulated_change = 0;
    static uint32_t display_timeout_counter = 0;
    static uint32_t last_display_adc = 0;
    static uint32_t display_value = 0;
	static uint32_t pi_value = 0;
    
    // 新增：IIR低通滤波变量
    static float iir_filtered = 0.0f;
    
    // 新增：噪声阈值检测变量
    #define NOISE_THRESHOLD 50
    static uint32_t last_raw_adc = 0;
    static uint8_t high_noise_detected = 0;
    
    while(1)
	{
		raw_adc = read_adc();
        
        // ====== 新增：噪声检测 ======
        // 检测原始ADC的突变，判断是否为高频噪声
        uint32_t raw_adc_change = abs(raw_adc - last_raw_adc);
        if (raw_adc_change > NOISE_THRESHOLD) {
            high_noise_detected = 1;
        } else {
            high_noise_detected = 0;
        }
        last_raw_adc = raw_adc;
        
        filtered_adc = filter_update(&filter, raw_adc);
        
        // ====== 中值滤波 ======
        median_buffer[median_index] = filtered_adc;
        median_index = (median_index + 1) % MEDIAN_FILTER_SIZE;
        
        if (!median_initialized && median_index == 0) {
            median_initialized = 1;
        }
        
        uint32_t median_filtered_adc;
        if (median_initialized) {
            // 复制到临时数组进行排序
            uint32_t temp_buffer[MEDIAN_FILTER_SIZE];
            for (uint8_t i = 0; i < MEDIAN_FILTER_SIZE; i++) {
                temp_buffer[i] = median_buffer[i];
            }
            
            // 使用选择排序（比冒泡排序效率稍高）
            for (uint8_t i = 0; i < MEDIAN_FILTER_SIZE - 1; i++) {
                uint8_t min_idx = i;
                for (uint8_t j = i + 1; j < MEDIAN_FILTER_SIZE; j++) {
                    if (temp_buffer[j] < temp_buffer[min_idx]) {
                        min_idx = j;
                    }
                }
                if (min_idx != i) {
                    uint32_t temp = temp_buffer[i];
                    temp_buffer[i] = temp_buffer[min_idx];
                    temp_buffer[min_idx] = temp;
                }
            }
            median_filtered_adc = temp_buffer[MEDIAN_FILTER_SIZE / 2];
        } else {
            median_filtered_adc = filtered_adc;
        }
        
        // ====== 新增：IIR低通滤波 ======
        // 一阶IIR低通滤波：y[n] = α * x[n] + (1-α) * y[n-1]
        if (iir_filtered == 0.0f) {
            // 第一次初始化
            iir_filtered = (float)median_filtered_adc;
        } else {
            iir_filtered = IIR_ALPHA * (float)median_filtered_adc + (1.0f - IIR_ALPHA) * iir_filtered;
        }
        
        uint32_t final_filtered_adc = (uint32_t)iir_filtered;
        
        // ====== 优化显示逻辑 ======
        // 当检测到高频噪声时，增加阈值以防止误更新
        uint32_t actual_threshold = DISPLAY_THRESHOLD;
        if (high_noise_detected) {
            actual_threshold = DISPLAY_THRESHOLD * 2; // 噪声大时提高阈值
        }
        
        // 计算累计变化
        int32_t current_change = final_filtered_adc - last_display_adc;
        accumulated_change += current_change;
        
        // 只有当累计变化超过阈值时才更新显示
        if (abs(accumulated_change) > actual_threshold)
        {
            display_value = final_filtered_adc / 10;
            last_display_adc = final_filtered_adc;
            accumulated_change = 0;
            display_timeout_counter = 0;
        }
        // 超时更新（防止长期小变化不更新）
        else
        {
            display_timeout_counter++;
            if (display_timeout_counter >= DISPLAY_TIMEOUT)
            {
                display_value = final_filtered_adc / 10;
                last_display_adc = final_filtered_adc;
                accumulated_change = 0;
                display_timeout_counter = 0;
            }
        }
        
        // 持续调用显示函数进行动态扫描
		
		if(display_value>pi_value)
		{
			displayNumberOnTube((display_value-pi_value)*4/9);
		}
		else
		{
			displayNumberOnTube(0);
		}
		
		WDT->WDT_CON |= WDT_CON_CLRWDT;  //清watchdog
		if(TK_TouchKeyStatus&0x80)
		{	   													 //重要步骤3：清除标志位，需要外部清除
			TK_TouchKeyStatus &= 0x7f; 
				TK_exKeyValueFlag = TK_TouchKeyScan();  
				DebounceTouchKey();          // 先进行消抖处理
				if(keyPressed)
				{
					ChangeTouchKeyvalue();   // 按键数据处理函数
					if(exKeyValue==1)
					{
						pi_value = display_value; 
						PB_OT(10);
					}
					if(exKeyValue==2)
					{
						pi_value = 0;
						PB_OT(13);
					}
					if(exKeyValue==3)
					{
						PB_OT(14);
					}
					if(exKeyValue==4)
					{
						PB_OT(15);
					}
					keyPressed = 0;          // 清除按键标志
				}
				TK_Restart();	         //启动下一轮转换
		  }
		

		  
		  {
			unsigned int i;
			for(i = 0; i < 1000; i++);
		}
		  
	}
}

/**
  * @brief  触摸按键消抖处理
  * @param  None
  * @retval None
  */
void DebounceTouchKey(void)
{
    // 如果当前按键值与上次相同
    if(TK_exKeyValueFlag == lastKeyValue)
    {
        debounceCount++;
        
        // 连续5次检测到相同按键值，确认为有效按键
        if(debounceCount >= 5)
        {
            if(stableKeyValue != TK_exKeyValueFlag)
            {
                stableKeyValue = TK_exKeyValueFlag;
                keyPressed = 1;  // 设置按键按下标志
            }
            debounceCount = 5;   // 防止计数器溢出
        }
    }
    else
    {
        // 按键值变化，重置计数器
        debounceCount = 0;
        lastKeyValue = TK_exKeyValueFlag;
    }
    
    // 无按键时的处理（按键值为0）
    if(TK_exKeyValueFlag == 0)
    {
        debounceCount = 0;
        stableKeyValue = 0;
    }
}

/**
  * @brief  处理消抖后的按键值
  * @param  None
  * @retval None
  */
void ChangeTouchKeyvalue(void)
{
    switch(stableKeyValue)   // 使用消抖后的稳定值
    {        
        case 0x00000010:
            exKeyValue = 1;
            break;    
            
        case 0x00000020:
            exKeyValue = 2;
            break; 
            
        case 0x00000040:
            exKeyValue = 3;
            break;
            
        case 0x00000080:
            exKeyValue = 4;
            break;    
            
        default:
            exKeyValue = 0xff;
            break;             
    }
}

void Sys_Scan(void)
{	
    if(TK_TouchKeyStatus&0x80)	    //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标志位置起后
    {	   																	
        TK_TouchKeyStatus &= 0x7f;	//重要步骤3: 清除标志位， 需要外部清除。													    
        TK_exKeyValueFlag = TK_TouchKeyScan();//按键数据处理函数 
        
        DebounceTouchKey();          // 消抖处理
        if(keyPressed) {
            ChangeTouchKeyvalue();
            keyPressed = 0;
        }
        
        TK_Restart();				//启动下一轮转换																														 			
    }
}
