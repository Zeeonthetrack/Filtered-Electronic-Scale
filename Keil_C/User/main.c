/**	
 *****************************************************************************************************
  * @copyright (c) Shenzhen Saiyuan Microelectronics Co., Ltd
  * @file main.c
  * @author
  * @version
  * @date
  * @brief
  * @details Contains the MCU initialization function and its H file
 *****************************************************************************************************
 * @attention
 *
 *****************************************************************************************************
 */
/*******************Includes************************************************************************/
#include "SC_Init.h"
#include "SC_it.h"
#include "..\Drivers\SCDriver_list.h"
#include "HeadFiles\SysFunVarDefine.h"
#include "sc32f12xx_TK_DynamicDebug.h"
#include <stdio.h>
extern volatile FlagStatus ADC_Flag;
<<<<<<< HEAD
#define persec  632   

=======
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
/**************************************Generated by EasyCodeCube*************************************/
//Forbid editing areas between the labels !!!
/*************************************.Generated by EasyCodeCube.************************************/
// 数码管段码表 (0-9)，基于共阴数码管和提供的硬件连接
// 段码顺序: a, f, b, g, c, dp, d, e (对应PB2-PB9)
const unsigned char digitSegments[10] = {
<<<<<<< HEAD
    0xD7, // 0
    0x14, // 1
    0xCD, // 2
    0x5D, // 3
    0x1E, // 4
    0x5B, // 5
    0xDB, // 6
    0x15, // 7
    0xDF, // 8
    0x5F // 9
};
// 数码管位选表，对应4个数码管
const unsigned char digitSelect[4] = {
    0xEF, // 第1位
    0xDF, // 第2位
    0xBF, // 第3位
    0x7F // 第4位
=======
    0xD7, // 0: a,b,c,d,e,f亮 (PB2=0,PB3=0,PB4=0,PB5=1,PB6=0,PB7=1,PB8=0,PB9=0) 0001 0100
    0x14, // 1: b,c亮 (PB2=1,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xCD, // 2: a,b,d,e,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=1,PB7=1,PB8=0,PB9=0)
    0x5D, // 3: a,b,c,d,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0x1E, // 4: b,c,f,g亮 (PB2=1,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=1,PB9=1)
    0x5B, // 5: a,c,d,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0xDB, // 6: a,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x15, // 7: a,b,c亮 (PB2=0,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xDF, // 8: a,b,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x5F // 9: a,b,c,d,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
};
// 数码管位选表，对应4个数码管
const unsigned char digitSelect[4] = {
    0xEF, // 第1位数码管: PA6=0(选中), PA7=1, PA8=1, PA9=1
    0xDF, // 第2位数码管: PA6=1, PA7=0(选中), PA8=1, PA9=1
    0xBF, // 第3位数码管: PA6=1, PA7=1, PA8=0(选中), PA9=1
    0x7F // 第4位数码管: PA6=1, PA7=1, PA8=1, PA9=0(选中)
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
};
// 全局变量，存储要显示的数字
unsigned int displayNumber;
unsigned char digits[4]; // 存储4位数字
/**
  * @brief 分解数字为4个单独的数字
  * @param num: 要显示的数字(0-9999)
  */
void decomposeNumber(unsigned int num)
{
<<<<<<< HEAD
    digits[0] = num % 10; // 个位
    digits[1] = (num / 10) % 10; // 十位
    digits[2] = (num / 100) % 10; // 百位
    digits[3] = (num / 1000) % 10; // 千位
=======
    digits[0] = num % 10; // 千位
    digits[1] = (num % 100) / 10; // 百位
    digits[2] = (num % 1000) / 100; // 十位
    digits[3] = num / 1000; // 个位
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
}
/**
  * @brief 在指定数码管位置显示数字
  * @param digit: 要显示的数字(0-9)
  * @param position: 数码管位置(0-3)
  */
void displayDigit(unsigned char digit, unsigned char position)
{
    if (digit > 9) return; // 数字范围检查
<<<<<<< HEAD
  
=======
   
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
    // 设置位选
    PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
    PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
    PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
    PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
<<<<<<< HEAD
  
=======
   
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
    // 设置段选
    unsigned char seg = digitSegments[digit];
    PB_BIT(2) = (seg >> 0) & 0x01; // a
    PB_BIT(3) = (seg >> 1) & 0x01; // f
    PB_BIT(4) = (seg >> 2) & 0x01; // b
    PB_BIT(5) = (seg >> 3) & 0x01; // g
    PB_BIT(6) = (seg >> 4) & 0x01; // c
    PB_BIT(7) = (seg >> 5) & 0x01; // dp
    PB_BIT(8) = (seg >> 6) & 0x01; // d
    PB_BIT(9) = (seg >> 7) & 0x01; // e
}
/**
  * @brief 在4位数码管上显示数字
  * @param num: 要显示的数字(0-9999)
  */
void displayNumberOnTube(unsigned int num)
{
    decomposeNumber(num);
<<<<<<< HEAD
  
    // 动态扫描显示4位数码管
    static unsigned char currentPosition = 0;
  
    displayDigit(digits[currentPosition], currentPosition);
  
=======
   
    // 动态扫描显示4位数码管
    static unsigned char currentPosition = 0;
   
    displayDigit(digits[currentPosition], currentPosition);
   
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
    currentPosition++;
    if (currentPosition >= 4) {
        currentPosition = 0;
    }
}
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
uint32_t TK_exKeyValueFlag = 0; //当前轮按键标志
uint8_t exKeyValue = 0;
// 消抖相关变量
uint32_t lastKeyValue = 0; // 上次按键值
uint32_t stableKeyValue = 0; // 稳定按键值
uint8_t debounceCount = 0; // 消抖计数器
uint8_t keyPressed = 0; // 按键已确认按下标志
//函数声明
void Sys_Scan(void);
void ChangeTouchKeyvalue(void);
void DebounceTouchKey(void); // 新增消抖函数
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
volatile FlagStatus ADC_Flag;
//读ADC（采8次平均，压噪声）
uint16_t read_adc()
{
<<<<<<< HEAD
    uint32_t sum = 0;
    for(uint8_t i = 0; i < 8; i++) { // 连续采8次取平均
        ADC_SoftwareStartConv(ADC);
        while(ADC_Flag == RESET);
        ADC_Flag = RESET;
        sum += ADC_GetConversionValue(ADC);
    }
    return (uint16_t)(sum / 8);
}
// ==================== 卡尔曼滤波器变量 ====================
typedef struct {
    float x; // 当前最优估计值（真实重量对应的ADC值）
    float p; // 估计误差协方差
    float q; // 过程噪声协方差（越大越相信测量值，响应更快）
    float r; // 测量噪声协方差（越大越相信预测值，滤波更平滑）
    float kg; // 卡尔曼增益（内部计算用）
} KalmanFilter;
KalmanFilter kf_weight; // 称重专用的卡尔曼滤波器
// 初始化卡尔曼滤波器（建议在 main() 开头调用一次）
void Kalman_Init(KalmanFilter *kf, float init_value, float q, float r) {
    kf->x = init_value; // 初始估计值
    kf->p = 1.0f; // 初始误差协方差
    kf->q = q; // 过程噪声
    kf->r = r; // 测量噪声
}
=======
    uint16_t adcData ;
    ADC_SoftwareStartConv(ADC); //软件触发
    while(ADC_Flag == RESET); //等待
    ADC_Flag = RESET;
    adcData = ADC_GetConversionValue(ADC); //采集ADC
    return adcData;
}

// ==================== 卡尔曼滤波器变量 ====================
typedef struct {
    float x;     // 当前最优估计值（真实重量对应的ADC值）
    float p;     // 估计误差协方差
    float q;     // 过程噪声协方差（越大越相信测量值，响应更快）
    float r;     // 测量噪声协方差（越大越相信预测值，滤波更平滑）
    float kg;    // 卡尔曼增益（内部计算用）
} KalmanFilter;

KalmanFilter kf_weight;  // 称重专用的卡尔曼滤波器

// 初始化卡尔曼滤波器（建议在 main() 开头调用一次）
void Kalman_Init(KalmanFilter *kf, float init_value, float q, float r) {
    kf->x = init_value;   // 初始估计值
    kf->p = 1.0f;         // 初始误差协方差
    kf->q = q;            // 过程噪声
    kf->r = r;            // 测量噪声
}

>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
// 卡尔曼滤波核心函数（每次新采样后调用）
float Kalman_Update(KalmanFilter *kf, float measurement) {
    // 预测步骤
    kf->p = kf->p + kf->q;
<<<<<<< HEAD
    // 更新步骤
    kf->kg = kf->p / (kf->p + kf->r);
    kf->x = kf->x + kf->kg * (measurement - kf->x);
    kf->p = (1.0f - kf->kg) * kf->p;
    return kf->x; // 返回当前最优估计值
}

// ==================== 歪比巴卜滤波新增部分 ====================
#define WBB_BUFFER_SIZE 1000  // 缓冲区大小，约10秒数据（根据你的循环速度实测调整）
float wbb_buffer[WBB_BUFFER_SIZE];
uint16_t wbb_index = 0;
uint8_t wbb_full = 0;         // 缓冲区是否已满
float wbb_stable_value = 0.0f; // 当前计算出的稳定中值
float pi_value_float = 0.0f;    // 去皮值（浮点，更精确）

void WBB_Reset(void) {
    wbb_index = 0;
    wbb_full = 0;
    wbb_stable_value = 0.0f;
}



// 在数组里追加这些频率（把数组改大一点）
const uint16_t noteFrequencies[] = {
    0,    // 0: 休止符
    262,  // 1: C4
    294,  // 2: D4
    330,  // 3: E4
    349,  // 4: F4
    392,  // 5: G4
    440,  // 6: A4
    494,  // 7: B4
    523,  // 8: C5
    311,  // 9: Eb4
    370,  // 10: F#4
    415,  // 11: G#4
    466,  // 12: Bb4
    554,  // 13: Db5
    622,  // 14: Eb5
    740,  // 15: F#5
    // 如果以后还要加更多音，可以继续往后加
};
#define NOTE_REST 0
#define NOTE_C4   1
#define NOTE_D4   2
#define NOTE_E4   3
#define NOTE_F4   4
#define NOTE_G4   5
#define NOTE_A4   6
#define NOTE_B4   7
#define NOTE_C5   8
// 新增 Faded 需要的音阶（直接加到数组后面，继续编号）
#define NOTE_Eb4  9   // Eb4 (降E) 311 Hz
#define NOTE_Fs4 10   // F#4 (升F) 370 Hz
#define NOTE_Gs4 11   // G#4 (升G) 415 Hz
#define NOTE_Bb4 12   // Bb4 (降B) 466 Hz
#define NOTE_Db5 13   // Db5 (降D，高音) 554 Hz
#define NOTE_Eb5 14   // Eb5 (降E，高音) 622 Hz
#define NOTE_Fs5 15   // F#5 (升F，高音) 740 Hz

// 超精确的微秒延迟（64MHz 时钟下校准，手动 nop 版）
void delay_us(uint32_t us) {
    while (us--) {
        // 下面这一坨 nop 大概消耗 58~60 个周期，接近 1us
        // 你可以实际听声音，多加或减几个 nop 来微调
        __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop");
        __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop");
        __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop");
        __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop"); 
        __asm volatile ("nop");
        // 一共大概 58 个 nop，你听声音高了就删几行，低了就再复制几行
    }
}


// 播放单个音符
void Buzzer_PlayTone(uint8_t note, uint16_t duration_ms) {
    uint16_t frequency = noteFrequencies[note];
    if (frequency == 0) {
        // 休止符：静音，简单延迟
        delay_us(duration_ms * 1000UL);
        return;
    }
    
    // 计算半周期微秒 (500000 / freq，避免浮点)
    uint32_t half_period_us = 500000UL / frequency;
    
    // 计算总循环次数 (duration_ms * 1000 / (2 * half_period_us)) = duration_ms * frequency / 1000
    uint32_t loops = (uint32_t)duration_ms * frequency / 1000UL;
    
    for (uint32_t i = 0; i < loops; i++) {
        PC_OT(9);  // 翻转引脚
        delay_us(half_period_us);  // 延迟半周期
    }
    
    // 结束后静音一小会儿，避免音符黏连（可选，20ms）
    delay_us(20000);
}

// 音符结构
typedef struct {
    uint8_t note;      // 音阶索引
    uint16_t duration; // 持续时间 (ms)
} Note;

// 生日快乐歌序列（简单版）
const Note happyBirthday[] = {
    {NOTE_C4, 250}, {NOTE_C4, 125}, {NOTE_D4, 375}, {NOTE_C4, 375},
    {NOTE_F4, 375}, {NOTE_E4, 750}, {NOTE_REST, 125},
    {NOTE_C4, 250}, {NOTE_C4, 125}, {NOTE_D4, 375}, {NOTE_C4, 375},
    {NOTE_G4, 375}, {NOTE_F4, 750}, {NOTE_REST, 125},
    {NOTE_C4, 250}, {NOTE_C4, 125}, {NOTE_C5, 375}, {NOTE_A4, 375},
    {NOTE_F4, 250}, {NOTE_F4, 125}, {NOTE_E4, 375}, {NOTE_D4, 750}, {NOTE_REST, 125},
    {NOTE_B4, 250}, {NOTE_B4, 125}, {NOTE_A4, 375}, {NOTE_F4, 375},
    {NOTE_G4, 375}, {NOTE_F4, 750}, {NOTE_REST, 500},  // 结束
    {0, 0}  // 终止符
};



// 播放整首曲子
void Buzzer_PlayMelody(const Note* melody) {
    uint8_t i = 0;
    while (melody[i].duration != 0) {
        Buzzer_PlayTone(melody[i].note, melody[i].duration);
        i++;
    }
}



// ========================================================

void DBL()
{
	PB_BIT(10)=1;
    PB_BIT(13)=1;
    PB_BIT(14)=1;
    PB_BIT(15)=1;
	PA_BIT(6)=1;
	PA_BIT(7)=1;
	PA_BIT(8)=1;
	PA_BIT(9)=1;
}

=======

    // 更新步骤
    kf->kg = kf->p / (kf->p + kf->r);
    kf->x  = kf->x + kf->kg * (measurement - kf->x);
    kf->p  = (1.0f - kf->kg) * kf->p;

    return kf->x;  // 返回当前最优估计值
}
// ========================================================
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2

int main(void)
{
    IcResourceInit();
    TK_Init();
<<<<<<< HEAD
    int sum=0,xiuzheng=0;
    uint16_t first_adc = read_adc(); // 先读一次作为初始值
    Kalman_Init(&kf_weight, (float)first_adc, 0.01f, 1500.0f); // 强滤波，空秤稳
    WBB_Reset(); // 初始化歪比巴卜缓冲区
=======
    
    uint16_t first_adc = read_adc();                    // 先读一次作为初始值
    Kalman_Init(&kf_weight, (float)first_adc, 0.005f, 150.0f);  // 初始化卡尔曼滤波器

>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
    OP_OffsetSet(OP);
    PB_BIT(10)=0;
    PB_BIT(13)=0;
    PB_BIT(14)=0;
    PB_BIT(15)=0;
<<<<<<< HEAD

	int counter = 0;
	int sleep = 0;
	int qian=0;
	
    while(1)
    {
        uint16_t raw_adc = read_adc(); // 已平均的值
        // 卡尔曼滤波更新
        float kalman_filtered = Kalman_Update(&kf_weight, (float)raw_adc);
       
        // === 歪比巴卜核心：存入缓冲区 ===
        wbb_buffer[wbb_index] = kalman_filtered;
        wbb_index++;
        if (wbb_index >= WBB_BUFFER_SIZE) {
            wbb_index = 0;
            wbb_full = 1; // 缓冲区已满
        }
        
        // === 计算稳定中值（仅当缓冲区满时）===
        float current_stable = kalman_filtered; // 默认用当前Kalman值（缓冲未满时）
        if (wbb_full) {
            float max_val = wbb_buffer[0];
            float min_val = wbb_buffer[0];
            for (uint16_t i = 1; i < WBB_BUFFER_SIZE; i++) {
                if (wbb_buffer[i] > max_val) max_val = wbb_buffer[i];
                if (wbb_buffer[i] < min_val) min_val = wbb_buffer[i];
            }
            float mid_val = (max_val + min_val) / 2.0f;
            // 轻微平滑，避免小抖动
            current_stable = 0.3f * wbb_stable_value + 0.7f * mid_val;
            wbb_stable_value = current_stable;
        }
        
        // === 检测大变化，重置缓冲区 ===
		float sss;
		if(kalman_filtered>wbb_stable_value) sss=kalman_filtered-wbb_stable_value;
		else sss=wbb_stable_value-kalman_filtered;
        if ((sss > 9000.0f) || (!wbb_full && wbb_index > 500)) {
            WBB_Reset(); // 重置，重新收集数据
            wbb_stable_value = kalman_filtered; // 临时用当前值
            current_stable = kalman_filtered;
        }
        
        // 计算去皮后的浮点值
        float current_float = current_stable - pi_value_float;
        if(current_float < 0.0f) current_float = 0.0f;
        // 四舍五入到最近的整数
        uint32_t show_value = (uint32_t)(current_float + 0.5f);
        
		int Oversize = 0;
		if(show_value+xiuzheng>1000)
		{
			Oversize = 1;
		}
		else
		{
			Oversize = 0;
		}
		
		if(!Oversize)
		{	
			if(!sleep)
			{
//				displayNumberOnTube(counter/10);
				if(show_value+xiuzheng<=30)
				{
					displayNumberOnTube(0);
				}
				else
				{
					displayNumberOnTube(show_value+xiuzheng);
				}	
			}				
			
		}
		else
		{
			DBL();
			show_value = 700;
			Buzzer_PlayMelody(happyBirthday);
		}			
        WDT->WDT_CON |= WDT_CON_CLRWDT; //清watchdog
        if(TK_TouchKeyStatus&0x80)
        {
            TK_TouchKeyStatus &= 0x7f;
            TK_exKeyValueFlag = TK_TouchKeyScan();
            DebounceTouchKey();
            if(keyPressed)
            {
                ChangeTouchKeyvalue();
                if(exKeyValue==1)
                {
                    sum++;
                    if(sum==1) xiuzheng=25;
                    else xiuzheng=0;
                    pi_value_float = current_stable; // 去皮用当前稳定值（更准！）
                    WBB_Reset(); // 去皮后重置缓冲区，避免旧漂移影响
=======
    
    static uint32_t pi_value = 0;                       // 去皮值

    while(1)
    {
        uint16_t raw_adc = read_adc();                  // 原始ADC值

        // 卡尔曼滤波更新
        float kalman_filtered = Kalman_Update(&kf_weight, (float)raw_adc);
        
        // 修正：这里不要再除以10了！和原来一样，在显示前才除以10
        uint32_t filtered_adc_value = (uint32_t)kalman_filtered;
        
        uint32_t display_value = filtered_adc_value;   // 这里才除以10，得到要显示的克数

        uint32_t show_value;
        if(display_value > pi_value)
        {
            show_value = display_value - pi_value;
        }
        else
        {
            show_value = 0;
        }

        displayNumberOnTube(show_value);

        WDT->WDT_CON |= WDT_CON_CLRWDT; //清watchdog

        if(TK_TouchKeyStatus&0x80)
        { //重要步骤3：清除标志位，需要外部清除
            TK_TouchKeyStatus &= 0x7f;
            TK_exKeyValueFlag = TK_TouchKeyScan();
            DebounceTouchKey(); // 先进行消抖处理
            if(keyPressed)
            {
                ChangeTouchKeyvalue(); // 按键数据处理函数
                if(exKeyValue==1)
                {
                    pi_value = display_value;   // 去皮用滤波后的值
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
                    PB_OT(10);
                }
                if(exKeyValue==2)
                {
<<<<<<< HEAD
                    sum=0;
                    pi_value_float = 0.0f;
                    WBB_Reset(); // 清零去皮也重置
=======
                    pi_value = 0;
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
                    PB_OT(13);
                }
                if(exKeyValue==3)
                {
<<<<<<< HEAD
					DBL();
                    Buzzer_PlayMelody(happyBirthday);
                }
                if(exKeyValue==4)
                {
					if(counter>persec*10) counter=0;
					else counter=persec*10+1;
					if(sleep==0)
					{
						sleep = 1;
					}
					else
					{
						sleep = 0;
					}
                }
                keyPressed = 0;
            }
            TK_Restart();
        }
        {
            unsigned int i;
            for(i = 0; i < 1500; i++);
        }
		counter++;
		if(counter>=persec*40) counter=persec*40;
		if(counter>20*persec)
		{
			sleep = 1;
			DBL();
		}
		if(counter%(persec*2)==0)
		{
			int cha;
			if(qian>show_value) cha=qian-show_value;
			else cha=show_value-qian;
			if(cha>20)
			{
				counter=0;
				sleep=0;
			}
			qian=show_value;
		}
=======
                    PB_OT(14);
                }
                if(exKeyValue==4)
                {
                    PB_OT(15);
                }
                keyPressed = 0; // 清除按键标志
            }
            TK_Restart(); //启动下一轮转换
        }
 
        {
            unsigned int i;
            for(i = 0; i < 5000; i++);
        }
 
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
    }
}
/**
  * @brief 触摸按键消抖处理
  * @param None
  * @retval None
  */
void DebounceTouchKey(void)
{
    if(TK_exKeyValueFlag == lastKeyValue)
    {
        debounceCount++;
<<<<<<< HEAD
=======
       
        // 连续5次检测到相同按键值，确认为有效按键
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
        if(debounceCount >= 5)
        {
            if(stableKeyValue != TK_exKeyValueFlag)
            {
                stableKeyValue = TK_exKeyValueFlag;
<<<<<<< HEAD
                keyPressed = 1;
            }
            debounceCount = 5;
=======
                keyPressed = 1; // 设置按键按下标志
            }
            debounceCount = 5; // 防止计数器溢出
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
        }
    }
    else
    {
        debounceCount = 0;
        lastKeyValue = TK_exKeyValueFlag;
    }
<<<<<<< HEAD
  
=======
   
    // 无按键时的处理（按键值为0）
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
    if(TK_exKeyValueFlag == 0)
    {
        debounceCount = 0;
        stableKeyValue = 0;
    }
}
/**
  * @brief 处理消抖后的按键值
  * @param None
  * @retval None
  */
void ChangeTouchKeyvalue(void)
{
<<<<<<< HEAD
    switch(stableKeyValue)
=======
    switch(stableKeyValue) // 使用消抖后的稳定值
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
    {
        case 0x00000010:
            exKeyValue = 1;
            break;
<<<<<<< HEAD
        case 0x00000020:
            exKeyValue = 2;
            break;
        case 0x00000040:
            exKeyValue = 3;
            break;
        case 0x00000080:
            exKeyValue = 4;
            break;
=======
           
        case 0x00000020:
            exKeyValue = 2;
            break;
           
        case 0x00000040:
            exKeyValue = 3;
            break;
           
        case 0x00000080:
            exKeyValue = 4;
            break;
           
>>>>>>> 9a4a3e384236b29aa7172b326dce0b2e2762d3f2
        default:
            exKeyValue = 0xff;
            break;
    }
}