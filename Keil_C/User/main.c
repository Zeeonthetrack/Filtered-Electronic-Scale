/**
 *****************************************************************************************************
  * @copyright (c) Shenzhen Saiyuan Microelectronics Co., Ltd
  * @file main.c
  * @author
  * @version
  * @date
  * @brief
  * @details Contains the MCU initialization function and its H file
 *****************************************************************************************************
 * @attention
 *
 *****************************************************************************************************
 */
/*******************Includes************************************************************************/
#include "SC_Init.h"
#include "SC_it.h"
#include "..\Drivers\SCDriver_list.h"
#include "HeadFiles\SysFunVarDefine.h"
#include "sc32f12xx_TK_DynamicDebug.h"
#include <stdio.h>
extern volatile FlagStatus ADC_Flag;
/**************************************Generated by EasyCodeCube*************************************/
//Forbid editing areas between the labels !!!

/*************************************.Generated by EasyCodeCube.************************************/
// 数码管段码表 (0-9)，基于共阴数码管和提供的硬件连接
// 段码顺序: a, f, b, g, c, dp, d, e (对应PB2-PB9)
const unsigned char digitSegments[10] = {
    0xD7, // 0: a,b,c,d,e,f亮 (PB2=0,PB3=0,PB4=0,PB5=1,PB6=0,PB7=1,PB8=0,PB9=0) 0001 0100
    0x14, // 1: b,c亮 (PB2=1,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xCD, // 2: a,b,d,e,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=1,PB7=1,PB8=0,PB9=0)
    0x5D, // 3: a,b,c,d,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0x1E, // 4: b,c,f,g亮 (PB2=1,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=1,PB9=1)
    0x5B, // 5: a,c,d,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0xDB, // 6: a,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x15, // 7: a,b,c亮 (PB2=0,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xDF, // 8: a,b,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x5F // 9: a,b,c,d,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
};
// 数码管位选表，对应4个数码管
const unsigned char digitSelect[4] = {
    0xEF, // 第1位数码管: PA6=0(选中), PA7=1, PA8=1, PA9=1
    0xDF, // 第2位数码管: PA6=1, PA7=0(选中), PA8=1, PA9=1
    0xBF, // 第3位数码管: PA6=1, PA7=1, PA8=0(选中), PA9=1
    0x7F // 第4位数码管: PA6=1, PA7=1, PA8=1, PA9=0(选中)
};
// 全局变量，存储要显示的数字
unsigned int displayNumber;
unsigned char digits[4]; // 存储4位数字
/**
  * @brief 分解数字为4个单独的数字
  * @param num: 要显示的数字(0-9999)
  */
void decomposeNumber(unsigned int num)
{
    digits[0] = num % 10; // 千位
    digits[1] = (num % 100) / 10; // 百位
    digits[2] = (num % 1000) / 100; // 十位
    digits[3] = num / 1000; // 个位
}
/**
  * @brief 在指定数码管位置显示数字
  * @param digit: 要显示的数字(0-9)
  * @param position: 数码管位置(0-3)
  */
void displayDigit(unsigned char digit, unsigned char position)
{
    if (digit > 9) return; // 数字范围检查
   
    // 设置位选
    PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
    PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
    PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
    PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
   
    // 设置段选
    unsigned char seg = digitSegments[digit];
    PB_BIT(2) = (seg >> 0) & 0x01; // a
    PB_BIT(3) = (seg >> 1) & 0x01; // f
    PB_BIT(4) = (seg >> 2) & 0x01; // b
    PB_BIT(5) = (seg >> 3) & 0x01; // g
    PB_BIT(6) = (seg >> 4) & 0x01; // c
    PB_BIT(7) = (seg >> 5) & 0x01; // dp
    PB_BIT(8) = (seg >> 6) & 0x01; // d
    PB_BIT(9) = (seg >> 7) & 0x01; // e
}
/**
  * @brief 在4位数码管上显示数字
  * @param num: 要显示的数字(0-9999)
  */
void displayNumberOnTube(unsigned int num)
{
    decomposeNumber(num);
   
    // 动态扫描显示4位数码管
    static unsigned char currentPosition = 0;
   
    displayDigit(digits[currentPosition], currentPosition);
   
    currentPosition++;
    if (currentPosition >= 4) {
        currentPosition = 0;
    }
}
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
uint32_t TK_exKeyValueFlag = 0; //当前轮按键标志
uint8_t exKeyValue = 0;
// 消抖相关变量
uint32_t lastKeyValue = 0; // 上次按键值
uint32_t stableKeyValue = 0; // 稳定按键值
uint8_t debounceCount = 0; // 消抖计数器
uint8_t keyPressed = 0; // 按键已确认按下标志
//函数声明
void Sys_Scan(void);
void ChangeTouchKeyvalue(void);
void DebounceTouchKey(void); // 新增消抖函数
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
volatile FlagStatus ADC_Flag;
//读ADC
uint16_t read_adc()
{
    uint16_t adcData ;
    ADC_SoftwareStartConv(ADC); //软件触发
    while(ADC_Flag == RESET); //等待
    ADC_Flag = RESET;
    adcData = ADC_GetConversionValue(ADC); //采集ADC
    return adcData;
}

// ==================== 卡尔曼滤波器变量 ====================
typedef struct {
    float x;     // 当前最优估计值（真实重量对应的ADC值）
    float p;     // 估计误差协方差
    float q;     // 过程噪声协方差（越大越相信测量值，响应更快）
    float r;     // 测量噪声协方差（越大越相信预测值，滤波更平滑）
    float kg;    // 卡尔曼增益（内部计算用）
} KalmanFilter;

KalmanFilter kf_weight;  // 称重专用的卡尔曼滤波器

// 初始化卡尔曼滤波器（建议在 main() 开头调用一次）
void Kalman_Init(KalmanFilter *kf, float init_value, float q, float r) {
    kf->x = init_value;   // 初始估计值
    kf->p = 1.0f;         // 初始误差协方差
    kf->q = q;            // 过程噪声
    kf->r = r;            // 测量噪声
}

// 卡尔曼滤波核心函数（每次新采样后调用）
float Kalman_Update(KalmanFilter *kf, float measurement) {
    // 预测步骤
    kf->p = kf->p + kf->q;

    // 更新步骤
    kf->kg = kf->p / (kf->p + kf->r);
    kf->x  = kf->x + kf->kg * (measurement - kf->x);
    kf->p  = (1.0f - kf->kg) * kf->p;

    return kf->x;  // 返回当前最优估计值
}
// ========================================================

int main(void)
{
    IcResourceInit();
    TK_Init();
    
    uint16_t first_adc = read_adc();                    // 先读一次作为初始值
    Kalman_Init(&kf_weight, (float)first_adc, 0.005f, 150.0f);  // 初始化卡尔曼滤波器

    OP_OffsetSet(OP);
    PB_BIT(10)=0;
    PB_BIT(13)=0;
    PB_BIT(14)=0;
    PB_BIT(15)=0;
    
    static uint32_t pi_value = 0;                       // 去皮值

    while(1)
    {
        uint16_t raw_adc = read_adc();                  // 原始ADC值

        // 卡尔曼滤波更新
        float kalman_filtered = Kalman_Update(&kf_weight, (float)raw_adc);
        
        // 修正：这里不要再除以10了！和原来一样，在显示前才除以10
        uint32_t filtered_adc_value = (uint32_t)kalman_filtered;
        
        uint32_t display_value = filtered_adc_value;   // 这里才除以10，得到要显示的克数

        uint32_t show_value;
        if(display_value > pi_value)
        {
            show_value = display_value - pi_value;
        }
        else
        {
            show_value = 0;
        }

        displayNumberOnTube(show_value);

        WDT->WDT_CON |= WDT_CON_CLRWDT; //清watchdog

        if(TK_TouchKeyStatus&0x80)
        { //重要步骤3：清除标志位，需要外部清除
            TK_TouchKeyStatus &= 0x7f;
            TK_exKeyValueFlag = TK_TouchKeyScan();
            DebounceTouchKey(); // 先进行消抖处理
            if(keyPressed)
            {
                ChangeTouchKeyvalue(); // 按键数据处理函数
                if(exKeyValue==1)
                {
                    pi_value = display_value;   // 去皮用滤波后的值
                    PB_OT(10);
                }
                if(exKeyValue==2)
                {
                    pi_value = 0;
                    PB_OT(13);
                }
                if(exKeyValue==3)
                {
                    PB_OT(14);
                }
                if(exKeyValue==4)
                {
                    PB_OT(15);
                }
                keyPressed = 0; // 清除按键标志
            }
            TK_Restart(); //启动下一轮转换
        }
 
        {
            unsigned int i;
            for(i = 0; i < 5000; i++);
        }
 
    }
}
/**
  * @brief 触摸按键消抖处理
  * @param None
  * @retval None
  */
void DebounceTouchKey(void)
{
    // 如果当前按键值与上次相同
    if(TK_exKeyValueFlag == lastKeyValue)
    {
        debounceCount++;
       
        // 连续5次检测到相同按键值，确认为有效按键
        if(debounceCount >= 5)
        {
            if(stableKeyValue != TK_exKeyValueFlag)
            {
                stableKeyValue = TK_exKeyValueFlag;
                keyPressed = 1; // 设置按键按下标志
            }
            debounceCount = 5; // 防止计数器溢出
        }
    }
    else
    {
        // 按键值变化，重置计数器
        debounceCount = 0;
        lastKeyValue = TK_exKeyValueFlag;
    }
   
    // 无按键时的处理（按键值为0）
    if(TK_exKeyValueFlag == 0)
    {
        debounceCount = 0;
        stableKeyValue = 0;
    }
}
/**
  * @brief 处理消抖后的按键值
  * @param None
  * @retval None
  */
void ChangeTouchKeyvalue(void)
{
    switch(stableKeyValue) // 使用消抖后的稳定值
    {
        case 0x00000010:
            exKeyValue = 1;
            break;
           
        case 0x00000020:
            exKeyValue = 2;
            break;
           
        case 0x00000040:
            exKeyValue = 3;
            break;
           
        case 0x00000080:
            exKeyValue = 4;
            break;
           
        default:
            exKeyValue = 0xff;
            break;
    }
}