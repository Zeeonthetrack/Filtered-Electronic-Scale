/**
 *****************************************************************************************************
  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
  * @file	         main.c
  * @author	 
  * @version 	
  * @date	
  * @brief	         
  * @details         Contains the MCU initialization function and its H file
 *****************************************************************************************************
 * @attention
 *
 *****************************************************************************************************
 */
/*******************Includes************************************************************************/

#include "SC_Init.h"
#include "SC_it.h"
#include "..\Drivers\SCDriver_list.h"
#include "HeadFiles\SysFunVarDefine.h"
#include "sc32f12xx_TK_DynamicDebug.h"
#include <stdio.h>

extern volatile FlagStatus ADC_Flag;

/**************************************Generated by EasyCodeCube*************************************/
//Forbid editing areas between the labels !!!

/*************************************.Generated by EasyCodeCube.************************************/

// 数码管段码表 (0-9)，基于共阴数码管和提供的硬件连接
// 段码顺序: a, f, b, g, c, dp, d, e (对应PB2-PB9)
const unsigned char digitSegments[10] = {
    0xD7, // 0: a,b,c,d,e,f亮 (PB2=0,PB3=0,PB4=0,PB5=1,PB6=0,PB7=1,PB8=0,PB9=0) 0001 0100
    0x14, // 1: b,c亮 (PB2=1,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xCD, // 2: a,b,d,e,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=1,PB7=1,PB8=0,PB9=0)
    0x5D, // 3: a,b,c,d,g亮 (PB2=0,PB3=1,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0x1E, // 4: b,c,f,g亮 (PB2=1,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=1,PB9=1)
    0x5B, // 5: a,c,d,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
    0xDB, // 6: a,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=1,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x15, // 7: a,b,c亮 (PB2=0,PB3=1,PB4=0,PB5=1,PB6=0,PB7=1,PB8=1,PB9=1)
    0xDF, // 8: a,b,c,d,e,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=0)
    0x5F  // 9: a,b,c,d,f,g亮 (PB2=0,PB3=0,PB4=0,PB5=0,PB6=0,PB7=1,PB8=0,PB9=1)
};

// 数码管位选表，对应4个数码管
const unsigned char digitSelect[4] = {
    0xEF, // 第1位数码管: PA6=0(选中), PA7=1, PA8=1, PA9=1
    0xDF, // 第2位数码管: PA6=1, PA7=0(选中), PA8=1, PA9=1
    0xBF, // 第3位数码管: PA6=1, PA7=1, PA8=0(选中), PA9=1
    0x7F  // 第4位数码管: PA6=1, PA7=1, PA8=1, PA9=0(选中)
};

// 全局变量，存储要显示的数字
unsigned int displayNumber;
unsigned char digits[4]; // 存储4位数字

/**
  * @brief 分解数字为4个单独的数字
  * @param num: 要显示的数字(0-9999)
  */
void decomposeNumber(unsigned int num)
{
    digits[0] = num % 10;            // 千位
    digits[1] = (num % 100) / 10; // 百位
    digits[2] = (num % 1000) / 100;     // 十位
    digits[3] =  num / 1000;         // 个位
}

/**
  * @brief 在指定数码管位置显示数字
  * @param digit: 要显示的数字(0-9)
  * @param position: 数码管位置(0-3)
  */
void displayDigit(unsigned char digit, unsigned char position)
{
    if (digit > 9) return; // 数字范围检查
    
    // 设置位选
	
	PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
    PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
    PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
    PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
    
    // 设置段选
    unsigned char seg = digitSegments[digit];
    PB_BIT(2) = (seg >> 0) & 0x01;  // a
    PB_BIT(3) = (seg >> 1) & 0x01;  // f
    PB_BIT(4) = (seg >> 2) & 0x01;  // b
    PB_BIT(5) = (seg >> 3) & 0x01;  // g
    PB_BIT(6) = (seg >> 4) & 0x01;  // c
    PB_BIT(7) = (seg >> 5) & 0x01;  // dp
    PB_BIT(8) = (seg >> 6) & 0x01;  // d
    PB_BIT(9) = (seg >> 7) & 0x01;  // e
}

/**
  * @brief 在4位数码管上显示数字
  * @param num: 要显示的数字(0-9999)
  */
void displayNumberOnTube(unsigned int num)
{
    decomposeNumber(num);
    
    // 动态扫描显示4位数码管
    static unsigned char currentPosition = 0;
    
    displayDigit(digits[currentPosition], currentPosition);
    
    currentPosition++;
    if (currentPosition >= 4) {
        currentPosition = 0;
    }
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



uint32_t TK_exKeyValueFlag = 0; //当前轮按键标志
uint8_t exKeyValue = 0;
// 消抖相关变量
uint32_t lastKeyValue = 0;      // 上次按键值
uint32_t stableKeyValue = 0;    // 稳定按键值
uint8_t debounceCount = 0;      // 消抖计数器
uint8_t keyPressed = 0;         // 按键已确认按下标志

//函数声明
void Sys_Scan(void);
void ChangeTouchKeyvalue(void);
void DebounceTouchKey(void);    // 新增消抖函数

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

volatile FlagStatus ADC_Flag;
//读ADC
uint16_t read_adc()
{
		uint16_t	adcData ;
		ADC_SoftwareStartConv(ADC);             //软件触发	
		while(ADC_Flag == RESET);               //等待
		ADC_Flag = RESET;
		adcData =  ADC_GetConversionValue(ADC);  //采集ADC	
	return adcData;
}
#define WINDOW_SIZE 1024  // 滑动窗口大小
typedef struct {
	  uint32_t sum;                  // 窗口内数据的累加和
    uint16_t buffer[WINDOW_SIZE];  // 数据缓冲区  
    uint16_t index;                // 当前写入位置
    uint8_t is_window_filled;     // 窗口是否已填满标志
	  
} MovingAverageFilter;
// 初始化滤波器
void filter_init(MovingAverageFilter *filter) {
    for (int i = 0; i < WINDOW_SIZE; i++) 
	  {
        filter->buffer[i] = 0;
    }
    filter->sum = 0;
    filter->index = 0;
    filter->is_window_filled = 0;
}
//滑动窗口
uint32_t filter_update(MovingAverageFilter *filter, uint16_t new_sample) {
	  uint32_t adcDataOver;
    // 1. 减去即将被覆盖的旧数据（如果窗口已填满）
    if (filter->is_window_filled) {
        filter->sum -= filter->buffer[filter->index];
    }

    // 2. 添加新数据到窗口
    filter->buffer[filter->index] = new_sample;
    filter->sum += new_sample;

    // 3. 更新索引和窗口状态
    filter->index++;
    if (filter->index >= WINDOW_SIZE) {
        filter->index = 0;
        filter->is_window_filled = 1;
    }

    // 4-1 计算当前过采样值 过采样5位
		if(filter->is_window_filled == 1)
		{
			adcDataOver = filter->sum >> 5;
		}
	  else
		{
			adcDataOver = new_sample << 5;//第一个窗口按照源数据输出			
		}			
    return adcDataOver;
		
//    // 4-2 计算当前均值（注意窗口未填满时除数不同）
//    uint16_t valid_samples = filter->is_window_filled ? WINDOW_SIZE : filter->index;
//    return (uint16_t)(filter->sum / valid_samples);
}
MovingAverageFilter filter;

static uint32_t display_buffer[10005] = {0};

int main(void)
{
	
    IcResourceInit();
    TK_Init();
	
	uint16_t raw_adc;
    uint32_t filtered_adc;
	
	filter_init(&filter);
    OP_OffsetSet(OP);  
	
	PB_BIT(10)=0;
	PB_BIT(13)=0;
	PB_BIT(14)=0;
	PB_BIT(15)=0;
    while(1)
	{
		raw_adc = read_adc();
        filtered_adc = filter_update(&filter, raw_adc);
        displayNumberOnTube(filtered_adc/10);
		
		
		
		WDT->WDT_CON |= WDT_CON_CLRWDT;  //清watchdog
		if(TK_TouchKeyStatus&0x80)
		{	   													 //重要步骤3：清除标志位，需要外部清除
			TK_TouchKeyStatus &= 0x7f; 
				TK_exKeyValueFlag = TK_TouchKeyScan();  
				DebounceTouchKey();          // 先进行消抖处理
				if(keyPressed)
				{
					ChangeTouchKeyvalue();   // 按键数据处理函数
					if(exKeyValue==1)
					{
						PB_OT(10);
					}
					if(exKeyValue==2)
					{
						PB_OT(13);
					}
					if(exKeyValue==3)
					{
						PB_OT(14);
					}
					if(exKeyValue==4)
					{
						PB_OT(15);
					}
					keyPressed = 0;          // 清除按键标志
				}
				TK_Restart();	         //启动下一轮转换
		  }
		

		  
		  {
			unsigned int i;
			for(i = 0; i < 1000; i++);
		}
		  
	}
}

/**
  * @brief  触摸按键消抖处理
  * @param  None
  * @retval None
  */
void DebounceTouchKey(void)
{
    // 如果当前按键值与上次相同
    if(TK_exKeyValueFlag == lastKeyValue)
    {
        debounceCount++;
        
        // 连续5次检测到相同按键值，确认为有效按键
        if(debounceCount >= 5)
        {
            if(stableKeyValue != TK_exKeyValueFlag)
            {
                stableKeyValue = TK_exKeyValueFlag;
                keyPressed = 1;  // 设置按键按下标志
            }
            debounceCount = 5;   // 防止计数器溢出
        }
    }
    else
    {
        // 按键值变化，重置计数器
        debounceCount = 0;
        lastKeyValue = TK_exKeyValueFlag;
    }
    
    // 无按键时的处理（按键值为0）
    if(TK_exKeyValueFlag == 0)
    {
        debounceCount = 0;
        stableKeyValue = 0;
    }
}

/**
  * @brief  处理消抖后的按键值
  * @param  None
  * @retval None
  */
void ChangeTouchKeyvalue(void)
{
    switch(stableKeyValue)   // 使用消抖后的稳定值
    {        
        case 0x00000010:
            exKeyValue = 1;
            break;    
            
        case 0x00000020:
            exKeyValue = 2;
            break; 
            
        case 0x00000040:
            exKeyValue = 3;
            break;
            
        case 0x00000080:
            exKeyValue = 4;
            break;    
            
        default:
            exKeyValue = 0xff;
            break;             
    }
}

void Sys_Scan(void)
{	
    if(TK_TouchKeyStatus&0x80)	    //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标志位置起后
    {	   																	
        TK_TouchKeyStatus &= 0x7f;	//重要步骤3: 清除标志位， 需要外部清除。													    
        TK_exKeyValueFlag = TK_TouchKeyScan();//按键数据处理函数 
        
        DebounceTouchKey();          // 消抖处理
        if(keyPressed) {
            ChangeTouchKeyvalue();
            keyPressed = 0;
        }
        
        TK_Restart();				//启动下一轮转换																														 			
    }
}