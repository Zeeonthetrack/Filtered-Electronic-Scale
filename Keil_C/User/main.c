/**
 *****************************************************************************************************
  * @copyright (c) Shenzhen Saiyuan Microelectronics Co., Ltd
  * @file main.c
  * @author
  * @version
  * @date
  * @brief
  * @details Contains the MCU initialization function and its H file
 *****************************************************************************************************
 * @attention
 *
 *****************************************************************************************************
 */
/*******************Includes************************************************************************/
#include "SC_Init.h"
#include "SC_it.h"
#include "..\Drivers\SCDriver_list.h"
#include "HeadFiles\SysFunVarDefine.h"
#include "sc32f12xx_TK_DynamicDebug.h"
#include <stdio.h>
extern volatile FlagStatus ADC_Flag;
/**************************************Generated by EasyCodeCube*************************************/
//Forbid editing areas between the labels !!!
/*************************************.Generated by EasyCodeCube.************************************/
// 数码管段码表 (0-9)，基于共阴数码管和提供的硬件连接
// 段码顺序: a, f, b, g, c, dp, d, e (对应PB2-PB9)
const unsigned char digitSegments[10] = {
    0xD7, // 0
    0x14, // 1
    0xCD, // 2
    0x5D, // 3
    0x1E, // 4
    0x5B, // 5
    0xDB, // 6
    0x15, // 7
    0xDF, // 8
    0x5F // 9
};
// 数码管位选表，对应4个数码管
const unsigned char digitSelect[4] = {
    0xEF, // 第1位
    0xDF, // 第2位
    0xBF, // 第3位
    0x7F // 第4位
};
// 全局变量，存储要显示的数字
unsigned int displayNumber;
unsigned char digits[4]; // 存储4位数字
/**
  * @brief 分解数字为4个单独的数字
  * @param num: 要显示的数字(0-9999)
  */
void decomposeNumber(unsigned int num)
{
    digits[0] = num % 10; // 个位
    digits[1] = (num / 10) % 10; // 十位
    digits[2] = (num / 100) % 10; // 百位
    digits[3] = (num / 1000) % 10; // 千位
}
/**
  * @brief 在指定数码管位置显示数字
  * @param digit: 要显示的数字(0-9)
  * @param position: 数码管位置(0-3)
  */
void displayDigit(unsigned char digit, unsigned char position)
{
    if (digit > 9) return; // 数字范围检查
   
    // 设置位选
    PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
    PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
    PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
    PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
   
    // 设置段选
    unsigned char seg = digitSegments[digit];
    PB_BIT(2) = (seg >> 0) & 0x01; // a
    PB_BIT(3) = (seg >> 1) & 0x01; // f
    PB_BIT(4) = (seg >> 2) & 0x01; // b
    PB_BIT(5) = (seg >> 3) & 0x01; // g
    PB_BIT(6) = (seg >> 4) & 0x01; // c
    PB_BIT(7) = (seg >> 5) & 0x01; // dp
    PB_BIT(8) = (seg >> 6) & 0x01; // d
    PB_BIT(9) = (seg >> 7) & 0x01; // e
}
/**
  * @brief 在4位数码管上显示数字
  * @param num: 要显示的数字(0-9999)
  */
void displayNumberOnTube(unsigned int num)
{
    decomposeNumber(num);
   
    // 动态扫描显示4位数码管
    static unsigned char currentPosition = 0;
   
    displayDigit(digits[currentPosition], currentPosition);
   
    currentPosition++;
    if (currentPosition >= 4) {
        currentPosition = 0;
    }
}
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
uint32_t TK_exKeyValueFlag = 0; //当前轮按键标志
uint8_t exKeyValue = 0;
// 消抖相关变量
uint32_t lastKeyValue = 0; // 上次按键值
uint32_t stableKeyValue = 0; // 稳定按键值
uint8_t debounceCount = 0; // 消抖计数器
uint8_t keyPressed = 0; // 按键已确认按下标志
//函数声明
void Sys_Scan(void);
void ChangeTouchKeyvalue(void);
void DebounceTouchKey(void); // 新增消抖函数
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
volatile FlagStatus ADC_Flag;
//读ADC（采8次平均，压噪声）
uint16_t read_adc()
{
    uint32_t sum = 0;
    for(uint8_t i = 0; i < 8; i++) {  // 连续采8次取平均
        ADC_SoftwareStartConv(ADC);
        while(ADC_Flag == RESET);
        ADC_Flag = RESET;
        sum += ADC_GetConversionValue(ADC);
    }
    return (uint16_t)(sum / 8);
}

// ==================== 卡尔曼滤波器变量 ====================
typedef struct {
    float x;     // 当前最优估计值（真实重量对应的ADC值）
    float p;     // 估计误差协方差
    float q;     // 过程噪声协方差（越大越相信测量值，响应更快）
    float r;     // 测量噪声协方差（越大越相信预测值，滤波更平滑）
    float kg;    // 卡尔曼增益（内部计算用）
} KalmanFilter;

KalmanFilter kf_weight;  // 称重专用的卡尔曼滤波器

// 初始化卡尔曼滤波器（建议在 main() 开头调用一次）
void Kalman_Init(KalmanFilter *kf, float init_value, float q, float r) {
    kf->x = init_value;   // 初始估计值
    kf->p = 1.0f;         // 初始误差协方差
    kf->q = q;            // 过程噪声
    kf->r = r;            // 测量噪声
}

// 卡尔曼滤波核心函数（每次新采样后调用）
float Kalman_Update(KalmanFilter *kf, float measurement) {
    // 预测步骤
    kf->p = kf->p + kf->q;

    // 更新步骤
    kf->kg = kf->p / (kf->p + kf->r);
    kf->x  = kf->x + kf->kg * (measurement - kf->x);
    kf->p  = (1.0f - kf->kg) * kf->p;

    return kf->x;  // 返回当前最优估计值
}
// ========================================================

int main(void)
{
    IcResourceInit();
    TK_Init();
    int sum=0,xiuzheng=0;
    uint16_t first_adc = read_adc();                    // 先读一次作为初始值
    Kalman_Init(&kf_weight, (float)first_adc, 0.01f, 1000.0f);  // 强滤波，空秤稳

    OP_OffsetSet(OP);
    PB_BIT(10)=0;
    PB_BIT(13)=0;
    PB_BIT(14)=0;
    PB_BIT(15)=0;
    
    static uint32_t pi_value = 0;                       // 去皮值（浮点去皮，更精确）

    static float pi_value_float = 0.0f;  // 新增：浮点去皮值

    while(1)
    {
        uint16_t raw_adc = read_adc();                  // 已平均的值

        // 卡尔曼滤波更新
        float kalman_filtered = Kalman_Update(&kf_weight, (float)raw_adc);
        
        // 计算去皮后的浮点值
        float current_float = kalman_filtered - pi_value_float;
        if(current_float < 0.0f) current_float = 0.0f;

        // 四舍五入到最近的整数（显示精确、自然跳变）
        uint32_t show_value = (uint32_t)(current_float + 0.5f);  // +0.5实现四舍五入

        // 先不除10！保持大值，等稳定了你再改这里加 /10 或其他系数
        // uint32_t show_value_gram = show_value / 10;  // 示例：后期打开这行调克数

        displayNumberOnTube(show_value+xiuzheng);

        WDT->WDT_CON |= WDT_CON_CLRWDT; //清watchdog

        if(TK_TouchKeyStatus&0x80)
        {
            TK_TouchKeyStatus &= 0x7f;
            TK_exKeyValueFlag = TK_TouchKeyScan();
            DebounceTouchKey();
            if(keyPressed)
            {
                ChangeTouchKeyvalue();
                if(exKeyValue==1)
                {
					sum++;
					if(sum==1) xiuzheng=25;
					else xiuzheng=0;
                    pi_value_float = kalman_filtered;  // 去皮用当前滤波浮点值（更准）
                    PB_OT(10);
                }
                if(exKeyValue==2)
                {
					sum=0;
                    pi_value_float = 0.0f;
                    PB_OT(13);
                }
                if(exKeyValue==3)
                {
                    PB_OT(14);
                }
                if(exKeyValue==4)
                {
                    PB_OT(15);
                }
                keyPressed = 0;
            }
            TK_Restart();
        }
 
        {
            unsigned int i;
            for(i = 0; i < 1500; i++);
        }
 
    }
}
/**
  * @brief 触摸按键消抖处理
  * @param None
  * @retval None
  */
void DebounceTouchKey(void)
{
    if(TK_exKeyValueFlag == lastKeyValue)
    {
        debounceCount++;
        if(debounceCount >= 5)
        {
            if(stableKeyValue != TK_exKeyValueFlag)
            {
                stableKeyValue = TK_exKeyValueFlag;
                keyPressed = 1;
            }
            debounceCount = 5;
        }
    }
    else
    {
        debounceCount = 0;
        lastKeyValue = TK_exKeyValueFlag;
    }
   
    if(TK_exKeyValueFlag == 0)
    {
        debounceCount = 0;
        stableKeyValue = 0;
    }
}
/**
  * @brief 处理消抖后的按键值
  * @param None
  * @retval None
  */
void ChangeTouchKeyvalue(void)
{
    switch(stableKeyValue)
    {
        case 0x00000010:
            exKeyValue = 1;
            break;
        case 0x00000020:
            exKeyValue = 2;
            break;
        case 0x00000040:
            exKeyValue = 3;
            break;
        case 0x00000080:
            exKeyValue = 4;
            break;
        default:
            exKeyValue = 0xff;
            break;
    }
}