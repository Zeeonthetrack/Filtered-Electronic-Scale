; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\main.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\main.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -IC:\KEIL_MDK\PACK\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||i.ChangeTouchKeyvalue||, CODE, READONLY, ALIGN=2

                  ChangeTouchKeyvalue PROC
;;;311      */
;;;312    void ChangeTouchKeyvalue(void)
000000  4810              LDR      r0,|L1.68|
;;;313    {
;;;314        switch(stableKeyValue)   // 使用消抖后的稳定值
000002  6800              LDR      r0,[r0,#0]  ; stableKeyValue
000004  2810              CMP      r0,#0x10
000006  d006              BEQ      |L1.22|
000008  2820              CMP      r0,#0x20
00000a  d008              BEQ      |L1.30|
00000c  2840              CMP      r0,#0x40
00000e  d00a              BEQ      |L1.38|
000010  2880              CMP      r0,#0x80
000012  d110              BNE      |L1.54|
000014  e00b              B        |L1.46|
                  |L1.22|
;;;315        {        
;;;316            case 0x00000010:
;;;317                exKeyValue = 1;
000016  2001              MOVS     r0,#1
000018  490b              LDR      r1,|L1.72|
00001a  7008              STRB     r0,[r1,#0]
;;;318                break;    
00001c  e00f              B        |L1.62|
                  |L1.30|
;;;319                
;;;320            case 0x00000020:
;;;321                exKeyValue = 2;
00001e  2002              MOVS     r0,#2
000020  4909              LDR      r1,|L1.72|
000022  7008              STRB     r0,[r1,#0]
;;;322                break; 
000024  e00b              B        |L1.62|
                  |L1.38|
;;;323                
;;;324            case 0x00000040:
;;;325                exKeyValue = 3;
000026  2003              MOVS     r0,#3
000028  4907              LDR      r1,|L1.72|
00002a  7008              STRB     r0,[r1,#0]
;;;326                break;
00002c  e007              B        |L1.62|
                  |L1.46|
;;;327                
;;;328            case 0x00000080:
;;;329                exKeyValue = 4;
00002e  2004              MOVS     r0,#4
000030  4905              LDR      r1,|L1.72|
000032  7008              STRB     r0,[r1,#0]
;;;330                break;    
000034  e003              B        |L1.62|
                  |L1.54|
;;;331                
;;;332            default:
;;;333                exKeyValue = 0xff;
000036  20ff              MOVS     r0,#0xff
000038  4903              LDR      r1,|L1.72|
00003a  7008              STRB     r0,[r1,#0]
;;;334                break;             
00003c  bf00              NOP      
                  |L1.62|
00003e  bf00              NOP                            ;318
;;;335        }
;;;336    }
000040  4770              BX       lr
;;;337    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      stableKeyValue
                  |L1.72|
                          DCD      exKeyValue

                          AREA ||i.DebounceTouchKey||, CODE, READONLY, ALIGN=2

                  DebounceTouchKey PROC
;;;273      */
;;;274    void DebounceTouchKey(void)
000000  4817              LDR      r0,|L2.96|
;;;275    {
;;;276        // 如果当前按键值与上次相同
;;;277        if(TK_exKeyValueFlag == lastKeyValue)
000002  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
000004  4917              LDR      r1,|L2.100|
000006  6809              LDR      r1,[r1,#0]  ; lastKeyValue
000008  4288              CMP      r0,r1
00000a  d119              BNE      |L2.64|
;;;278        {
;;;279            debounceCount++;
00000c  4816              LDR      r0,|L2.104|
00000e  7800              LDRB     r0,[r0,#0]  ; debounceCount
000010  1c40              ADDS     r0,r0,#1
000012  4915              LDR      r1,|L2.104|
000014  7008              STRB     r0,[r1,#0]
;;;280            
;;;281            // 连续5次检测到相同按键值，确认为有效按键
;;;282            if(debounceCount >= 5)
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; debounceCount
00001a  2805              CMP      r0,#5
00001c  db17              BLT      |L2.78|
;;;283            {
;;;284                if(stableKeyValue != TK_exKeyValueFlag)
00001e  4813              LDR      r0,|L2.108|
000020  6800              LDR      r0,[r0,#0]  ; stableKeyValue
000022  490f              LDR      r1,|L2.96|
000024  6809              LDR      r1,[r1,#0]  ; TK_exKeyValueFlag
000026  4288              CMP      r0,r1
000028  d006              BEQ      |L2.56|
;;;285                {
;;;286                    stableKeyValue = TK_exKeyValueFlag;
00002a  480d              LDR      r0,|L2.96|
00002c  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
00002e  490f              LDR      r1,|L2.108|
000030  6008              STR      r0,[r1,#0]  ; stableKeyValue
;;;287                    keyPressed = 1;  // 设置按键按下标志
000032  2001              MOVS     r0,#1
000034  490e              LDR      r1,|L2.112|
000036  7008              STRB     r0,[r1,#0]
                  |L2.56|
;;;288                }
;;;289                debounceCount = 5;   // 防止计数器溢出
000038  2005              MOVS     r0,#5
00003a  490b              LDR      r1,|L2.104|
00003c  7008              STRB     r0,[r1,#0]
00003e  e006              B        |L2.78|
                  |L2.64|
;;;290            }
;;;291        }
;;;292        else
;;;293        {
;;;294            // 按键值变化，重置计数器
;;;295            debounceCount = 0;
000040  2000              MOVS     r0,#0
000042  4909              LDR      r1,|L2.104|
000044  7008              STRB     r0,[r1,#0]
;;;296            lastKeyValue = TK_exKeyValueFlag;
000046  4806              LDR      r0,|L2.96|
000048  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
00004a  4906              LDR      r1,|L2.100|
00004c  6008              STR      r0,[r1,#0]  ; lastKeyValue
                  |L2.78|
;;;297        }
;;;298        
;;;299        // 无按键时的处理（按键值为0）
;;;300        if(TK_exKeyValueFlag == 0)
00004e  4804              LDR      r0,|L2.96|
000050  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
000052  2800              CMP      r0,#0
000054  d103              BNE      |L2.94|
;;;301        {
;;;302            debounceCount = 0;
000056  4904              LDR      r1,|L2.104|
000058  7008              STRB     r0,[r1,#0]
;;;303            stableKeyValue = 0;
00005a  4904              LDR      r1,|L2.108|
00005c  6008              STR      r0,[r1,#0]  ; stableKeyValue
                  |L2.94|
;;;304        }
;;;305    }
00005e  4770              BX       lr
;;;306    
                          ENDP

                  |L2.96|
                          DCD      TK_exKeyValueFlag
                  |L2.100|
                          DCD      lastKeyValue
                  |L2.104|
                          DCD      debounceCount
                  |L2.108|
                          DCD      stableKeyValue
                  |L2.112|
                          DCD      keyPressed

                          AREA ||i.Sys_Scan||, CODE, READONLY, ALIGN=2

                  Sys_Scan PROC
;;;337    
;;;338    void Sys_Scan(void)
000000  b510              PUSH     {r4,lr}
;;;339    {	
;;;340        if(TK_TouchKeyStatus&0x80)	    //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标志位置起后
000002  480f              LDR      r0,|L3.64|
000004  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
000006  2180              MOVS     r1,#0x80
000008  4008              ANDS     r0,r0,r1
00000a  2800              CMP      r0,#0
00000c  d016              BEQ      |L3.60|
;;;341        {	   																	
;;;342            TK_TouchKeyStatus &= 0x7f;	//重要步骤3: 清除标志位， 需要外部清除。													    
00000e  480c              LDR      r0,|L3.64|
000010  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
000012  0640              LSLS     r0,r0,#25
000014  0e40              LSRS     r0,r0,#25
000016  490a              LDR      r1,|L3.64|
000018  7008              STRB     r0,[r1,#0]
;;;343            TK_exKeyValueFlag = TK_TouchKeyScan();//按键数据处理函数 
00001a  f7fffffe          BL       TK_TouchKeyScan
00001e  4909              LDR      r1,|L3.68|
000020  6008              STR      r0,[r1,#0]  ; TK_exKeyValueFlag
;;;344            
;;;345            DebounceTouchKey();          // 消抖处理
000022  f7fffffe          BL       DebounceTouchKey
;;;346            if(keyPressed) {
000026  4808              LDR      r0,|L3.72|
000028  7800              LDRB     r0,[r0,#0]  ; keyPressed
00002a  2800              CMP      r0,#0
00002c  d004              BEQ      |L3.56|
;;;347                ChangeTouchKeyvalue();
00002e  f7fffffe          BL       ChangeTouchKeyvalue
;;;348                keyPressed = 0;
000032  2000              MOVS     r0,#0
000034  4904              LDR      r1,|L3.72|
000036  7008              STRB     r0,[r1,#0]
                  |L3.56|
;;;349            }
;;;350            
;;;351            TK_Restart();				//启动下一轮转换																														 			
000038  f7fffffe          BL       TK_Restart
                  |L3.60|
;;;352        }
;;;353    }
00003c  bd10              POP      {r4,pc}
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      TK_TouchKeyStatus
                  |L3.68|
                          DCD      TK_exKeyValueFlag
                  |L3.72|
                          DCD      keyPressed

                          AREA ||i.decomposeNumber||, CODE, READONLY, ALIGN=2

                  decomposeNumber PROC
;;;59       */
;;;60     void decomposeNumber(unsigned int num)
000000  b570              PUSH     {r4-r6,lr}
;;;61     {
000002  4604              MOV      r4,r0
;;;62         digits[0] = num % 10;            // 千位
000004  210a              MOVS     r1,#0xa
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       __aeabi_uidivmod
00000c  4810              LDR      r0,|L4.80|
00000e  7001              STRB     r1,[r0,#0]
;;;63         digits[1] = (num % 100) / 10; // 百位
000010  2164              MOVS     r1,#0x64
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_uidivmod
000018  460d              MOV      r5,r1
00001a  210a              MOVS     r1,#0xa
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  490b              LDR      r1,|L4.80|
000024  7048              STRB     r0,[r1,#1]
;;;64         digits[2] = (num % 1000) / 100;     // 十位
000026  217d              MOVS     r1,#0x7d
000028  00c9              LSLS     r1,r1,#3
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  460d              MOV      r5,r1
000032  2164              MOVS     r1,#0x64
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       __aeabi_uidivmod
00003a  4905              LDR      r1,|L4.80|
00003c  7088              STRB     r0,[r1,#2]
;;;65         digits[3] =  num / 1000;         // 个位
00003e  217d              MOVS     r1,#0x7d
000040  00c9              LSLS     r1,r1,#3
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       __aeabi_uidivmod
000048  4901              LDR      r1,|L4.80|
00004a  70c8              STRB     r0,[r1,#3]
;;;66     }
00004c  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      digits

                          AREA ||i.displayDigit||, CODE, READONLY, ALIGN=2

                  displayDigit PROC
;;;72       */
;;;73     void displayDigit(unsigned char digit, unsigned char position)
000000  b510              PUSH     {r4,lr}
;;;74     {
000002  4602              MOV      r2,r0
;;;75         if (digit > 9) return; // 数字范围检查
000004  2a09              CMP      r2,#9
000006  dd00              BLE      |L5.10|
                  |L5.8|
;;;76         
;;;77         // 设置位选
;;;78     	
;;;79     	PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
;;;80         PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
;;;81         PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
;;;82         PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
;;;83         
;;;84         // 设置段选
;;;85         unsigned char seg = digitSegments[digit];
;;;86         PB_BIT(2) = (seg >> 0) & 0x01;  // a
;;;87         PB_BIT(3) = (seg >> 1) & 0x01;  // f
;;;88         PB_BIT(4) = (seg >> 2) & 0x01;  // b
;;;89         PB_BIT(5) = (seg >> 3) & 0x01;  // g
;;;90         PB_BIT(6) = (seg >> 4) & 0x01;  // c
;;;91         PB_BIT(7) = (seg >> 5) & 0x01;  // dp
;;;92         PB_BIT(8) = (seg >> 6) & 0x01;  // d
;;;93         PB_BIT(9) = (seg >> 7) & 0x01;  // e
;;;94     }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  4b18              LDR      r3,|L5.108|
00000c  5c5b              LDRB     r3,[r3,r1]            ;79
00000e  06db              LSLS     r3,r3,#27             ;79
000010  0fdb              LSRS     r3,r3,#31             ;79
000012  4c17              LDR      r4,|L5.112|
000014  71a3              STRB     r3,[r4,#6]            ;79
000016  4b15              LDR      r3,|L5.108|
000018  5c5b              LDRB     r3,[r3,r1]            ;80
00001a  069b              LSLS     r3,r3,#26             ;80
00001c  0fdb              LSRS     r3,r3,#31             ;80
00001e  71e3              STRB     r3,[r4,#7]            ;80
000020  4b12              LDR      r3,|L5.108|
000022  5c5b              LDRB     r3,[r3,r1]            ;81
000024  065b              LSLS     r3,r3,#25             ;81
000026  0fdb              LSRS     r3,r3,#31             ;81
000028  7223              STRB     r3,[r4,#8]            ;81
00002a  4b10              LDR      r3,|L5.108|
00002c  5c5b              LDRB     r3,[r3,r1]            ;82
00002e  11db              ASRS     r3,r3,#7              ;82
000030  7263              STRB     r3,[r4,#9]            ;82
000032  4b10              LDR      r3,|L5.116|
000034  5c98              LDRB     r0,[r3,r2]            ;85
000036  07c3              LSLS     r3,r0,#31             ;86
000038  0fdb              LSRS     r3,r3,#31             ;86
00003a  4c0f              LDR      r4,|L5.120|
00003c  70a3              STRB     r3,[r4,#2]            ;86
00003e  0783              LSLS     r3,r0,#30             ;87
000040  0fdb              LSRS     r3,r3,#31             ;87
000042  70e3              STRB     r3,[r4,#3]            ;87
000044  0743              LSLS     r3,r0,#29             ;88
000046  0fdb              LSRS     r3,r3,#31             ;88
000048  7123              STRB     r3,[r4,#4]            ;88
00004a  0703              LSLS     r3,r0,#28             ;89
00004c  0fdb              LSRS     r3,r3,#31             ;89
00004e  7163              STRB     r3,[r4,#5]            ;89
000050  06c3              LSLS     r3,r0,#27             ;90
000052  0fdb              LSRS     r3,r3,#31             ;90
000054  71a3              STRB     r3,[r4,#6]            ;90
000056  0683              LSLS     r3,r0,#26             ;91
000058  0fdb              LSRS     r3,r3,#31             ;91
00005a  71e3              STRB     r3,[r4,#7]            ;91
00005c  0643              LSLS     r3,r0,#25             ;92
00005e  0fdb              LSRS     r3,r3,#31             ;92
000060  7223              STRB     r3,[r4,#8]            ;92
000062  11c3              ASRS     r3,r0,#7              ;93
000064  7263              STRB     r3,[r4,#9]            ;93
000066  bf00              NOP      
000068  e7ce              B        |L5.8|
;;;95     
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      digitSelect
                  |L5.112|
                          DCD      0x40011000
                  |L5.116|
                          DCD      digitSegments
                  |L5.120|
                          DCD      0x40011100

                          AREA ||i.displayNumberOnTube||, CODE, READONLY, ALIGN=2

                  displayNumberOnTube PROC
;;;99       */
;;;100    void displayNumberOnTube(unsigned int num)
000000  b510              PUSH     {r4,lr}
;;;101    {
000002  4604              MOV      r4,r0
;;;102        decomposeNumber(num);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       decomposeNumber
;;;103        
;;;104        // 动态扫描显示4位数码管
;;;105        static unsigned char currentPosition = 0;
;;;106        
;;;107        displayDigit(digits[currentPosition], currentPosition);
00000a  490a              LDR      r1,|L6.52|
00000c  4a0a              LDR      r2,|L6.56|
00000e  7812              LDRB     r2,[r2,#0]  ; currentPosition
000010  5c88              LDRB     r0,[r1,r2]
000012  4909              LDR      r1,|L6.56|
000014  7809              LDRB     r1,[r1,#0]  ; currentPosition
000016  f7fffffe          BL       displayDigit
;;;108        
;;;109        currentPosition++;
00001a  4807              LDR      r0,|L6.56|
00001c  7800              LDRB     r0,[r0,#0]  ; currentPosition
00001e  1c40              ADDS     r0,r0,#1
000020  4905              LDR      r1,|L6.56|
000022  7008              STRB     r0,[r1,#0]
;;;110        if (currentPosition >= 4) {
000024  4608              MOV      r0,r1
000026  7800              LDRB     r0,[r0,#0]  ; currentPosition
000028  2804              CMP      r0,#4
00002a  db01              BLT      |L6.48|
;;;111            currentPosition = 0;
00002c  2000              MOVS     r0,#0
00002e  7008              STRB     r0,[r1,#0]
                  |L6.48|
;;;112        }
;;;113    }
000030  bd10              POP      {r4,pc}
;;;114    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      digits
                  |L6.56|
                          DCD      currentPosition

                          AREA ||i.filter_init||, CODE, READONLY, ALIGN=1

                  filter_init PROC
;;;157    // 初始化滤波器
;;;158    void filter_init(MovingAverageFilter *filter) {
000000  b510              PUSH     {r4,lr}
;;;159        for (int i = 0; i < WINDOW_SIZE; i++) 
000002  2100              MOVS     r1,#0
000004  e004              B        |L7.16|
                  |L7.6|
;;;160    	  {
;;;161            filter->buffer[i] = 0;
000006  2300              MOVS     r3,#0
000008  004c              LSLS     r4,r1,#1
00000a  1d02              ADDS     r2,r0,#4
00000c  5313              STRH     r3,[r2,r4]
00000e  1c49              ADDS     r1,r1,#1              ;159
                  |L7.16|
000010  2201              MOVS     r2,#1                 ;159
000012  0292              LSLS     r2,r2,#10             ;159
000014  4291              CMP      r1,r2                 ;159
000016  dbf6              BLT      |L7.6|
;;;162        }
;;;163        filter->sum = 0;
000018  2100              MOVS     r1,#0
00001a  6001              STR      r1,[r0,#0]
;;;164        filter->index = 0;
00001c  0052              LSLS     r2,r2,#1
00001e  1882              ADDS     r2,r0,r2
000020  8091              STRH     r1,[r2,#4]
;;;165        filter->is_window_filled = 0;
000022  2201              MOVS     r2,#1
000024  02d2              LSLS     r2,r2,#11
000026  1882              ADDS     r2,r0,r2
000028  7191              STRB     r1,[r2,#6]
;;;166    }
00002a  bd10              POP      {r4,pc}
;;;167    //滑动窗口
                          ENDP


                          AREA ||i.filter_update||, CODE, READONLY, ALIGN=1

                  filter_update PROC
;;;167    //滑动窗口
;;;168    uint32_t filter_update(MovingAverageFilter *filter, uint16_t new_sample) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;169    	  uint32_t adcDataOver;
;;;170        // 1. 减去即将被覆盖的旧数据（如果窗口已填满）
;;;171        if (filter->is_window_filled) {
000004  2301              MOVS     r3,#1
000006  02db              LSLS     r3,r3,#11
000008  18d3              ADDS     r3,r2,r3
00000a  799b              LDRB     r3,[r3,#6]
00000c  2b00              CMP      r3,#0
00000e  d009              BEQ      |L8.36|
;;;172            filter->sum -= filter->buffer[filter->index];
000010  2301              MOVS     r3,#1
000012  02db              LSLS     r3,r3,#11
000014  18d3              ADDS     r3,r2,r3
000016  889b              LDRH     r3,[r3,#4]
000018  005d              LSLS     r5,r3,#1
00001a  1d13              ADDS     r3,r2,#4
00001c  5b5b              LDRH     r3,[r3,r5]
00001e  6814              LDR      r4,[r2,#0]
000020  1ae3              SUBS     r3,r4,r3
000022  6013              STR      r3,[r2,#0]
                  |L8.36|
;;;173        }
;;;174    
;;;175        // 2. 添加新数据到窗口
;;;176        filter->buffer[filter->index] = new_sample;
000024  2301              MOVS     r3,#1
000026  02db              LSLS     r3,r3,#11
000028  18d3              ADDS     r3,r2,r3
00002a  889b              LDRH     r3,[r3,#4]
00002c  005c              LSLS     r4,r3,#1
00002e  1d13              ADDS     r3,r2,#4
000030  5319              STRH     r1,[r3,r4]
;;;177        filter->sum += new_sample;
000032  6813              LDR      r3,[r2,#0]
000034  185b              ADDS     r3,r3,r1
000036  6013              STR      r3,[r2,#0]
;;;178    
;;;179        // 3. 更新索引和窗口状态
;;;180        filter->index++;
000038  2301              MOVS     r3,#1
00003a  02db              LSLS     r3,r3,#11
00003c  18d3              ADDS     r3,r2,r3
00003e  889b              LDRH     r3,[r3,#4]
000040  1c5b              ADDS     r3,r3,#1
000042  2401              MOVS     r4,#1
000044  02e4              LSLS     r4,r4,#11
000046  1914              ADDS     r4,r2,r4
000048  80a3              STRH     r3,[r4,#4]
;;;181        if (filter->index >= WINDOW_SIZE) {
00004a  2301              MOVS     r3,#1
00004c  02db              LSLS     r3,r3,#11
00004e  18d3              ADDS     r3,r2,r3
000050  889b              LDRH     r3,[r3,#4]
000052  2401              MOVS     r4,#1
000054  02a4              LSLS     r4,r4,#10
000056  42a3              CMP      r3,r4
000058  db07              BLT      |L8.106|
;;;182            filter->index = 0;
00005a  2300              MOVS     r3,#0
00005c  0064              LSLS     r4,r4,#1
00005e  1914              ADDS     r4,r2,r4
000060  80a3              STRH     r3,[r4,#4]
;;;183            filter->is_window_filled = 1;
000062  2301              MOVS     r3,#1
000064  02dc              LSLS     r4,r3,#11
000066  1914              ADDS     r4,r2,r4
000068  71a3              STRB     r3,[r4,#6]
                  |L8.106|
;;;184        }
;;;185    
;;;186        // 4-1 计算当前过采样值 过采样5位
;;;187    		if(filter->is_window_filled == 1)
00006a  2301              MOVS     r3,#1
00006c  02db              LSLS     r3,r3,#11
00006e  18d3              ADDS     r3,r2,r3
000070  799b              LDRB     r3,[r3,#6]
000072  2b01              CMP      r3,#1
000074  d102              BNE      |L8.124|
;;;188    		{
;;;189    			adcDataOver = filter->sum >> 5;
000076  6813              LDR      r3,[r2,#0]
000078  0958              LSRS     r0,r3,#5
00007a  e000              B        |L8.126|
                  |L8.124|
;;;190    		}
;;;191    	  else
;;;192    		{
;;;193    			adcDataOver = new_sample << 5;//第一个窗口按照源数据输出			
00007c  0148              LSLS     r0,r1,#5
                  |L8.126|
;;;194    		}			
;;;195        return adcDataOver;
;;;196    		
;;;197    //    // 4-2 计算当前均值（注意窗口未填满时除数不同）
;;;198    //    uint16_t valid_samples = filter->is_window_filled ? WINDOW_SIZE : filter->index;
;;;199    //    return (uint16_t)(filter->sum / valid_samples);
;;;200    }
00007e  bd30              POP      {r4,r5,pc}
;;;201    MovingAverageFilter filter;
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;204    
;;;205    int main(void)
000000  f7fffffe          BL       IcResourceInit
;;;206    {
;;;207    
;;;208        IcResourceInit();
;;;209        TK_Init();
000004  f7fffffe          BL       TK_Init
;;;210    	
;;;211    	uint16_t raw_adc;
;;;212        uint32_t filtered_adc;
;;;213    	
;;;214    	filter_init(&filter);
000008  4832              LDR      r0,|L9.212|
00000a  f7fffffe          BL       filter_init
;;;215        OP_OffsetSet(OP);  
00000e  4832              LDR      r0,|L9.216|
000010  f7fffffe          BL       OP_OffsetSet
;;;216    	
;;;217    	PB_BIT(10)=0;
000014  2000              MOVS     r0,#0
000016  4931              LDR      r1,|L9.220|
000018  7288              STRB     r0,[r1,#0xa]
;;;218    	PB_BIT(13)=0;
00001a  7348              STRB     r0,[r1,#0xd]
;;;219    	PB_BIT(14)=0;
00001c  7388              STRB     r0,[r1,#0xe]
;;;220    	PB_BIT(15)=0;
00001e  73c8              STRB     r0,[r1,#0xf]
;;;221        while(1)
000020  e057              B        |L9.210|
                  |L9.34|
;;;222    	{
;;;223    		raw_adc = read_adc();
000022  f7fffffe          BL       read_adc
000026  4604              MOV      r4,r0
;;;224            filtered_adc = filter_update(&filter, raw_adc);
000028  4621              MOV      r1,r4
00002a  482a              LDR      r0,|L9.212|
00002c  f7fffffe          BL       filter_update
000030  4605              MOV      r5,r0
;;;225            displayNumberOnTube(filtered_adc/10);
000032  210a              MOVS     r1,#0xa
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       __aeabi_uidivmod
00003a  4606              MOV      r6,r0
00003c  f7fffffe          BL       displayNumberOnTube
;;;226    		
;;;227    		
;;;228    		
;;;229    		WDT->WDT_CON |= WDT_CON_CLRWDT;  //清watchdog
000040  4827              LDR      r0,|L9.224|
000042  6bc0              LDR      r0,[r0,#0x3c]
000044  2101              MOVS     r1,#1
000046  4308              ORRS     r0,r0,r1
000048  4925              LDR      r1,|L9.224|
00004a  63c8              STR      r0,[r1,#0x3c]
;;;230    		if(TK_TouchKeyStatus&0x80)
00004c  4825              LDR      r0,|L9.228|
00004e  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
000050  2180              MOVS     r1,#0x80
000052  4008              ANDS     r0,r0,r1
000054  2800              CMP      r0,#0
000056  d031              BEQ      |L9.188|
;;;231    		{	   													 //重要步骤3：清除标志位，需要外部清除
;;;232    			TK_TouchKeyStatus &= 0x7f; 
000058  4822              LDR      r0,|L9.228|
00005a  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
00005c  0640              LSLS     r0,r0,#25
00005e  0e40              LSRS     r0,r0,#25
000060  4920              LDR      r1,|L9.228|
000062  7008              STRB     r0,[r1,#0]
;;;233    				TK_exKeyValueFlag = TK_TouchKeyScan();  
000064  f7fffffe          BL       TK_TouchKeyScan
000068  491f              LDR      r1,|L9.232|
00006a  6008              STR      r0,[r1,#0]  ; TK_exKeyValueFlag
;;;234    				DebounceTouchKey();          // 先进行消抖处理
00006c  f7fffffe          BL       DebounceTouchKey
;;;235    				if(keyPressed)
000070  481e              LDR      r0,|L9.236|
000072  7800              LDRB     r0,[r0,#0]  ; keyPressed
000074  2800              CMP      r0,#0
000076  d01f              BEQ      |L9.184|
;;;236    				{
;;;237    					ChangeTouchKeyvalue();   // 按键数据处理函数
000078  f7fffffe          BL       ChangeTouchKeyvalue
;;;238    					if(exKeyValue==1)
00007c  481c              LDR      r0,|L9.240|
00007e  7800              LDRB     r0,[r0,#0]  ; exKeyValue
000080  2801              CMP      r0,#1
000082  d101              BNE      |L9.136|
;;;239    					{
;;;240    						PB_OT(10);
000084  4915              LDR      r1,|L9.220|
000086  7688              STRB     r0,[r1,#0x1a]
                  |L9.136|
;;;241    					}
;;;242    					if(exKeyValue==2)
000088  4819              LDR      r0,|L9.240|
00008a  7800              LDRB     r0,[r0,#0]  ; exKeyValue
00008c  2802              CMP      r0,#2
00008e  d102              BNE      |L9.150|
;;;243    					{
;;;244    						PB_OT(13);
000090  2001              MOVS     r0,#1
000092  4912              LDR      r1,|L9.220|
000094  7748              STRB     r0,[r1,#0x1d]
                  |L9.150|
;;;245    					}
;;;246    					if(exKeyValue==3)
000096  4816              LDR      r0,|L9.240|
000098  7800              LDRB     r0,[r0,#0]  ; exKeyValue
00009a  2803              CMP      r0,#3
00009c  d102              BNE      |L9.164|
;;;247    					{
;;;248    						PB_OT(14);
00009e  2001              MOVS     r0,#1
0000a0  490e              LDR      r1,|L9.220|
0000a2  7788              STRB     r0,[r1,#0x1e]
                  |L9.164|
;;;249    					}
;;;250    					if(exKeyValue==4)
0000a4  4812              LDR      r0,|L9.240|
0000a6  7800              LDRB     r0,[r0,#0]  ; exKeyValue
0000a8  2804              CMP      r0,#4
0000aa  d102              BNE      |L9.178|
;;;251    					{
;;;252    						PB_OT(15);
0000ac  2001              MOVS     r0,#1
0000ae  490b              LDR      r1,|L9.220|
0000b0  77c8              STRB     r0,[r1,#0x1f]
                  |L9.178|
;;;253    					}
;;;254    					keyPressed = 0;          // 清除按键标志
0000b2  2000              MOVS     r0,#0
0000b4  490d              LDR      r1,|L9.236|
0000b6  7008              STRB     r0,[r1,#0]
                  |L9.184|
;;;255    				}
;;;256    				TK_Restart();	         //启动下一轮转换
0000b8  f7fffffe          BL       TK_Restart
                  |L9.188|
;;;257    		  }
;;;258    		
;;;259    		  displayNumberOnTube(4399);
0000bc  480d              LDR      r0,|L9.244|
0000be  f7fffffe          BL       displayNumberOnTube
;;;260    		  
;;;261    		  {
;;;262    			unsigned int i;
;;;263    			for(i = 0; i < 1000; i++);
0000c2  2000              MOVS     r0,#0
0000c4  e000              B        |L9.200|
                  |L9.198|
0000c6  1c40              ADDS     r0,r0,#1
                  |L9.200|
0000c8  217d              MOVS     r1,#0x7d
0000ca  00c9              LSLS     r1,r1,#3
0000cc  4288              CMP      r0,r1
0000ce  d3fa              BCC      |L9.198|
;;;264    		}
0000d0  bf00              NOP      
                  |L9.210|
0000d2  e7a6              B        |L9.34|
;;;265    		  
;;;266    	}
;;;267    }
;;;268    
                          ENDP

                  |L9.212|
                          DCD      filter
                  |L9.216|
                          DCD      0x40022140
                  |L9.220|
                          DCD      0x40011100
                  |L9.224|
                          DCD      0x40000300
                  |L9.228|
                          DCD      TK_TouchKeyStatus
                  |L9.232|
                          DCD      TK_exKeyValueFlag
                  |L9.236|
                          DCD      keyPressed
                  |L9.240|
                          DCD      exKeyValue
                  |L9.244|
                          DCD      0x0000112f

                          AREA ||i.read_adc||, CODE, READONLY, ALIGN=2

                  read_adc PROC
;;;139    //读ADC
;;;140    uint16_t read_adc()
000000  b510              PUSH     {r4,lr}
;;;141    {
;;;142    		uint16_t	adcData ;
;;;143    		ADC_SoftwareStartConv(ADC);             //软件触发	
000002  4808              LDR      r0,|L10.36|
000004  f7fffffe          BL       ADC_SoftwareStartConv
;;;144    		while(ADC_Flag == RESET);               //等待
000008  bf00              NOP      
                  |L10.10|
00000a  4807              LDR      r0,|L10.40|
00000c  7800              LDRB     r0,[r0,#0]  ; ADC_Flag
00000e  2800              CMP      r0,#0
000010  d0fb              BEQ      |L10.10|
;;;145    		ADC_Flag = RESET;
000012  2000              MOVS     r0,#0
000014  4904              LDR      r1,|L10.40|
000016  7008              STRB     r0,[r1,#0]
;;;146    		adcData =  ADC_GetConversionValue(ADC);  //采集ADC	
000018  4802              LDR      r0,|L10.36|
00001a  f7fffffe          BL       ADC_GetConversionValue
00001e  4604              MOV      r4,r0
;;;147    	return adcData;
000020  4620              MOV      r0,r4
;;;148    }
000022  bd10              POP      {r4,pc}
;;;149    #define WINDOW_SIZE 1024  // 滑动窗口大小
                          ENDP

                  |L10.36|
                          DCD      0x40022110
                  |L10.40|
                          DCD      ADC_Flag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  filter
                          %        2056

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  digitSegments
000000  d714cd5d          DCB      0xd7,0x14,0xcd,0x5d
000004  1e5bdb15          DCB      0x1e,0x5b,0xdb,0x15
000008  df5f              DCB      0xdf,0x5f
                  digitSelect
00000a  efdf              DCB      0xef,0xdf
00000c  bf7f              DCB      0xbf,0x7f

                          AREA ||.data||, DATA, ALIGN=2

                  displayNumber
                          DCD      0x00000000
                  digits
                          DCD      0x00000000
                  TK_exKeyValueFlag
                          DCD      0x00000000
                  exKeyValue
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  lastKeyValue
                          DCD      0x00000000
                  stableKeyValue
                          DCD      0x00000000
                  debounceCount
000018  00                DCB      0x00
                  keyPressed
000019  00                DCB      0x00
                  ADC_Flag
00001a  00                DCB      0x00
                  currentPosition
00001b  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_370df81d____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_370df81d____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_370df81d____REVSH|
#line 478
|__asm___6_main_c_370df81d____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
