; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\main.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\main.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -IC:\KEIL_MDK\PACK\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||i.ChangeTouchKeyvalue||, CODE, READONLY, ALIGN=2

                  ChangeTouchKeyvalue PROC
;;;313      */
;;;314    void ChangeTouchKeyvalue(void)
000000  4810              LDR      r0,|L1.68|
;;;315    {
;;;316        switch(stableKeyValue)   // 使用消抖后的稳定值
000002  6800              LDR      r0,[r0,#0]  ; stableKeyValue
000004  2810              CMP      r0,#0x10
000006  d006              BEQ      |L1.22|
000008  2820              CMP      r0,#0x20
00000a  d008              BEQ      |L1.30|
00000c  2840              CMP      r0,#0x40
00000e  d00a              BEQ      |L1.38|
000010  2880              CMP      r0,#0x80
000012  d110              BNE      |L1.54|
000014  e00b              B        |L1.46|
                  |L1.22|
;;;317        {        
;;;318            case 0x00000010:
;;;319                exKeyValue = 1;
000016  2001              MOVS     r0,#1
000018  490b              LDR      r1,|L1.72|
00001a  7008              STRB     r0,[r1,#0]
;;;320                break;    
00001c  e00f              B        |L1.62|
                  |L1.30|
;;;321                
;;;322            case 0x00000020:
;;;323                exKeyValue = 2;
00001e  2002              MOVS     r0,#2
000020  4909              LDR      r1,|L1.72|
000022  7008              STRB     r0,[r1,#0]
;;;324                break; 
000024  e00b              B        |L1.62|
                  |L1.38|
;;;325                
;;;326            case 0x00000040:
;;;327                exKeyValue = 3;
000026  2003              MOVS     r0,#3
000028  4907              LDR      r1,|L1.72|
00002a  7008              STRB     r0,[r1,#0]
;;;328                break;
00002c  e007              B        |L1.62|
                  |L1.46|
;;;329                
;;;330            case 0x00000080:
;;;331                exKeyValue = 4;
00002e  2004              MOVS     r0,#4
000030  4905              LDR      r1,|L1.72|
000032  7008              STRB     r0,[r1,#0]
;;;332                break;    
000034  e003              B        |L1.62|
                  |L1.54|
;;;333                
;;;334            default:
;;;335                exKeyValue = 0xff;
000036  20ff              MOVS     r0,#0xff
000038  4903              LDR      r1,|L1.72|
00003a  7008              STRB     r0,[r1,#0]
;;;336                break;             
00003c  bf00              NOP      
                  |L1.62|
00003e  bf00              NOP                            ;320
;;;337        }
;;;338    }
000040  4770              BX       lr
;;;339    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      stableKeyValue
                  |L1.72|
                          DCD      exKeyValue

                          AREA ||i.DebounceTouchKey||, CODE, READONLY, ALIGN=2

                  DebounceTouchKey PROC
;;;275      */
;;;276    void DebounceTouchKey(void)
000000  4817              LDR      r0,|L2.96|
;;;277    {
;;;278        // 如果当前按键值与上次相同
;;;279        if(TK_exKeyValueFlag == lastKeyValue)
000002  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
000004  4917              LDR      r1,|L2.100|
000006  6809              LDR      r1,[r1,#0]  ; lastKeyValue
000008  4288              CMP      r0,r1
00000a  d119              BNE      |L2.64|
;;;280        {
;;;281            debounceCount++;
00000c  4816              LDR      r0,|L2.104|
00000e  7800              LDRB     r0,[r0,#0]  ; debounceCount
000010  1c40              ADDS     r0,r0,#1
000012  4915              LDR      r1,|L2.104|
000014  7008              STRB     r0,[r1,#0]
;;;282            
;;;283            // 连续5次检测到相同按键值，确认为有效按键
;;;284            if(debounceCount >= 5)
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; debounceCount
00001a  2805              CMP      r0,#5
00001c  db17              BLT      |L2.78|
;;;285            {
;;;286                if(stableKeyValue != TK_exKeyValueFlag)
00001e  4813              LDR      r0,|L2.108|
000020  6800              LDR      r0,[r0,#0]  ; stableKeyValue
000022  490f              LDR      r1,|L2.96|
000024  6809              LDR      r1,[r1,#0]  ; TK_exKeyValueFlag
000026  4288              CMP      r0,r1
000028  d006              BEQ      |L2.56|
;;;287                {
;;;288                    stableKeyValue = TK_exKeyValueFlag;
00002a  480d              LDR      r0,|L2.96|
00002c  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
00002e  490f              LDR      r1,|L2.108|
000030  6008              STR      r0,[r1,#0]  ; stableKeyValue
;;;289                    keyPressed = 1;  // 设置按键按下标志
000032  2001              MOVS     r0,#1
000034  490e              LDR      r1,|L2.112|
000036  7008              STRB     r0,[r1,#0]
                  |L2.56|
;;;290                }
;;;291                debounceCount = 5;   // 防止计数器溢出
000038  2005              MOVS     r0,#5
00003a  490b              LDR      r1,|L2.104|
00003c  7008              STRB     r0,[r1,#0]
00003e  e006              B        |L2.78|
                  |L2.64|
;;;292            }
;;;293        }
;;;294        else
;;;295        {
;;;296            // 按键值变化，重置计数器
;;;297            debounceCount = 0;
000040  2000              MOVS     r0,#0
000042  4909              LDR      r1,|L2.104|
000044  7008              STRB     r0,[r1,#0]
;;;298            lastKeyValue = TK_exKeyValueFlag;
000046  4806              LDR      r0,|L2.96|
000048  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
00004a  4906              LDR      r1,|L2.100|
00004c  6008              STR      r0,[r1,#0]  ; lastKeyValue
                  |L2.78|
;;;299        }
;;;300        
;;;301        // 无按键时的处理（按键值为0）
;;;302        if(TK_exKeyValueFlag == 0)
00004e  4804              LDR      r0,|L2.96|
000050  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
000052  2800              CMP      r0,#0
000054  d103              BNE      |L2.94|
;;;303        {
;;;304            debounceCount = 0;
000056  4904              LDR      r1,|L2.104|
000058  7008              STRB     r0,[r1,#0]
;;;305            stableKeyValue = 0;
00005a  4904              LDR      r1,|L2.108|
00005c  6008              STR      r0,[r1,#0]  ; stableKeyValue
                  |L2.94|
;;;306        }
;;;307    }
00005e  4770              BX       lr
;;;308    
                          ENDP

                  |L2.96|
                          DCD      TK_exKeyValueFlag
                  |L2.100|
                          DCD      lastKeyValue
                  |L2.104|
                          DCD      debounceCount
                  |L2.108|
                          DCD      stableKeyValue
                  |L2.112|
                          DCD      keyPressed

                          AREA ||i.Sys_Scan||, CODE, READONLY, ALIGN=2

                  Sys_Scan PROC
;;;339    
;;;340    void Sys_Scan(void)
000000  b510              PUSH     {r4,lr}
;;;341    {	
;;;342        if(TK_TouchKeyStatus&0x80)	    //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标志位置起后
000002  480f              LDR      r0,|L3.64|
000004  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
000006  2180              MOVS     r1,#0x80
000008  4008              ANDS     r0,r0,r1
00000a  2800              CMP      r0,#0
00000c  d016              BEQ      |L3.60|
;;;343        {	   																	
;;;344            TK_TouchKeyStatus &= 0x7f;	//重要步骤3: 清除标志位， 需要外部清除。													    
00000e  480c              LDR      r0,|L3.64|
000010  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
000012  0640              LSLS     r0,r0,#25
000014  0e40              LSRS     r0,r0,#25
000016  490a              LDR      r1,|L3.64|
000018  7008              STRB     r0,[r1,#0]
;;;345            TK_exKeyValueFlag = TK_TouchKeyScan();//按键数据处理函数 
00001a  f7fffffe          BL       TK_TouchKeyScan
00001e  4909              LDR      r1,|L3.68|
000020  6008              STR      r0,[r1,#0]  ; TK_exKeyValueFlag
;;;346            
;;;347            DebounceTouchKey();          // 消抖处理
000022  f7fffffe          BL       DebounceTouchKey
;;;348            if(keyPressed) {
000026  4808              LDR      r0,|L3.72|
000028  7800              LDRB     r0,[r0,#0]  ; keyPressed
00002a  2800              CMP      r0,#0
00002c  d004              BEQ      |L3.56|
;;;349                ChangeTouchKeyvalue();
00002e  f7fffffe          BL       ChangeTouchKeyvalue
;;;350                keyPressed = 0;
000032  2000              MOVS     r0,#0
000034  4904              LDR      r1,|L3.72|
000036  7008              STRB     r0,[r1,#0]
                  |L3.56|
;;;351            }
;;;352            
;;;353            TK_Restart();				//启动下一轮转换																														 			
000038  f7fffffe          BL       TK_Restart
                  |L3.60|
;;;354        }
;;;355    }
00003c  bd10              POP      {r4,pc}
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      TK_TouchKeyStatus
                  |L3.68|
                          DCD      TK_exKeyValueFlag
                  |L3.72|
                          DCD      keyPressed

                          AREA ||i.decomposeNumber||, CODE, READONLY, ALIGN=2

                  decomposeNumber PROC
;;;61       */
;;;62     void decomposeNumber(unsigned int num)
000000  b570              PUSH     {r4-r6,lr}
;;;63     {
000002  4604              MOV      r4,r0
;;;64         digits[0] = num % 10;            // 千位
000004  210a              MOVS     r1,#0xa
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       __aeabi_uidivmod
00000c  4810              LDR      r0,|L4.80|
00000e  7001              STRB     r1,[r0,#0]
;;;65         digits[1] = (num % 100) / 10; // 百位
000010  2164              MOVS     r1,#0x64
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_uidivmod
000018  460d              MOV      r5,r1
00001a  210a              MOVS     r1,#0xa
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  490b              LDR      r1,|L4.80|
000024  7048              STRB     r0,[r1,#1]
;;;66         digits[2] = (num % 1000) / 100;     // 十位
000026  217d              MOVS     r1,#0x7d
000028  00c9              LSLS     r1,r1,#3
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  460d              MOV      r5,r1
000032  2164              MOVS     r1,#0x64
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       __aeabi_uidivmod
00003a  4905              LDR      r1,|L4.80|
00003c  7088              STRB     r0,[r1,#2]
;;;67         digits[3] =  num / 1000;         // 个位
00003e  217d              MOVS     r1,#0x7d
000040  00c9              LSLS     r1,r1,#3
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       __aeabi_uidivmod
000048  4901              LDR      r1,|L4.80|
00004a  70c8              STRB     r0,[r1,#3]
;;;68     }
00004c  bd70              POP      {r4-r6,pc}
;;;69     
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      digits

                          AREA ||i.displayDigit||, CODE, READONLY, ALIGN=2

                  displayDigit PROC
;;;74       */
;;;75     void displayDigit(unsigned char digit, unsigned char position)
000000  b510              PUSH     {r4,lr}
;;;76     {
000002  4602              MOV      r2,r0
;;;77         if (digit > 9) return; // 数字范围检查
000004  2a09              CMP      r2,#9
000006  dd00              BLE      |L5.10|
                  |L5.8|
;;;78         
;;;79         // 设置位选
;;;80     	
;;;81     	PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
;;;82         PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
;;;83         PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
;;;84         PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
;;;85         
;;;86         // 设置段选
;;;87         unsigned char seg = digitSegments[digit];
;;;88         PB_BIT(2) = (seg >> 0) & 0x01;  // a
;;;89         PB_BIT(3) = (seg >> 1) & 0x01;  // f
;;;90         PB_BIT(4) = (seg >> 2) & 0x01;  // b
;;;91         PB_BIT(5) = (seg >> 3) & 0x01;  // g
;;;92         PB_BIT(6) = (seg >> 4) & 0x01;  // c
;;;93         PB_BIT(7) = (seg >> 5) & 0x01;  // dp
;;;94         PB_BIT(8) = (seg >> 6) & 0x01;  // d
;;;95         PB_BIT(9) = (seg >> 7) & 0x01;  // e
;;;96     }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  4b18              LDR      r3,|L5.108|
00000c  5c5b              LDRB     r3,[r3,r1]            ;81
00000e  06db              LSLS     r3,r3,#27             ;81
000010  0fdb              LSRS     r3,r3,#31             ;81
000012  4c17              LDR      r4,|L5.112|
000014  71a3              STRB     r3,[r4,#6]            ;81
000016  4b15              LDR      r3,|L5.108|
000018  5c5b              LDRB     r3,[r3,r1]            ;82
00001a  069b              LSLS     r3,r3,#26             ;82
00001c  0fdb              LSRS     r3,r3,#31             ;82
00001e  71e3              STRB     r3,[r4,#7]            ;82
000020  4b12              LDR      r3,|L5.108|
000022  5c5b              LDRB     r3,[r3,r1]            ;83
000024  065b              LSLS     r3,r3,#25             ;83
000026  0fdb              LSRS     r3,r3,#31             ;83
000028  7223              STRB     r3,[r4,#8]            ;83
00002a  4b10              LDR      r3,|L5.108|
00002c  5c5b              LDRB     r3,[r3,r1]            ;84
00002e  11db              ASRS     r3,r3,#7              ;84
000030  7263              STRB     r3,[r4,#9]            ;84
000032  4b10              LDR      r3,|L5.116|
000034  5c98              LDRB     r0,[r3,r2]            ;87
000036  07c3              LSLS     r3,r0,#31             ;88
000038  0fdb              LSRS     r3,r3,#31             ;88
00003a  4c0f              LDR      r4,|L5.120|
00003c  70a3              STRB     r3,[r4,#2]            ;88
00003e  0783              LSLS     r3,r0,#30             ;89
000040  0fdb              LSRS     r3,r3,#31             ;89
000042  70e3              STRB     r3,[r4,#3]            ;89
000044  0743              LSLS     r3,r0,#29             ;90
000046  0fdb              LSRS     r3,r3,#31             ;90
000048  7123              STRB     r3,[r4,#4]            ;90
00004a  0703              LSLS     r3,r0,#28             ;91
00004c  0fdb              LSRS     r3,r3,#31             ;91
00004e  7163              STRB     r3,[r4,#5]            ;91
000050  06c3              LSLS     r3,r0,#27             ;92
000052  0fdb              LSRS     r3,r3,#31             ;92
000054  71a3              STRB     r3,[r4,#6]            ;92
000056  0683              LSLS     r3,r0,#26             ;93
000058  0fdb              LSRS     r3,r3,#31             ;93
00005a  71e3              STRB     r3,[r4,#7]            ;93
00005c  0643              LSLS     r3,r0,#25             ;94
00005e  0fdb              LSRS     r3,r3,#31             ;94
000060  7223              STRB     r3,[r4,#8]            ;94
000062  11c3              ASRS     r3,r0,#7              ;95
000064  7263              STRB     r3,[r4,#9]            ;95
000066  bf00              NOP      
000068  e7ce              B        |L5.8|
;;;97     
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      digitSelect
                  |L5.112|
                          DCD      0x40011000
                  |L5.116|
                          DCD      digitSegments
                  |L5.120|
                          DCD      0x40011100

                          AREA ||i.displayNumberOnTube||, CODE, READONLY, ALIGN=2

                  displayNumberOnTube PROC
;;;101      */
;;;102    void displayNumberOnTube(unsigned int num)
000000  b510              PUSH     {r4,lr}
;;;103    {
000002  4604              MOV      r4,r0
;;;104        decomposeNumber(num);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       decomposeNumber
;;;105        
;;;106        // 动态扫描显示4位数码管
;;;107        static unsigned char currentPosition = 0;
;;;108        
;;;109        displayDigit(digits[currentPosition], currentPosition);
00000a  490a              LDR      r1,|L6.52|
00000c  4a0a              LDR      r2,|L6.56|
00000e  7812              LDRB     r2,[r2,#0]  ; currentPosition
000010  5c88              LDRB     r0,[r1,r2]
000012  4909              LDR      r1,|L6.56|
000014  7809              LDRB     r1,[r1,#0]  ; currentPosition
000016  f7fffffe          BL       displayDigit
;;;110        
;;;111        currentPosition++;
00001a  4807              LDR      r0,|L6.56|
00001c  7800              LDRB     r0,[r0,#0]  ; currentPosition
00001e  1c40              ADDS     r0,r0,#1
000020  4905              LDR      r1,|L6.56|
000022  7008              STRB     r0,[r1,#0]
;;;112        if (currentPosition >= 4) {
000024  4608              MOV      r0,r1
000026  7800              LDRB     r0,[r0,#0]  ; currentPosition
000028  2804              CMP      r0,#4
00002a  db01              BLT      |L6.48|
;;;113            currentPosition = 0;
00002c  2000              MOVS     r0,#0
00002e  7008              STRB     r0,[r1,#0]
                  |L6.48|
;;;114        }
;;;115    }
000030  bd10              POP      {r4,pc}
;;;116    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      digits
                  |L6.56|
                          DCD      currentPosition

                          AREA ||i.filter_init||, CODE, READONLY, ALIGN=1

                  filter_init PROC
;;;159    // 初始化滤波器
;;;160    void filter_init(MovingAverageFilter *filter) {
000000  b510              PUSH     {r4,lr}
;;;161        for (int i = 0; i < WINDOW_SIZE; i++) 
000002  2100              MOVS     r1,#0
000004  e004              B        |L7.16|
                  |L7.6|
;;;162    	  {
;;;163            filter->buffer[i] = 0;
000006  2300              MOVS     r3,#0
000008  004c              LSLS     r4,r1,#1
00000a  1d02              ADDS     r2,r0,#4
00000c  5313              STRH     r3,[r2,r4]
00000e  1c49              ADDS     r1,r1,#1              ;161
                  |L7.16|
000010  2201              MOVS     r2,#1                 ;161
000012  0292              LSLS     r2,r2,#10             ;161
000014  4291              CMP      r1,r2                 ;161
000016  dbf6              BLT      |L7.6|
;;;164        }
;;;165        filter->sum = 0;
000018  2100              MOVS     r1,#0
00001a  6001              STR      r1,[r0,#0]
;;;166        filter->index = 0;
00001c  0052              LSLS     r2,r2,#1
00001e  1882              ADDS     r2,r0,r2
000020  8091              STRH     r1,[r2,#4]
;;;167        filter->is_window_filled = 0;
000022  2201              MOVS     r2,#1
000024  02d2              LSLS     r2,r2,#11
000026  1882              ADDS     r2,r0,r2
000028  7191              STRB     r1,[r2,#6]
;;;168    }
00002a  bd10              POP      {r4,pc}
;;;169    //滑动窗口
                          ENDP


                          AREA ||i.filter_update||, CODE, READONLY, ALIGN=1

                  filter_update PROC
;;;169    //滑动窗口
;;;170    uint32_t filter_update(MovingAverageFilter *filter, uint16_t new_sample) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;171    	  uint32_t adcDataOver;
;;;172        // 1. 减去即将被覆盖的旧数据（如果窗口已填满）
;;;173        if (filter->is_window_filled) {
000004  2301              MOVS     r3,#1
000006  02db              LSLS     r3,r3,#11
000008  18d3              ADDS     r3,r2,r3
00000a  799b              LDRB     r3,[r3,#6]
00000c  2b00              CMP      r3,#0
00000e  d009              BEQ      |L8.36|
;;;174            filter->sum -= filter->buffer[filter->index];
000010  2301              MOVS     r3,#1
000012  02db              LSLS     r3,r3,#11
000014  18d3              ADDS     r3,r2,r3
000016  889b              LDRH     r3,[r3,#4]
000018  005d              LSLS     r5,r3,#1
00001a  1d13              ADDS     r3,r2,#4
00001c  5b5b              LDRH     r3,[r3,r5]
00001e  6814              LDR      r4,[r2,#0]
000020  1ae3              SUBS     r3,r4,r3
000022  6013              STR      r3,[r2,#0]
                  |L8.36|
;;;175        }
;;;176    
;;;177        // 2. 添加新数据到窗口
;;;178        filter->buffer[filter->index] = new_sample;
000024  2301              MOVS     r3,#1
000026  02db              LSLS     r3,r3,#11
000028  18d3              ADDS     r3,r2,r3
00002a  889b              LDRH     r3,[r3,#4]
00002c  005c              LSLS     r4,r3,#1
00002e  1d13              ADDS     r3,r2,#4
000030  5319              STRH     r1,[r3,r4]
;;;179        filter->sum += new_sample;
000032  6813              LDR      r3,[r2,#0]
000034  185b              ADDS     r3,r3,r1
000036  6013              STR      r3,[r2,#0]
;;;180    
;;;181        // 3. 更新索引和窗口状态
;;;182        filter->index++;
000038  2301              MOVS     r3,#1
00003a  02db              LSLS     r3,r3,#11
00003c  18d3              ADDS     r3,r2,r3
00003e  889b              LDRH     r3,[r3,#4]
000040  1c5b              ADDS     r3,r3,#1
000042  2401              MOVS     r4,#1
000044  02e4              LSLS     r4,r4,#11
000046  1914              ADDS     r4,r2,r4
000048  80a3              STRH     r3,[r4,#4]
;;;183        if (filter->index >= WINDOW_SIZE) {
00004a  2301              MOVS     r3,#1
00004c  02db              LSLS     r3,r3,#11
00004e  18d3              ADDS     r3,r2,r3
000050  889b              LDRH     r3,[r3,#4]
000052  2401              MOVS     r4,#1
000054  02a4              LSLS     r4,r4,#10
000056  42a3              CMP      r3,r4
000058  db07              BLT      |L8.106|
;;;184            filter->index = 0;
00005a  2300              MOVS     r3,#0
00005c  0064              LSLS     r4,r4,#1
00005e  1914              ADDS     r4,r2,r4
000060  80a3              STRH     r3,[r4,#4]
;;;185            filter->is_window_filled = 1;
000062  2301              MOVS     r3,#1
000064  02dc              LSLS     r4,r3,#11
000066  1914              ADDS     r4,r2,r4
000068  71a3              STRB     r3,[r4,#6]
                  |L8.106|
;;;186        }
;;;187    
;;;188        // 4-1 计算当前过采样值 过采样5位
;;;189    		if(filter->is_window_filled == 1)
00006a  2301              MOVS     r3,#1
00006c  02db              LSLS     r3,r3,#11
00006e  18d3              ADDS     r3,r2,r3
000070  799b              LDRB     r3,[r3,#6]
000072  2b01              CMP      r3,#1
000074  d102              BNE      |L8.124|
;;;190    		{
;;;191    			adcDataOver = filter->sum >> 5;
000076  6813              LDR      r3,[r2,#0]
000078  0958              LSRS     r0,r3,#5
00007a  e000              B        |L8.126|
                  |L8.124|
;;;192    		}
;;;193    	  else
;;;194    		{
;;;195    			adcDataOver = new_sample << 5;//第一个窗口按照源数据输出			
00007c  0148              LSLS     r0,r1,#5
                  |L8.126|
;;;196    		}			
;;;197        return adcDataOver;
;;;198    		
;;;199    //    // 4-2 计算当前均值（注意窗口未填满时除数不同）
;;;200    //    uint16_t valid_samples = filter->is_window_filled ? WINDOW_SIZE : filter->index;
;;;201    //    return (uint16_t)(filter->sum / valid_samples);
;;;202    }
00007e  bd30              POP      {r4,r5,pc}
;;;203    MovingAverageFilter filter;
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;206    
;;;207    int main(void)
000000  f7fffffe          BL       IcResourceInit
;;;208    {
;;;209    	
;;;210        IcResourceInit();
;;;211        TK_Init();
000004  f7fffffe          BL       TK_Init
;;;212    	
;;;213    	uint16_t raw_adc;
;;;214        uint32_t filtered_adc;
;;;215    	
;;;216    	filter_init(&filter);
000008  4831              LDR      r0,|L9.208|
00000a  f7fffffe          BL       filter_init
;;;217        OP_OffsetSet(OP);  
00000e  4831              LDR      r0,|L9.212|
000010  f7fffffe          BL       OP_OffsetSet
;;;218    	
;;;219    	PB_BIT(10)=0;
000014  2000              MOVS     r0,#0
000016  4930              LDR      r1,|L9.216|
000018  7288              STRB     r0,[r1,#0xa]
;;;220    	PB_BIT(13)=0;
00001a  7348              STRB     r0,[r1,#0xd]
;;;221    	PB_BIT(14)=0;
00001c  7388              STRB     r0,[r1,#0xe]
;;;222    	PB_BIT(15)=0;
00001e  73c8              STRB     r0,[r1,#0xf]
;;;223        while(1)
000020  e054              B        |L9.204|
                  |L9.34|
;;;224    	{
;;;225    		raw_adc = read_adc();
000022  f7fffffe          BL       read_adc
000026  4604              MOV      r4,r0
;;;226            filtered_adc = filter_update(&filter, raw_adc);
000028  4621              MOV      r1,r4
00002a  4829              LDR      r0,|L9.208|
00002c  f7fffffe          BL       filter_update
000030  4605              MOV      r5,r0
;;;227            displayNumberOnTube(filtered_adc/10);
000032  210a              MOVS     r1,#0xa
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       __aeabi_uidivmod
00003a  4606              MOV      r6,r0
00003c  f7fffffe          BL       displayNumberOnTube
;;;228    		
;;;229    		
;;;230    		
;;;231    		WDT->WDT_CON |= WDT_CON_CLRWDT;  //清watchdog
000040  4826              LDR      r0,|L9.220|
000042  6bc0              LDR      r0,[r0,#0x3c]
000044  2101              MOVS     r1,#1
000046  4308              ORRS     r0,r0,r1
000048  4924              LDR      r1,|L9.220|
00004a  63c8              STR      r0,[r1,#0x3c]
;;;232    		if(TK_TouchKeyStatus&0x80)
00004c  4824              LDR      r0,|L9.224|
00004e  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
000050  2180              MOVS     r1,#0x80
000052  4008              ANDS     r0,r0,r1
000054  2800              CMP      r0,#0
000056  d031              BEQ      |L9.188|
;;;233    		{	   													 //重要步骤3：清除标志位，需要外部清除
;;;234    			TK_TouchKeyStatus &= 0x7f; 
000058  4821              LDR      r0,|L9.224|
00005a  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
00005c  0640              LSLS     r0,r0,#25
00005e  0e40              LSRS     r0,r0,#25
000060  491f              LDR      r1,|L9.224|
000062  7008              STRB     r0,[r1,#0]
;;;235    				TK_exKeyValueFlag = TK_TouchKeyScan();  
000064  f7fffffe          BL       TK_TouchKeyScan
000068  491e              LDR      r1,|L9.228|
00006a  6008              STR      r0,[r1,#0]  ; TK_exKeyValueFlag
;;;236    				DebounceTouchKey();          // 先进行消抖处理
00006c  f7fffffe          BL       DebounceTouchKey
;;;237    				if(keyPressed)
000070  481d              LDR      r0,|L9.232|
000072  7800              LDRB     r0,[r0,#0]  ; keyPressed
000074  2800              CMP      r0,#0
000076  d01f              BEQ      |L9.184|
;;;238    				{
;;;239    					ChangeTouchKeyvalue();   // 按键数据处理函数
000078  f7fffffe          BL       ChangeTouchKeyvalue
;;;240    					if(exKeyValue==1)
00007c  481b              LDR      r0,|L9.236|
00007e  7800              LDRB     r0,[r0,#0]  ; exKeyValue
000080  2801              CMP      r0,#1
000082  d101              BNE      |L9.136|
;;;241    					{
;;;242    						PB_OT(10);
000084  4914              LDR      r1,|L9.216|
000086  7688              STRB     r0,[r1,#0x1a]
                  |L9.136|
;;;243    					}
;;;244    					if(exKeyValue==2)
000088  4818              LDR      r0,|L9.236|
00008a  7800              LDRB     r0,[r0,#0]  ; exKeyValue
00008c  2802              CMP      r0,#2
00008e  d102              BNE      |L9.150|
;;;245    					{
;;;246    						PB_OT(13);
000090  2001              MOVS     r0,#1
000092  4911              LDR      r1,|L9.216|
000094  7748              STRB     r0,[r1,#0x1d]
                  |L9.150|
;;;247    					}
;;;248    					if(exKeyValue==3)
000096  4815              LDR      r0,|L9.236|
000098  7800              LDRB     r0,[r0,#0]  ; exKeyValue
00009a  2803              CMP      r0,#3
00009c  d102              BNE      |L9.164|
;;;249    					{
;;;250    						PB_OT(14);
00009e  2001              MOVS     r0,#1
0000a0  490d              LDR      r1,|L9.216|
0000a2  7788              STRB     r0,[r1,#0x1e]
                  |L9.164|
;;;251    					}
;;;252    					if(exKeyValue==4)
0000a4  4811              LDR      r0,|L9.236|
0000a6  7800              LDRB     r0,[r0,#0]  ; exKeyValue
0000a8  2804              CMP      r0,#4
0000aa  d102              BNE      |L9.178|
;;;253    					{
;;;254    						PB_OT(15);
0000ac  2001              MOVS     r0,#1
0000ae  490a              LDR      r1,|L9.216|
0000b0  77c8              STRB     r0,[r1,#0x1f]
                  |L9.178|
;;;255    					}
;;;256    					keyPressed = 0;          // 清除按键标志
0000b2  2000              MOVS     r0,#0
0000b4  490c              LDR      r1,|L9.232|
0000b6  7008              STRB     r0,[r1,#0]
                  |L9.184|
;;;257    				}
;;;258    				TK_Restart();	         //启动下一轮转换
0000b8  f7fffffe          BL       TK_Restart
                  |L9.188|
;;;259    		  }
;;;260    		
;;;261    
;;;262    		  
;;;263    		  {
;;;264    			unsigned int i;
;;;265    			for(i = 0; i < 1000; i++);
0000bc  2000              MOVS     r0,#0
0000be  e000              B        |L9.194|
                  |L9.192|
0000c0  1c40              ADDS     r0,r0,#1
                  |L9.194|
0000c2  217d              MOVS     r1,#0x7d
0000c4  00c9              LSLS     r1,r1,#3
0000c6  4288              CMP      r0,r1
0000c8  d3fa              BCC      |L9.192|
;;;266    		}
0000ca  bf00              NOP      
                  |L9.204|
0000cc  e7a9              B        |L9.34|
;;;267    		  
;;;268    	}
;;;269    }
;;;270    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L9.208|
                          DCD      filter
                  |L9.212|
                          DCD      0x40022140
                  |L9.216|
                          DCD      0x40011100
                  |L9.220|
                          DCD      0x40000300
                  |L9.224|
                          DCD      TK_TouchKeyStatus
                  |L9.228|
                          DCD      TK_exKeyValueFlag
                  |L9.232|
                          DCD      keyPressed
                  |L9.236|
                          DCD      exKeyValue

                          AREA ||i.read_adc||, CODE, READONLY, ALIGN=2

                  read_adc PROC
;;;141    //读ADC
;;;142    uint16_t read_adc()
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144    		uint16_t	adcData ;
;;;145    		ADC_SoftwareStartConv(ADC);             //软件触发	
000002  4808              LDR      r0,|L10.36|
000004  f7fffffe          BL       ADC_SoftwareStartConv
;;;146    		while(ADC_Flag == RESET);               //等待
000008  bf00              NOP      
                  |L10.10|
00000a  4807              LDR      r0,|L10.40|
00000c  7800              LDRB     r0,[r0,#0]  ; ADC_Flag
00000e  2800              CMP      r0,#0
000010  d0fb              BEQ      |L10.10|
;;;147    		ADC_Flag = RESET;
000012  2000              MOVS     r0,#0
000014  4904              LDR      r1,|L10.40|
000016  7008              STRB     r0,[r1,#0]
;;;148    		adcData =  ADC_GetConversionValue(ADC);  //采集ADC	
000018  4802              LDR      r0,|L10.36|
00001a  f7fffffe          BL       ADC_GetConversionValue
00001e  4604              MOV      r4,r0
;;;149    	return adcData;
000020  4620              MOV      r0,r4
;;;150    }
000022  bd10              POP      {r4,pc}
;;;151    #define WINDOW_SIZE 1024  // 滑动窗口大小
                          ENDP

                  |L10.36|
                          DCD      0x40022110
                  |L10.40|
                          DCD      ADC_Flag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  filter
                          %        2056
                  display_buffer
                          %        40020

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  digitSegments
000000  d714cd5d          DCB      0xd7,0x14,0xcd,0x5d
000004  1e5bdb15          DCB      0x1e,0x5b,0xdb,0x15
000008  df5f              DCB      0xdf,0x5f
                  digitSelect
00000a  efdf              DCB      0xef,0xdf
00000c  bf7f              DCB      0xbf,0x7f

                          AREA ||.data||, DATA, ALIGN=2

                  displayNumber
                          DCD      0x00000000
                  digits
                          DCD      0x00000000
                  TK_exKeyValueFlag
                          DCD      0x00000000
                  exKeyValue
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  lastKeyValue
                          DCD      0x00000000
                  stableKeyValue
                          DCD      0x00000000
                  debounceCount
000018  00                DCB      0x00
                  keyPressed
000019  00                DCB      0x00
                  ADC_Flag
00001a  00                DCB      0x00
                  currentPosition
00001b  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_370df81d____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_370df81d____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_370df81d____REVSH|
#line 478
|__asm___6_main_c_370df81d____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
