; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\main.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\main.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -IC:\KEIL_MDK\PACK\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||i.Buzzer_PlayMelody||, CODE, READONLY, ALIGN=1

                  Buzzer_PlayMelody PROC
;;;278    // 播放整首曲子
;;;279    void Buzzer_PlayMelody(const Note* melody) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;280        uint8_t i = 0;
000004  2500              MOVS     r5,#0
;;;281        while (melody[i].duration != 0) {
000006  e008              B        |L1.26|
                  |L1.8|
;;;282            Buzzer_PlayTone(melody[i].note, melody[i].duration);
000008  00aa              LSLS     r2,r5,#2
00000a  1912              ADDS     r2,r2,r4
00000c  8851              LDRH     r1,[r2,#2]
00000e  00aa              LSLS     r2,r5,#2
000010  5ca0              LDRB     r0,[r4,r2]
000012  f7fffffe          BL       Buzzer_PlayTone
;;;283            i++;
000016  1c68              ADDS     r0,r5,#1
000018  b2c5              UXTB     r5,r0
                  |L1.26|
00001a  00a8              LSLS     r0,r5,#2              ;281
00001c  1900              ADDS     r0,r0,r4              ;281
00001e  8840              LDRH     r0,[r0,#2]            ;281
000020  2800              CMP      r0,#0                 ;281
000022  d1f1              BNE      |L1.8|
;;;284        }
;;;285    }
000024  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP


                          AREA ||i.Buzzer_PlayTone||, CODE, READONLY, ALIGN=2

                  Buzzer_PlayTone PROC
;;;233    // 播放单个音符
;;;234    void Buzzer_PlayTone(uint8_t note, uint16_t duration_ms) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4607              MOV      r7,r0
000004  460c              MOV      r4,r1
;;;235        uint16_t frequency = noteFrequencies[note];
000006  0078              LSLS     r0,r7,#1
000008  4913              LDR      r1,|L2.88|
00000a  5a0d              LDRH     r5,[r1,r0]
;;;236        if (frequency == 0) {
00000c  2d00              CMP      r5,#0
00000e  d106              BNE      |L2.30|
;;;237            // 休止符：静音，简单延迟
;;;238            delay_us(duration_ms * 1000UL);
000010  217d              MOVS     r1,#0x7d
000012  00c9              LSLS     r1,r1,#3
000014  4361              MULS     r1,r4,r1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       delay_us
                  |L2.28|
;;;239            return;
;;;240        }
;;;241        
;;;242        // 计算半周期微秒 (500000 / freq，避免浮点)
;;;243        uint32_t half_period_us = 500000UL / frequency;
;;;244        
;;;245        // 计算总循环次数 (duration_ms * 1000 / (2 * half_period_us)) = duration_ms * frequency / 1000
;;;246        uint32_t loops = (uint32_t)duration_ms * frequency / 1000UL;
;;;247        
;;;248        for (uint32_t i = 0; i < loops; i++) {
;;;249            PC_OT(9);  // 翻转引脚
;;;250            delay_us(half_period_us);  // 延迟半周期
;;;251        }
;;;252        
;;;253        // 结束后静音一小会儿，避免音符黏连（可选，20ms）
;;;254        delay_us(20000);
;;;255    }
00001c  bdf8              POP      {r3-r7,pc}
                  |L2.30|
00001e  4629              MOV      r1,r5                 ;243
000020  480e              LDR      r0,|L2.92|
000022  f7fffffe          BL       __aeabi_uidivmod
000026  9000              STR      r0,[sp,#0]            ;243
000028  4621              MOV      r1,r4                 ;246
00002a  4369              MULS     r1,r5,r1              ;246
00002c  4608              MOV      r0,r1                 ;246
00002e  217d              MOVS     r1,#0x7d              ;246
000030  00c9              LSLS     r1,r1,#3              ;246
000032  f7fffffe          BL       __aeabi_uidivmod
000036  4606              MOV      r6,r0                 ;246
000038  2300              MOVS     r3,#0                 ;248
00003a  e006              B        |L2.74|
                  |L2.60|
00003c  2001              MOVS     r0,#1                 ;249
00003e  4908              LDR      r1,|L2.96|
000040  7648              STRB     r0,[r1,#0x19]         ;249
000042  9800              LDR      r0,[sp,#0]            ;250
000044  f7fffffe          BL       delay_us
000048  1c5b              ADDS     r3,r3,#1              ;248
                  |L2.74|
00004a  42b3              CMP      r3,r6                 ;248
00004c  d3f6              BCC      |L2.60|
00004e  4805              LDR      r0,|L2.100|
000050  f7fffffe          BL       delay_us
000054  bf00              NOP      
000056  e7e1              B        |L2.28|
;;;256    
                          ENDP

                  |L2.88|
                          DCD      noteFrequencies
                  |L2.92|
                          DCD      0x0007a120
                  |L2.96|
                          DCD      0x40011200
                  |L2.100|
                          DCD      0x00004e20

                          AREA ||i.ChangeTouchKeyvalue||, CODE, READONLY, ALIGN=2

                  ChangeTouchKeyvalue PROC
;;;506      */
;;;507    void ChangeTouchKeyvalue(void)
000000  4810              LDR      r0,|L3.68|
;;;508    {
;;;509        switch(stableKeyValue)
000002  6800              LDR      r0,[r0,#0]  ; stableKeyValue
000004  2810              CMP      r0,#0x10
000006  d006              BEQ      |L3.22|
000008  2820              CMP      r0,#0x20
00000a  d008              BEQ      |L3.30|
00000c  2840              CMP      r0,#0x40
00000e  d00a              BEQ      |L3.38|
000010  2880              CMP      r0,#0x80
000012  d110              BNE      |L3.54|
000014  e00b              B        |L3.46|
                  |L3.22|
;;;510        {
;;;511            case 0x00000010:
;;;512                exKeyValue = 1;
000016  2001              MOVS     r0,#1
000018  490b              LDR      r1,|L3.72|
00001a  7008              STRB     r0,[r1,#0]
;;;513                break;
00001c  e00f              B        |L3.62|
                  |L3.30|
;;;514            case 0x00000020:
;;;515                exKeyValue = 2;
00001e  2002              MOVS     r0,#2
000020  4909              LDR      r1,|L3.72|
000022  7008              STRB     r0,[r1,#0]
;;;516                break;
000024  e00b              B        |L3.62|
                  |L3.38|
;;;517            case 0x00000040:
;;;518                exKeyValue = 3;
000026  2003              MOVS     r0,#3
000028  4907              LDR      r1,|L3.72|
00002a  7008              STRB     r0,[r1,#0]
;;;519                break;
00002c  e007              B        |L3.62|
                  |L3.46|
;;;520            case 0x00000080:
;;;521                exKeyValue = 4;
00002e  2004              MOVS     r0,#4
000030  4905              LDR      r1,|L3.72|
000032  7008              STRB     r0,[r1,#0]
;;;522                break;
000034  e003              B        |L3.62|
                  |L3.54|
;;;523            default:
;;;524                exKeyValue = 0xff;
000036  20ff              MOVS     r0,#0xff
000038  4903              LDR      r1,|L3.72|
00003a  7008              STRB     r0,[r1,#0]
;;;525                break;
00003c  bf00              NOP      
                  |L3.62|
00003e  bf00              NOP                            ;513
;;;526        }
;;;527    }
000040  4770              BX       lr
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      stableKeyValue
                  |L3.72|
                          DCD      exKeyValue

                          AREA ||i.DBL||, CODE, READONLY, ALIGN=2

                  ||DBL|| PROC
;;;290    
;;;291    void DBL()
000000  2001              MOVS     r0,#1
;;;292    {
;;;293    	PB_BIT(10)=1;
000002  4905              LDR      r1,|L4.24|
000004  7288              STRB     r0,[r1,#0xa]
;;;294        PB_BIT(13)=1;
000006  7348              STRB     r0,[r1,#0xd]
;;;295        PB_BIT(14)=1;
000008  7388              STRB     r0,[r1,#0xe]
;;;296        PB_BIT(15)=1;
00000a  73c8              STRB     r0,[r1,#0xf]
;;;297    	PA_BIT(6)=1;
00000c  4903              LDR      r1,|L4.28|
00000e  7188              STRB     r0,[r1,#6]
;;;298    	PA_BIT(7)=1;
000010  71c8              STRB     r0,[r1,#7]
;;;299    	PA_BIT(8)=1;
000012  7208              STRB     r0,[r1,#8]
;;;300    	PA_BIT(9)=1;
000014  7248              STRB     r0,[r1,#9]
;;;301    }
000016  4770              BX       lr
;;;302    
                          ENDP

                  |L4.24|
                          DCD      0x40011100
                  |L4.28|
                          DCD      0x40011000

                          AREA ||i.DebounceTouchKey||, CODE, READONLY, ALIGN=2

                  DebounceTouchKey PROC
;;;474      */
;;;475    void DebounceTouchKey(void)
000000  4817              LDR      r0,|L5.96|
;;;476    {
;;;477        if(TK_exKeyValueFlag == lastKeyValue)
000002  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
000004  4917              LDR      r1,|L5.100|
000006  6809              LDR      r1,[r1,#0]  ; lastKeyValue
000008  4288              CMP      r0,r1
00000a  d119              BNE      |L5.64|
;;;478        {
;;;479            debounceCount++;
00000c  4816              LDR      r0,|L5.104|
00000e  7800              LDRB     r0,[r0,#0]  ; debounceCount
000010  1c40              ADDS     r0,r0,#1
000012  4915              LDR      r1,|L5.104|
000014  7008              STRB     r0,[r1,#0]
;;;480            if(debounceCount >= 5)
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; debounceCount
00001a  2805              CMP      r0,#5
00001c  db17              BLT      |L5.78|
;;;481            {
;;;482                if(stableKeyValue != TK_exKeyValueFlag)
00001e  4813              LDR      r0,|L5.108|
000020  6800              LDR      r0,[r0,#0]  ; stableKeyValue
000022  490f              LDR      r1,|L5.96|
000024  6809              LDR      r1,[r1,#0]  ; TK_exKeyValueFlag
000026  4288              CMP      r0,r1
000028  d006              BEQ      |L5.56|
;;;483                {
;;;484                    stableKeyValue = TK_exKeyValueFlag;
00002a  480d              LDR      r0,|L5.96|
00002c  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
00002e  490f              LDR      r1,|L5.108|
000030  6008              STR      r0,[r1,#0]  ; stableKeyValue
;;;485                    keyPressed = 1;
000032  2001              MOVS     r0,#1
000034  490e              LDR      r1,|L5.112|
000036  7008              STRB     r0,[r1,#0]
                  |L5.56|
;;;486                }
;;;487                debounceCount = 5;
000038  2005              MOVS     r0,#5
00003a  490b              LDR      r1,|L5.104|
00003c  7008              STRB     r0,[r1,#0]
00003e  e006              B        |L5.78|
                  |L5.64|
;;;488            }
;;;489        }
;;;490        else
;;;491        {
;;;492            debounceCount = 0;
000040  2000              MOVS     r0,#0
000042  4909              LDR      r1,|L5.104|
000044  7008              STRB     r0,[r1,#0]
;;;493            lastKeyValue = TK_exKeyValueFlag;
000046  4806              LDR      r0,|L5.96|
000048  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
00004a  4906              LDR      r1,|L5.100|
00004c  6008              STR      r0,[r1,#0]  ; lastKeyValue
                  |L5.78|
;;;494        }
;;;495      
;;;496        if(TK_exKeyValueFlag == 0)
00004e  4804              LDR      r0,|L5.96|
000050  6800              LDR      r0,[r0,#0]  ; TK_exKeyValueFlag
000052  2800              CMP      r0,#0
000054  d103              BNE      |L5.94|
;;;497        {
;;;498            debounceCount = 0;
000056  4904              LDR      r1,|L5.104|
000058  7008              STRB     r0,[r1,#0]
;;;499            stableKeyValue = 0;
00005a  4904              LDR      r1,|L5.108|
00005c  6008              STR      r0,[r1,#0]  ; stableKeyValue
                  |L5.94|
;;;500        }
;;;501    }
00005e  4770              BX       lr
;;;502    /**
                          ENDP

                  |L5.96|
                          DCD      TK_exKeyValueFlag
                  |L5.100|
                          DCD      lastKeyValue
                  |L5.104|
                          DCD      debounceCount
                  |L5.108|
                          DCD      stableKeyValue
                  |L5.112|
                          DCD      keyPressed

                          AREA ||i.Kalman_Init||, CODE, READONLY, ALIGN=1

                  Kalman_Init PROC
;;;146    // 初始化卡尔曼滤波器（建议在 main() 开头调用一次）
;;;147    void Kalman_Init(KalmanFilter *kf, float init_value, float q, float r) {
000000  b510              PUSH     {r4,lr}
;;;148        kf->x = init_value; // 初始估计值
000002  6001              STR      r1,[r0,#0]
;;;149        kf->p = 1.0f; // 初始误差协方差
000004  247f              MOVS     r4,#0x7f
000006  05e4              LSLS     r4,r4,#23
000008  6044              STR      r4,[r0,#4]
;;;150        kf->q = q; // 过程噪声
00000a  6082              STR      r2,[r0,#8]
;;;151        kf->r = r; // 测量噪声
00000c  60c3              STR      r3,[r0,#0xc]
;;;152    }
00000e  bd10              POP      {r4,pc}
;;;153    // 卡尔曼滤波核心函数（每次新采样后调用）
                          ENDP


                          AREA ||i.Kalman_Update||, CODE, READONLY, ALIGN=1

                  Kalman_Update PROC
;;;153    // 卡尔曼滤波核心函数（每次新采样后调用）
;;;154    float Kalman_Update(KalmanFilter *kf, float measurement) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;155        // 预测步骤
;;;156        kf->p = kf->p + kf->q;
000006  68a1              LDR      r1,[r4,#8]
000008  6860              LDR      r0,[r4,#4]
00000a  f7fffffe          BL       __aeabi_fadd
00000e  6060              STR      r0,[r4,#4]
;;;157        // 更新步骤
;;;158        kf->kg = kf->p / (kf->p + kf->r);
000010  68e1              LDR      r1,[r4,#0xc]
000012  6860              LDR      r0,[r4,#4]
000014  f7fffffe          BL       __aeabi_fadd
000018  4606              MOV      r6,r0
00001a  4631              MOV      r1,r6
00001c  6860              LDR      r0,[r4,#4]
00001e  f7fffffe          BL       __aeabi_fdiv
000022  6120              STR      r0,[r4,#0x10]
;;;159        kf->x = kf->x + kf->kg * (measurement - kf->x);
000024  4628              MOV      r0,r5
000026  6821              LDR      r1,[r4,#0]
000028  f7fffffe          BL       __aeabi_fsub
00002c  4607              MOV      r7,r0
00002e  6921              LDR      r1,[r4,#0x10]
000030  f7fffffe          BL       __aeabi_fmul
000034  4606              MOV      r6,r0
000036  6821              LDR      r1,[r4,#0]
000038  f7fffffe          BL       __aeabi_fadd
00003c  6020              STR      r0,[r4,#0]
;;;160        kf->p = (1.0f - kf->kg) * kf->p;
00003e  207f              MOVS     r0,#0x7f
000040  05c0              LSLS     r0,r0,#23
000042  6921              LDR      r1,[r4,#0x10]
000044  f7fffffe          BL       __aeabi_fsub
000048  4606              MOV      r6,r0
00004a  6861              LDR      r1,[r4,#4]
00004c  f7fffffe          BL       __aeabi_fmul
000050  6060              STR      r0,[r4,#4]
;;;161        return kf->x; // 返回当前最优估计值
000052  6820              LDR      r0,[r4,#0]
;;;162    }
000054  bdf8              POP      {r3-r7,pc}
;;;163    
                          ENDP


                          AREA ||i.WBB_Reset||, CODE, READONLY, ALIGN=2

                  WBB_Reset PROC
;;;171    
;;;172    void WBB_Reset(void) {
000000  2000              MOVS     r0,#0
;;;173        wbb_index = 0;
000002  4903              LDR      r1,|L8.16|
000004  8008              STRH     r0,[r1,#0]
;;;174        wbb_full = 0;
000006  4903              LDR      r1,|L8.20|
000008  7008              STRB     r0,[r1,#0]
;;;175        wbb_stable_value = 0.0f;
00000a  4903              LDR      r1,|L8.24|
00000c  6008              STR      r0,[r1,#0]  ; wbb_stable_value
;;;176    }
00000e  4770              BX       lr
;;;177    
                          ENDP

                  |L8.16|
                          DCD      wbb_index
                  |L8.20|
                          DCD      wbb_full
                  |L8.24|
                          DCD      wbb_stable_value

                          AREA ||i.decomposeNumber||, CODE, READONLY, ALIGN=2

                  decomposeNumber PROC
;;;55       */
;;;56     void decomposeNumber(unsigned int num)
000000  b570              PUSH     {r4-r6,lr}
;;;57     {
000002  4604              MOV      r4,r0
;;;58         digits[0] = num % 10; // 个位
000004  210a              MOVS     r1,#0xa
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       __aeabi_uidivmod
00000c  4810              LDR      r0,|L9.80|
00000e  7001              STRB     r1,[r0,#0]
;;;59         digits[1] = (num / 10) % 10; // 十位
000010  210a              MOVS     r1,#0xa
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_uidivmod
000018  4605              MOV      r5,r0
00001a  210a              MOVS     r1,#0xa
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  480b              LDR      r0,|L9.80|
000022  7041              STRB     r1,[r0,#1]
;;;60         digits[2] = (num / 100) % 10; // 百位
000024  2164              MOVS     r1,#0x64
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  4605              MOV      r5,r0
00002e  210a              MOVS     r1,#0xa
000030  f7fffffe          BL       __aeabi_uidivmod
000034  4806              LDR      r0,|L9.80|
000036  7081              STRB     r1,[r0,#2]
;;;61         digits[3] = (num / 1000) % 10; // 千位
000038  217d              MOVS     r1,#0x7d
00003a  00c9              LSLS     r1,r1,#3
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  4605              MOV      r5,r0
000044  210a              MOVS     r1,#0xa
000046  f7fffffe          BL       __aeabi_uidivmod
00004a  4801              LDR      r0,|L9.80|
00004c  70c1              STRB     r1,[r0,#3]
;;;62     }
00004e  bd70              POP      {r4-r6,pc}
;;;63     /**
                          ENDP

                  |L9.80|
                          DCD      digits

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=1

                  delay_us PROC
;;;218    // 超精确的微秒延迟（64MHz 时钟下校准，手动 nop 版）
;;;219    void delay_us(uint32_t us) {
000000  e00c              B        |L10.28|
                  |L10.2|
;;;220        while (us--) {
;;;221            // 下面这一坨 nop 大概消耗 58~60 个周期，接近 1us
;;;222            // 你可以实际听声音，多加或减几个 nop 来微调
;;;223            __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop");
000002  bf00              NOP      
000004  bf00              NOP      
000006  bf00              NOP      
;;;224            __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop");
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;225            __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop");
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
;;;226            __asm volatile ("nop"); __asm volatile ("nop"); __asm volatile ("nop"); 
000014  bf00              NOP      
000016  bf00              NOP      
000018  bf00              NOP      
;;;227            __asm volatile ("nop");
00001a  bf00              NOP      
                  |L10.28|
00001c  4601              MOV      r1,r0                 ;220
00001e  1e40              SUBS     r0,r0,#1              ;220
000020  2900              CMP      r1,#0                 ;220
000022  d1ee              BNE      |L10.2|
;;;228            // 一共大概 58 个 nop，你听声音高了就删几行，低了就再复制几行
;;;229        }
;;;230    }
000024  4770              BX       lr
;;;231    
                          ENDP


                          AREA ||i.displayDigit||, CODE, READONLY, ALIGN=2

                  displayDigit PROC
;;;67       */
;;;68     void displayDigit(unsigned char digit, unsigned char position)
000000  b510              PUSH     {r4,lr}
;;;69     {
000002  4602              MOV      r2,r0
;;;70         if (digit > 9) return; // 数字范围检查
000004  2a09              CMP      r2,#9
000006  dd00              BLE      |L11.10|
                  |L11.8|
;;;71       
;;;72         // 设置位选
;;;73         PA_BIT(6) = (digitSelect[position] >> 4) & 0x01;
;;;74         PA_BIT(7) = (digitSelect[position] >> 5) & 0x01;
;;;75         PA_BIT(8) = (digitSelect[position] >> 6) & 0x01;
;;;76         PA_BIT(9) = (digitSelect[position] >> 7) & 0x01;
;;;77       
;;;78         // 设置段选
;;;79         unsigned char seg = digitSegments[digit];
;;;80         PB_BIT(2) = (seg >> 0) & 0x01; // a
;;;81         PB_BIT(3) = (seg >> 1) & 0x01; // f
;;;82         PB_BIT(4) = (seg >> 2) & 0x01; // b
;;;83         PB_BIT(5) = (seg >> 3) & 0x01; // g
;;;84         PB_BIT(6) = (seg >> 4) & 0x01; // c
;;;85         PB_BIT(7) = (seg >> 5) & 0x01; // dp
;;;86         PB_BIT(8) = (seg >> 6) & 0x01; // d
;;;87         PB_BIT(9) = (seg >> 7) & 0x01; // e
;;;88     }
000008  bd10              POP      {r4,pc}
                  |L11.10|
00000a  4b18              LDR      r3,|L11.108|
00000c  5c5b              LDRB     r3,[r3,r1]            ;73
00000e  06db              LSLS     r3,r3,#27             ;73
000010  0fdb              LSRS     r3,r3,#31             ;73
000012  4c17              LDR      r4,|L11.112|
000014  71a3              STRB     r3,[r4,#6]            ;73
000016  4b15              LDR      r3,|L11.108|
000018  5c5b              LDRB     r3,[r3,r1]            ;74
00001a  069b              LSLS     r3,r3,#26             ;74
00001c  0fdb              LSRS     r3,r3,#31             ;74
00001e  71e3              STRB     r3,[r4,#7]            ;74
000020  4b12              LDR      r3,|L11.108|
000022  5c5b              LDRB     r3,[r3,r1]            ;75
000024  065b              LSLS     r3,r3,#25             ;75
000026  0fdb              LSRS     r3,r3,#31             ;75
000028  7223              STRB     r3,[r4,#8]            ;75
00002a  4b10              LDR      r3,|L11.108|
00002c  5c5b              LDRB     r3,[r3,r1]            ;76
00002e  11db              ASRS     r3,r3,#7              ;76
000030  7263              STRB     r3,[r4,#9]            ;76
000032  4b10              LDR      r3,|L11.116|
000034  5c98              LDRB     r0,[r3,r2]            ;79
000036  07c3              LSLS     r3,r0,#31             ;80
000038  0fdb              LSRS     r3,r3,#31             ;80
00003a  4c0f              LDR      r4,|L11.120|
00003c  70a3              STRB     r3,[r4,#2]            ;80
00003e  0783              LSLS     r3,r0,#30             ;81
000040  0fdb              LSRS     r3,r3,#31             ;81
000042  70e3              STRB     r3,[r4,#3]            ;81
000044  0743              LSLS     r3,r0,#29             ;82
000046  0fdb              LSRS     r3,r3,#31             ;82
000048  7123              STRB     r3,[r4,#4]            ;82
00004a  0703              LSLS     r3,r0,#28             ;83
00004c  0fdb              LSRS     r3,r3,#31             ;83
00004e  7163              STRB     r3,[r4,#5]            ;83
000050  06c3              LSLS     r3,r0,#27             ;84
000052  0fdb              LSRS     r3,r3,#31             ;84
000054  71a3              STRB     r3,[r4,#6]            ;84
000056  0683              LSLS     r3,r0,#26             ;85
000058  0fdb              LSRS     r3,r3,#31             ;85
00005a  71e3              STRB     r3,[r4,#7]            ;85
00005c  0643              LSLS     r3,r0,#25             ;86
00005e  0fdb              LSRS     r3,r3,#31             ;86
000060  7223              STRB     r3,[r4,#8]            ;86
000062  11c3              ASRS     r3,r0,#7              ;87
000064  7263              STRB     r3,[r4,#9]            ;87
000066  bf00              NOP      
000068  e7ce              B        |L11.8|
;;;89     /**
                          ENDP

00006a  0000              DCW      0x0000
                  |L11.108|
                          DCD      digitSelect
                  |L11.112|
                          DCD      0x40011000
                  |L11.116|
                          DCD      digitSegments
                  |L11.120|
                          DCD      0x40011100

                          AREA ||i.displayNumberOnTube||, CODE, READONLY, ALIGN=2

                  displayNumberOnTube PROC
;;;92       */
;;;93     void displayNumberOnTube(unsigned int num)
000000  b510              PUSH     {r4,lr}
;;;94     {
000002  4604              MOV      r4,r0
;;;95         decomposeNumber(num);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       decomposeNumber
;;;96       
;;;97         // 动态扫描显示4位数码管
;;;98         static unsigned char currentPosition = 0;
;;;99       
;;;100        displayDigit(digits[currentPosition], currentPosition);
00000a  490a              LDR      r1,|L12.52|
00000c  4a0a              LDR      r2,|L12.56|
00000e  7812              LDRB     r2,[r2,#0]  ; currentPosition
000010  5c88              LDRB     r0,[r1,r2]
000012  4909              LDR      r1,|L12.56|
000014  7809              LDRB     r1,[r1,#0]  ; currentPosition
000016  f7fffffe          BL       displayDigit
;;;101      
;;;102        currentPosition++;
00001a  4807              LDR      r0,|L12.56|
00001c  7800              LDRB     r0,[r0,#0]  ; currentPosition
00001e  1c40              ADDS     r0,r0,#1
000020  4905              LDR      r1,|L12.56|
000022  7008              STRB     r0,[r1,#0]
;;;103        if (currentPosition >= 4) {
000024  4608              MOV      r0,r1
000026  7800              LDRB     r0,[r0,#0]  ; currentPosition
000028  2804              CMP      r0,#4
00002a  db01              BLT      |L12.48|
;;;104            currentPosition = 0;
00002c  2000              MOVS     r0,#0
00002e  7008              STRB     r0,[r1,#0]
                  |L12.48|
;;;105        }
;;;106    }
000030  bd10              POP      {r4,pc}
;;;107    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      digits
                  |L12.56|
                          DCD      currentPosition

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;303    
;;;304    int main(void)
000000  b08e              SUB      sp,sp,#0x38
;;;305    {
;;;306        IcResourceInit();
000002  f7fffffe          BL       IcResourceInit
;;;307        TK_Init();
000006  f7fffffe          BL       TK_Init
;;;308        int sum=0,xiuzheng=0;
00000a  2000              MOVS     r0,#0
00000c  900d              STR      r0,[sp,#0x34]
00000e  900c              STR      r0,[sp,#0x30]
;;;309        uint16_t first_adc = read_adc(); // 先读一次作为初始值
000010  f7fffffe          BL       read_adc
000014  900b              STR      r0,[sp,#0x2c]
;;;310        Kalman_Init(&kf_weight, (float)first_adc, 0.01f, 1500.0f); // 强滤波，空秤稳
000016  980b              LDR      r0,[sp,#0x2c]
000018  f7fffffe          BL       __aeabi_ui2f
00001c  4604              MOV      r4,r0
00001e  4bb6              LDR      r3,|L13.760|
000020  4ab6              LDR      r2,|L13.764|
000022  4621              MOV      r1,r4
000024  48b6              LDR      r0,|L13.768|
000026  f7fffffe          BL       Kalman_Init
;;;311        WBB_Reset(); // 初始化歪比巴卜缓冲区
00002a  f7fffffe          BL       WBB_Reset
;;;312        OP_OffsetSet(OP);
00002e  48b5              LDR      r0,|L13.772|
000030  f7fffffe          BL       OP_OffsetSet
;;;313        PB_BIT(10)=0;
000034  2000              MOVS     r0,#0
000036  49b4              LDR      r1,|L13.776|
000038  7288              STRB     r0,[r1,#0xa]
;;;314        PB_BIT(13)=0;
00003a  7348              STRB     r0,[r1,#0xd]
;;;315        PB_BIT(14)=0;
00003c  7388              STRB     r0,[r1,#0xe]
;;;316        PB_BIT(15)=0;
00003e  73c8              STRB     r0,[r1,#0xf]
;;;317    
;;;318    	int counter = 0;
000040  2700              MOVS     r7,#0
;;;319    	int sleep = 0;
000042  900a              STR      r0,[sp,#0x28]
;;;320    	int qian=0;
000044  9009              STR      r0,[sp,#0x24]
;;;321    	
;;;322        while(1)
000046  e155              B        |L13.756|
                  |L13.72|
;;;323        {
;;;324            uint16_t raw_adc = read_adc(); // 已平均的值
000048  f7fffffe          BL       read_adc
00004c  9008              STR      r0,[sp,#0x20]
;;;325            // 卡尔曼滤波更新
;;;326            float kalman_filtered = Kalman_Update(&kf_weight, (float)raw_adc);
00004e  9808              LDR      r0,[sp,#0x20]
000050  f7fffffe          BL       __aeabi_ui2f
000054  4606              MOV      r6,r0
000056  4631              MOV      r1,r6
000058  48a9              LDR      r0,|L13.768|
00005a  f7fffffe          BL       Kalman_Update
00005e  4605              MOV      r5,r0
;;;327           
;;;328            // === 歪比巴卜核心：存入缓冲区 ===
;;;329            wbb_buffer[wbb_index] = kalman_filtered;
000060  48aa              LDR      r0,|L13.780|
000062  8800              LDRH     r0,[r0,#0]  ; wbb_index
000064  0080              LSLS     r0,r0,#2
000066  49aa              LDR      r1,|L13.784|
000068  500d              STR      r5,[r1,r0]
;;;330            wbb_index++;
00006a  48a8              LDR      r0,|L13.780|
00006c  8800              LDRH     r0,[r0,#0]  ; wbb_index
00006e  1c40              ADDS     r0,r0,#1
000070  49a6              LDR      r1,|L13.780|
000072  8008              STRH     r0,[r1,#0]
;;;331            if (wbb_index >= WBB_BUFFER_SIZE) {
000074  4608              MOV      r0,r1
000076  8800              LDRH     r0,[r0,#0]  ; wbb_index
000078  217d              MOVS     r1,#0x7d
00007a  00c9              LSLS     r1,r1,#3
00007c  4288              CMP      r0,r1
00007e  db05              BLT      |L13.140|
;;;332                wbb_index = 0;
000080  2000              MOVS     r0,#0
000082  49a2              LDR      r1,|L13.780|
000084  8008              STRH     r0,[r1,#0]
;;;333                wbb_full = 1; // 缓冲区已满
000086  2001              MOVS     r0,#1
000088  49a2              LDR      r1,|L13.788|
00008a  7008              STRB     r0,[r1,#0]
                  |L13.140|
;;;334            }
;;;335            
;;;336            // === 计算稳定中值（仅当缓冲区满时）===
;;;337            float current_stable = kalman_filtered; // 默认用当前Kalman值（缓冲未满时）
00008c  9507              STR      r5,[sp,#0x1c]
;;;338            if (wbb_full) {
00008e  48a1              LDR      r0,|L13.788|
000090  7800              LDRB     r0,[r0,#0]  ; wbb_full
000092  2800              CMP      r0,#0
000094  d040              BEQ      |L13.280|
;;;339                float max_val = wbb_buffer[0];
000096  489e              LDR      r0,|L13.784|
000098  6800              LDR      r0,[r0,#0]  ; wbb_buffer
00009a  9003              STR      r0,[sp,#0xc]
;;;340                float min_val = wbb_buffer[0];
00009c  489c              LDR      r0,|L13.784|
00009e  6800              LDR      r0,[r0,#0]  ; wbb_buffer
0000a0  9002              STR      r0,[sp,#8]
;;;341                for (uint16_t i = 1; i < WBB_BUFFER_SIZE; i++) {
0000a2  2601              MOVS     r6,#1
0000a4  e017              B        |L13.214|
                  |L13.166|
;;;342                    if (wbb_buffer[i] > max_val) max_val = wbb_buffer[i];
0000a6  00b1              LSLS     r1,r6,#2
0000a8  4a99              LDR      r2,|L13.784|
0000aa  5850              LDR      r0,[r2,r1]
0000ac  9903              LDR      r1,[sp,#0xc]
0000ae  f7fffffe          BL       __aeabi_cfrcmple
0000b2  d203              BCS      |L13.188|
0000b4  00b0              LSLS     r0,r6,#2
0000b6  4996              LDR      r1,|L13.784|
0000b8  5808              LDR      r0,[r1,r0]
0000ba  9003              STR      r0,[sp,#0xc]
                  |L13.188|
;;;343                    if (wbb_buffer[i] < min_val) min_val = wbb_buffer[i];
0000bc  00b1              LSLS     r1,r6,#2
0000be  4a94              LDR      r2,|L13.784|
0000c0  5850              LDR      r0,[r2,r1]
0000c2  9902              LDR      r1,[sp,#8]
0000c4  f7fffffe          BL       __aeabi_cfcmple
0000c8  d203              BCS      |L13.210|
0000ca  00b0              LSLS     r0,r6,#2
0000cc  4990              LDR      r1,|L13.784|
0000ce  5808              LDR      r0,[r1,r0]
0000d0  9002              STR      r0,[sp,#8]
                  |L13.210|
0000d2  1c70              ADDS     r0,r6,#1              ;341
0000d4  b286              UXTH     r6,r0                 ;341
                  |L13.214|
0000d6  207d              MOVS     r0,#0x7d              ;341
0000d8  00c0              LSLS     r0,r0,#3              ;341
0000da  4286              CMP      r6,r0                 ;341
0000dc  dbe3              BLT      |L13.166|
;;;344                }
;;;345                float mid_val = (max_val + min_val) / 2.0f;
0000de  9902              LDR      r1,[sp,#8]
0000e0  9803              LDR      r0,[sp,#0xc]
0000e2  f7fffffe          BL       __aeabi_fadd
0000e6  4606              MOV      r6,r0
0000e8  2101              MOVS     r1,#1
0000ea  0789              LSLS     r1,r1,#30
0000ec  f7fffffe          BL       __aeabi_fdiv
0000f0  9001              STR      r0,[sp,#4]
;;;346                // 轻微平滑，避免小抖动
;;;347                current_stable = 0.3f * wbb_stable_value + 0.7f * mid_val;
0000f2  4889              LDR      r0,|L13.792|
0000f4  9901              LDR      r1,[sp,#4]
0000f6  f7fffffe          BL       __aeabi_fmul
0000fa  4606              MOV      r6,r0
0000fc  4887              LDR      r0,|L13.796|
0000fe  6801              LDR      r1,[r0,#0]  ; wbb_stable_value
000100  4887              LDR      r0,|L13.800|
000102  f7fffffe          BL       __aeabi_fmul
000106  4631              MOV      r1,r6
000108  9000              STR      r0,[sp,#0]
00010a  f7fffffe          BL       __aeabi_fadd
00010e  9007              STR      r0,[sp,#0x1c]
;;;348                wbb_stable_value = current_stable;
000110  4982              LDR      r1,|L13.796|
000112  9807              LDR      r0,[sp,#0x1c]
000114  6008              STR      r0,[r1,#0]  ; wbb_stable_value
;;;349            }
000116  bf00              NOP      
                  |L13.280|
;;;350            
;;;351            // === 检测大变化，重置缓冲区 ===
;;;352    		float sss;
;;;353    		if(kalman_filtered>wbb_stable_value) sss=kalman_filtered-wbb_stable_value;
000118  4880              LDR      r0,|L13.796|
00011a  6801              LDR      r1,[r0,#0]  ; wbb_stable_value
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       __aeabi_cfrcmple
000122  d206              BCS      |L13.306|
000124  487d              LDR      r0,|L13.796|
000126  6801              LDR      r1,[r0,#0]  ; wbb_stable_value
000128  4628              MOV      r0,r5
00012a  f7fffffe          BL       __aeabi_fsub
00012e  9006              STR      r0,[sp,#0x18]
000130  e005              B        |L13.318|
                  |L13.306|
;;;354    		else sss=wbb_stable_value-kalman_filtered;
000132  4629              MOV      r1,r5
000134  4879              LDR      r0,|L13.796|
000136  6800              LDR      r0,[r0,#0]  ; wbb_stable_value
000138  f7fffffe          BL       __aeabi_fsub
00013c  9006              STR      r0,[sp,#0x18]
                  |L13.318|
;;;355            if ((sss > 9000.0f) || (!wbb_full && wbb_index > 500)) {
00013e  4979              LDR      r1,|L13.804|
000140  9806              LDR      r0,[sp,#0x18]
000142  f7fffffe          BL       __aeabi_cfrcmple
000146  d309              BCC      |L13.348|
000148  4872              LDR      r0,|L13.788|
00014a  7800              LDRB     r0,[r0,#0]  ; wbb_full
00014c  2800              CMP      r0,#0
00014e  d10a              BNE      |L13.358|
000150  486e              LDR      r0,|L13.780|
000152  8800              LDRH     r0,[r0,#0]  ; wbb_index
000154  21ff              MOVS     r1,#0xff
000156  31f5              ADDS     r1,r1,#0xf5
000158  4288              CMP      r0,r1
00015a  dd04              BLE      |L13.358|
                  |L13.348|
;;;356                WBB_Reset(); // 重置，重新收集数据
00015c  f7fffffe          BL       WBB_Reset
;;;357                wbb_stable_value = kalman_filtered; // 临时用当前值
000160  486e              LDR      r0,|L13.796|
000162  6005              STR      r5,[r0,#0]  ; wbb_stable_value
;;;358                current_stable = kalman_filtered;
000164  9507              STR      r5,[sp,#0x1c]
                  |L13.358|
;;;359            }
;;;360            
;;;361            // 计算去皮后的浮点值
;;;362            float current_float = current_stable - pi_value_float;
000166  4870              LDR      r0,|L13.808|
000168  6801              LDR      r1,[r0,#0]  ; pi_value_float
00016a  9807              LDR      r0,[sp,#0x1c]
00016c  f7fffffe          BL       __aeabi_fsub
000170  9005              STR      r0,[sp,#0x14]
;;;363            if(current_float < 0.0f) current_float = 0.0f;
000172  2100              MOVS     r1,#0
000174  9805              LDR      r0,[sp,#0x14]
000176  f7fffffe          BL       __aeabi_cfcmple
00017a  d201              BCS      |L13.384|
00017c  2000              MOVS     r0,#0
00017e  9005              STR      r0,[sp,#0x14]
                  |L13.384|
;;;364            // 四舍五入到最近的整数
;;;365            uint32_t show_value = (uint32_t)(current_float + 0.5f);
000180  213f              MOVS     r1,#0x3f
000182  0609              LSLS     r1,r1,#24
000184  9805              LDR      r0,[sp,#0x14]
000186  f7fffffe          BL       __aeabi_fadd
00018a  4606              MOV      r6,r0
00018c  f7fffffe          BL       __aeabi_f2uiz
000190  4604              MOV      r4,r0
;;;366            
;;;367    		int Oversize = 0;
000192  2000              MOVS     r0,#0
000194  9004              STR      r0,[sp,#0x10]
;;;368    		if(show_value+xiuzheng>1000)
000196  990c              LDR      r1,[sp,#0x30]
000198  1860              ADDS     r0,r4,r1
00019a  217d              MOVS     r1,#0x7d
00019c  00c9              LSLS     r1,r1,#3
00019e  4288              CMP      r0,r1
0001a0  d902              BLS      |L13.424|
;;;369    		{
;;;370    			Oversize = 1;
0001a2  2001              MOVS     r0,#1
0001a4  9004              STR      r0,[sp,#0x10]
0001a6  e001              B        |L13.428|
                  |L13.424|
;;;371    		}
;;;372    		else
;;;373    		{
;;;374    			Oversize = 0;
0001a8  2000              MOVS     r0,#0
0001aa  9004              STR      r0,[sp,#0x10]
                  |L13.428|
;;;375    		}
;;;376    		
;;;377    		if(!Oversize)
0001ac  9804              LDR      r0,[sp,#0x10]
0001ae  2800              CMP      r0,#0
0001b0  d10f              BNE      |L13.466|
;;;378    		{	
;;;379    			if(!sleep)
0001b2  980a              LDR      r0,[sp,#0x28]
0001b4  2800              CMP      r0,#0
0001b6  d113              BNE      |L13.480|
;;;380    			{
;;;381    //				displayNumberOnTube(counter/10);
;;;382    				if(show_value+xiuzheng<=26)
0001b8  980c              LDR      r0,[sp,#0x30]
0001ba  1820              ADDS     r0,r4,r0
0001bc  281a              CMP      r0,#0x1a
0001be  d803              BHI      |L13.456|
;;;383    				{
;;;384    					displayNumberOnTube(0);
0001c0  2000              MOVS     r0,#0
0001c2  f7fffffe          BL       displayNumberOnTube
0001c6  e00b              B        |L13.480|
                  |L13.456|
;;;385    				}
;;;386    				else
;;;387    				{
;;;388    					displayNumberOnTube(show_value+xiuzheng);
0001c8  990c              LDR      r1,[sp,#0x30]
0001ca  1860              ADDS     r0,r4,r1
0001cc  f7fffffe          BL       displayNumberOnTube
0001d0  e006              B        |L13.480|
                  |L13.466|
;;;389    				}	
;;;390    			}				
;;;391    			
;;;392    		}
;;;393    		else
;;;394    		{
;;;395    			DBL();
0001d2  f7fffffe          BL       ||DBL||
;;;396    			show_value = 700;
0001d6  24af              MOVS     r4,#0xaf
0001d8  00a4              LSLS     r4,r4,#2
;;;397    			Buzzer_PlayMelody(happyBirthday);
0001da  4854              LDR      r0,|L13.812|
0001dc  f7fffffe          BL       Buzzer_PlayMelody
                  |L13.480|
;;;398    		}			
;;;399            WDT->WDT_CON |= WDT_CON_CLRWDT; //清watchdog
0001e0  4853              LDR      r0,|L13.816|
0001e2  6bc0              LDR      r0,[r0,#0x3c]
0001e4  2101              MOVS     r1,#1
0001e6  4308              ORRS     r0,r0,r1
0001e8  4951              LDR      r1,|L13.816|
0001ea  63c8              STR      r0,[r1,#0x3c]
;;;400            if(TK_TouchKeyStatus&0x80)
0001ec  4851              LDR      r0,|L13.820|
0001ee  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
0001f0  2180              MOVS     r1,#0x80
0001f2  4008              ANDS     r0,r0,r1
0001f4  2800              CMP      r0,#0
0001f6  d054              BEQ      |L13.674|
;;;401            {
;;;402                TK_TouchKeyStatus &= 0x7f;
0001f8  484e              LDR      r0,|L13.820|
0001fa  7800              LDRB     r0,[r0,#0]  ; TK_TouchKeyStatus
0001fc  0640              LSLS     r0,r0,#25
0001fe  0e40              LSRS     r0,r0,#25
000200  494c              LDR      r1,|L13.820|
000202  7008              STRB     r0,[r1,#0]
;;;403                TK_exKeyValueFlag = TK_TouchKeyScan();
000204  f7fffffe          BL       TK_TouchKeyScan
000208  494b              LDR      r1,|L13.824|
00020a  6008              STR      r0,[r1,#0]  ; TK_exKeyValueFlag
;;;404                DebounceTouchKey();
00020c  f7fffffe          BL       DebounceTouchKey
;;;405                if(keyPressed)
000210  484a              LDR      r0,|L13.828|
000212  7800              LDRB     r0,[r0,#0]  ; keyPressed
000214  2800              CMP      r0,#0
000216  d042              BEQ      |L13.670|
;;;406                {
;;;407                    ChangeTouchKeyvalue();
000218  f7fffffe          BL       ChangeTouchKeyvalue
;;;408                    if(exKeyValue==1)
00021c  4848              LDR      r0,|L13.832|
00021e  7800              LDRB     r0,[r0,#0]  ; exKeyValue
000220  2801              CMP      r0,#1
000222  d112              BNE      |L13.586|
;;;409                    {
;;;410                        sum++;
000224  980d              LDR      r0,[sp,#0x34]
000226  1c40              ADDS     r0,r0,#1
000228  900d              STR      r0,[sp,#0x34]
;;;411                        if(sum==1) xiuzheng=25;
00022a  980d              LDR      r0,[sp,#0x34]
00022c  2801              CMP      r0,#1
00022e  d102              BNE      |L13.566|
000230  2019              MOVS     r0,#0x19
000232  900c              STR      r0,[sp,#0x30]
000234  e001              B        |L13.570|
                  |L13.566|
;;;412                        else xiuzheng=0;
000236  2000              MOVS     r0,#0
000238  900c              STR      r0,[sp,#0x30]
                  |L13.570|
;;;413                        pi_value_float = current_stable; // 去皮用当前稳定值（更准！）
00023a  493b              LDR      r1,|L13.808|
00023c  9807              LDR      r0,[sp,#0x1c]
00023e  6008              STR      r0,[r1,#0]  ; pi_value_float
;;;414                        WBB_Reset(); // 去皮后重置缓冲区，避免旧漂移影响
000240  f7fffffe          BL       WBB_Reset
;;;415                        PB_OT(10);
000244  2001              MOVS     r0,#1
000246  4930              LDR      r1,|L13.776|
000248  7688              STRB     r0,[r1,#0x1a]
                  |L13.586|
;;;416                    }
;;;417                    if(exKeyValue==2)
00024a  483d              LDR      r0,|L13.832|
00024c  7800              LDRB     r0,[r0,#0]  ; exKeyValue
00024e  2802              CMP      r0,#2
000250  d108              BNE      |L13.612|
;;;418                    {
;;;419                        sum=0;
000252  2000              MOVS     r0,#0
000254  900d              STR      r0,[sp,#0x34]
;;;420                        pi_value_float = 0.0f;
000256  4934              LDR      r1,|L13.808|
000258  6008              STR      r0,[r1,#0]  ; pi_value_float
;;;421                        WBB_Reset(); // 清零去皮也重置
00025a  f7fffffe          BL       WBB_Reset
;;;422                        PB_OT(13);
00025e  2001              MOVS     r0,#1
000260  4929              LDR      r1,|L13.776|
000262  7748              STRB     r0,[r1,#0x1d]
                  |L13.612|
;;;423                    }
;;;424                    if(exKeyValue==3)
000264  4836              LDR      r0,|L13.832|
000266  7800              LDRB     r0,[r0,#0]  ; exKeyValue
000268  2803              CMP      r0,#3
00026a  d102              BNE      |L13.626|
;;;425                    {
;;;426                        Buzzer_PlayMelody(happyBirthday);
00026c  482f              LDR      r0,|L13.812|
00026e  f7fffffe          BL       Buzzer_PlayMelody
                  |L13.626|
;;;427                    }
;;;428                    if(exKeyValue==4)
000272  4833              LDR      r0,|L13.832|
000274  7800              LDRB     r0,[r0,#0]  ; exKeyValue
000276  2804              CMP      r0,#4
000278  d10e              BNE      |L13.664|
;;;429                    {
;;;430    					if(counter>persec*10) counter=0;
00027a  4832              LDR      r0,|L13.836|
00027c  4287              CMP      r7,r0
00027e  dd01              BLE      |L13.644|
000280  2700              MOVS     r7,#0
000282  e001              B        |L13.648|
                  |L13.644|
;;;431    					else counter=persec*10+1;
000284  4f2f              LDR      r7,|L13.836|
000286  1c7f              ADDS     r7,r7,#1
                  |L13.648|
;;;432    					if(sleep==0)
000288  980a              LDR      r0,[sp,#0x28]
00028a  2800              CMP      r0,#0
00028c  d102              BNE      |L13.660|
;;;433    					{
;;;434    						sleep = 1;
00028e  2001              MOVS     r0,#1
000290  900a              STR      r0,[sp,#0x28]
000292  e001              B        |L13.664|
                  |L13.660|
;;;435    					}
;;;436    					else
;;;437    					{
;;;438    						sleep = 0;
000294  2000              MOVS     r0,#0
000296  900a              STR      r0,[sp,#0x28]
                  |L13.664|
;;;439    					}
;;;440                    }
;;;441                    keyPressed = 0;
000298  2000              MOVS     r0,#0
00029a  4928              LDR      r1,|L13.828|
00029c  7008              STRB     r0,[r1,#0]
                  |L13.670|
;;;442                }
;;;443                TK_Restart();
00029e  f7fffffe          BL       TK_Restart
                  |L13.674|
;;;444            }
;;;445            {
;;;446                unsigned int i;
;;;447                for(i = 0; i < 1500; i++);
0002a2  2000              MOVS     r0,#0
0002a4  e000              B        |L13.680|
                  |L13.678|
0002a6  1c40              ADDS     r0,r0,#1
                  |L13.680|
0002a8  4927              LDR      r1,|L13.840|
0002aa  4288              CMP      r0,r1
0002ac  d3fb              BCC      |L13.678|
;;;448            }
;;;449    		counter++;
0002ae  1c7f              ADDS     r7,r7,#1
;;;450    		if(counter>=persec*20) counter=persec*20;
0002b0  4826              LDR      r0,|L13.844|
0002b2  4287              CMP      r7,r0
0002b4  db00              BLT      |L13.696|
0002b6  4607              MOV      r7,r0
                  |L13.696|
;;;451    		if(counter>10*persec)
0002b8  4822              LDR      r0,|L13.836|
0002ba  4287              CMP      r7,r0
0002bc  dd03              BLE      |L13.710|
;;;452    		{
;;;453    			sleep = 1;
0002be  2001              MOVS     r0,#1
0002c0  900a              STR      r0,[sp,#0x28]
;;;454    			DBL();
0002c2  f7fffffe          BL       ||DBL||
                  |L13.710|
;;;455    		}
;;;456    		if(counter%(persec*2)==0)
0002c6  214f              MOVS     r1,#0x4f
0002c8  0109              LSLS     r1,r1,#4
0002ca  4638              MOV      r0,r7
0002cc  f7fffffe          BL       __aeabi_idivmod
0002d0  2900              CMP      r1,#0
0002d2  d10e              BNE      |L13.754|
;;;457    		{
;;;458    			int cha;
;;;459    			if(qian>show_value) cha=qian-show_value;
0002d4  9909              LDR      r1,[sp,#0x24]
0002d6  42a1              CMP      r1,r4
0002d8  d902              BLS      |L13.736|
0002da  9909              LDR      r1,[sp,#0x24]
0002dc  1b08              SUBS     r0,r1,r4
0002de  e001              B        |L13.740|
                  |L13.736|
;;;460    			else cha=show_value-qian;
0002e0  9909              LDR      r1,[sp,#0x24]
0002e2  1a60              SUBS     r0,r4,r1
                  |L13.740|
;;;461    			if(cha>20)
0002e4  2814              CMP      r0,#0x14
0002e6  dd02              BLE      |L13.750|
;;;462    			{
;;;463    				counter=0;
0002e8  2700              MOVS     r7,#0
;;;464    				sleep=0;
0002ea  2100              MOVS     r1,#0
0002ec  910a              STR      r1,[sp,#0x28]
                  |L13.750|
;;;465    			}
;;;466    			qian=show_value;
0002ee  9409              STR      r4,[sp,#0x24]
;;;467    		}
0002f0  bf00              NOP      
                  |L13.754|
;;;468        }
0002f2  bf00              NOP      
                  |L13.756|
0002f4  e6a8              B        |L13.72|
;;;469    }
;;;470    /**
                          ENDP

0002f6  0000              DCW      0x0000
                  |L13.760|
                          DCD      0x44bb8000
                  |L13.764|
                          DCD      0x3c23d70a
                  |L13.768|
                          DCD      kf_weight
                  |L13.772|
                          DCD      0x40022140
                  |L13.776|
                          DCD      0x40011100
                  |L13.780|
                          DCD      wbb_index
                  |L13.784|
                          DCD      wbb_buffer
                  |L13.788|
                          DCD      wbb_full
                  |L13.792|
                          DCD      0x3f333333
                  |L13.796|
                          DCD      wbb_stable_value
                  |L13.800|
                          DCD      0x3e99999a
                  |L13.804|
                          DCD      0x460ca000
                  |L13.808|
                          DCD      pi_value_float
                  |L13.812|
                          DCD      happyBirthday
                  |L13.816|
                          DCD      0x40000300
                  |L13.820|
                          DCD      TK_TouchKeyStatus
                  |L13.824|
                          DCD      TK_exKeyValueFlag
                  |L13.828|
                          DCD      keyPressed
                  |L13.832|
                          DCD      exKeyValue
                  |L13.836|
                          DCD      0x000018b0
                  |L13.840|
                          DCD      0x000005dc
                  |L13.844|
                          DCD      0x00003160

                          AREA ||i.read_adc||, CODE, READONLY, ALIGN=2

                  read_adc PROC
;;;125    //读ADC（采8次平均，压噪声）
;;;126    uint16_t read_adc()
000000  b570              PUSH     {r4-r6,lr}
;;;127    {
;;;128        uint32_t sum = 0;
000002  2400              MOVS     r4,#0
;;;129        for(uint8_t i = 0; i < 8; i++) { // 连续采8次取平均
000004  2500              MOVS     r5,#0
000006  e010              B        |L14.42|
                  |L14.8|
;;;130            ADC_SoftwareStartConv(ADC);
000008  480a              LDR      r0,|L14.52|
00000a  f7fffffe          BL       ADC_SoftwareStartConv
;;;131            while(ADC_Flag == RESET);
00000e  bf00              NOP      
                  |L14.16|
000010  4809              LDR      r0,|L14.56|
000012  7800              LDRB     r0,[r0,#0]  ; ADC_Flag
000014  2800              CMP      r0,#0
000016  d0fb              BEQ      |L14.16|
;;;132            ADC_Flag = RESET;
000018  2000              MOVS     r0,#0
00001a  4907              LDR      r1,|L14.56|
00001c  7008              STRB     r0,[r1,#0]
;;;133            sum += ADC_GetConversionValue(ADC);
00001e  4805              LDR      r0,|L14.52|
000020  f7fffffe          BL       ADC_GetConversionValue
000024  1904              ADDS     r4,r0,r4
000026  1c68              ADDS     r0,r5,#1              ;129
000028  b2c5              UXTB     r5,r0                 ;129
                  |L14.42|
00002a  2d08              CMP      r5,#8                 ;129
00002c  dbec              BLT      |L14.8|
;;;134        }
;;;135        return (uint16_t)(sum / 8);
00002e  0360              LSLS     r0,r4,#13
000030  0c00              LSRS     r0,r0,#16
;;;136    }
000032  bd70              POP      {r4-r6,pc}
;;;137    // ==================== 卡尔曼滤波器变量 ====================
                          ENDP

                  |L14.52|
                          DCD      0x40022110
                  |L14.56|
                          DCD      ADC_Flag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  kf_weight
                          %        20
                  wbb_buffer
                          %        4000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  digitSegments
000000  d714cd5d          DCB      0xd7,0x14,0xcd,0x5d
000004  1e5bdb15          DCB      0x1e,0x5b,0xdb,0x15
000008  df5f              DCB      0xdf,0x5f
                  digitSelect
00000a  efdf              DCB      0xef,0xdf
00000c  bf7f              DCB      0xbf,0x7f
                  noteFrequencies
00000e  0000              DCW      0x0000
000010  01060126          DCW      0x0106,0x0126
000014  014a015d          DCW      0x014a,0x015d
000018  018801b8          DCW      0x0188,0x01b8
00001c  01ee020b          DCW      0x01ee,0x020b
000020  01370172          DCW      0x0137,0x0172
000024  019f01d2          DCW      0x019f,0x01d2
000028  022a026e          DCW      0x022a,0x026e
00002c  02e4              DCW      0x02e4
                  happyBirthday
00002e  0100              DCB      0x01,0x00
000030  00fa              DCW      0x00fa
000032  0100              DCB      0x01,0x00
000034  007d              DCW      0x007d
000036  0200              DCB      0x02,0x00
000038  0177              DCW      0x0177
00003a  0100              DCB      0x01,0x00
00003c  0177              DCW      0x0177
00003e  0400              DCB      0x04,0x00
000040  0177              DCW      0x0177
000042  0300              DCB      0x03,0x00
000044  02ee              DCW      0x02ee
000046  0000              DCB      0x00,0x00
000048  007d              DCW      0x007d
00004a  0000              DCB      0x00,0x00
00004c  0000              DCW      0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  displayNumber
                          DCD      0x00000000
                  digits
                          DCD      0x00000000
                  TK_exKeyValueFlag
                          DCD      0x00000000
                  exKeyValue
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  lastKeyValue
                          DCD      0x00000000
                  stableKeyValue
                          DCD      0x00000000
                  debounceCount
000018  00                DCB      0x00
                  keyPressed
000019  00                DCB      0x00
                  ADC_Flag
00001a  0000              DCB      0x00,0x00
                  wbb_index
00001c  0000              DCW      0x0000
                  wbb_full
00001e  0000              DCB      0x00,0x00
                  wbb_stable_value
000020  00000000          DCFS     0x00000000 ; 0
                  pi_value_float
000024  00000000          DCFS     0x00000000 ; 0
                  currentPosition
000028  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_370df81d____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_370df81d____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_370df81d____REVSH|
#line 478
|__asm___6_main_c_370df81d____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
