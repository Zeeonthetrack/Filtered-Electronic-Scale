; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_pwm.o --asm_dir=..\List --list_dir=..\List --cpu=Cortex-M0+ --apcs=interwork -O0 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -DSC32f12xx -DPrintfEable -D__UVISION_VERSION=536 ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_pwm.c]
                          THUMB
                          AREA ||i.PWM_ClearFlag||, CODE, READONLY, ALIGN=1
                  PWM_ClearFlag PROC
;;;507     */
;;;508    void PWM_ClearFlag ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  6081              STR      r1,[r0,#8]
;;;509    {
;;;510        
;;;511        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;512        assert_param ( IS_GET_PWM_FLAG ( PWM_FLAG ) );
;;;513    
;;;514        
;;;515        PWMx->PWM_STS = ( uint16_t ) PWM_FLAG;
;;;516    }
000002  4770              BX       lr
;;;517    
                          ENDP
                          AREA ||i.PWM_Cmd||, CODE, READONLY, ALIGN=2
                  PWM_Cmd PROC
;;;177     */
;;;178    void PWM_Cmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;179    {
;;;180        
;;;181        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;182        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;183    
;;;184        if ( NewState != DISABLE )
000002  d004              BEQ      |L2.14|
;;;185        {
;;;186            
;;;187            PWMx->PWM_CON |= PWM_CON_ENPWM;
000004  6802              LDR      r2,[r0,#0]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L2.22|
                  |L2.14|
;;;188        }
;;;189        else
;;;190        {
;;;191            
;;;192            PWMx->PWM_CON &= ( uint16_t ) ~PWM_CON_ENPWM;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L2.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L2.22|
;;;193        }
;;;194    }
000016  4770              BX       lr
;;;195    
                          ENDP
                  |L2.24|
                          DCD      0x0000ff7f
                          AREA ||i.PWM_DeInit||, CODE, READONLY, ALIGN=2
                  PWM_DeInit PROC
;;;46      */
;;;47     void PWM_DeInit ( PWM_TypeDef* PWMx )
000000  b510              PUSH     {r4,lr}
;;;48     {
000002  4604              MOV      r4,r0
;;;49         
;;;50         assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;51     
;;;52         if ( PWMx == PWM0 )
000004  4805              LDR      r0,|L3.28|
000006  4284              CMP      r4,r0
000008  d107              BNE      |L3.26|
;;;53         {
;;;54             
;;;55             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  1580              ASRS     r0,r0,#22
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;56             
;;;57             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, DISABLE );
000012  2100              MOVS     r1,#0
000014  15a0              ASRS     r0,r4,#22
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
                  |L3.26|
;;;58         }
;;;59     }
00001a  bd10              POP      {r4,pc}
;;;60     
                          ENDP
                  |L3.28|
                          DCD      0x40020200
                          AREA ||i.PWM_FDCmd||, CODE, READONLY, ALIGN=2
                  PWM_FDCmd PROC
;;;408     */
;;;409    void PWM_FDCmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;410    {
;;;411        
;;;412        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;413        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;414    
;;;415        if ( NewState != DISABLE )
000002  d004              BEQ      |L4.14|
;;;416        {
;;;417            
;;;418            PWMx->PWM_FLT |= PWM_FLT_FLTEN;
000004  6942              LDR      r2,[r0,#0x14]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  6142              STR      r2,[r0,#0x14]
00000c  e003              B        |L4.22|
                  |L4.14|
;;;419        }
;;;420        else
;;;421        {
;;;422            
;;;423            PWMx->PWM_FLT &= ( uint16_t ) ~PWM_FLT_FLTEN;
00000e  6942              LDR      r2,[r0,#0x14]
000010  4b01              LDR      r3,|L4.24|
000012  401a              ANDS     r2,r2,r3
000014  6142              STR      r2,[r0,#0x14]
                  |L4.22|
;;;424        }
;;;425    }
000016  4770              BX       lr
;;;426    
;;;391    void PWM_FDInit ( PWM_TypeDef* PWMx, PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  6942              LDR      r2,[r0,#0x14]
;;;392    {
;;;393        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;394    
;;;395        PWMx->PWM_FLT &= ( uint32_t ) ~ ( PWM_FLT_FLTDT | PWM_FLT_FLTTV | PWM_FLT_FLTMD );
000002  2333              MOVS     r3,#0x33
000004  439a              BICS     r2,r2,r3
000006  6142              STR      r2,[r0,#0x14]
;;;396        PWMx->PWM_FLT |= ( uint32_t ) ( PWM_FDInitStruct->PWM_FDFilteringTime | PWM_FDInitStruct->PWM_FDMode |
000008  888a              LDRH     r2,[r1,#4]
00000a  880b              LDRH     r3,[r1,#0]
00000c  431a              ORRS     r2,r2,r3
00000e  884b              LDRH     r3,[r1,#2]
000010  431a              ORRS     r2,r2,r3
000012  6943              LDR      r3,[r0,#0x14]
000014  431a              ORRS     r2,r2,r3
000016  6142              STR      r2,[r0,#0x14]
;;;397                                        PWM_FDInitStruct->PWM_FDVoltage );
;;;398    }
000018  4770              BX       lr
;;;399    
                          ENDP
                          AREA ||i.PWM_FDStructInit||, CODE, READONLY, ALIGN=1
                  PWM_FDStructInit PROC
;;;375      */
;;;376    void PWM_FDStructInit ( PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  2100              MOVS     r1,#0
;;;377    {
;;;378        
;;;379        PWM_FDInitStruct->PWM_FDFilteringTime = PWM_FilteringTime_0us;
000002  8081              STRH     r1,[r0,#4]
;;;380        PWM_FDInitStruct->PWM_FDMode = PWM_FDMode_Latch;
000004  8001              STRH     r1,[r0,#0]
;;;381        PWM_FDInitStruct->PWM_FDVoltage = PWM_FDVoltage_Low;
000006  8041              STRH     r1,[r0,#2]
;;;382    }
000008  4770              BX       lr
;;;383    
                          ENDP
                          AREA ||i.PWM_FallingDeadTimeConfig||, CODE, READONLY, ALIGN=1
                  PWM_FallingDeadTimeConfig PROC
;;;149     */
;;;150    void PWM_FallingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_FallingDeadTime )
000000  b510              PUSH     {r4,lr}
;;;151    {
000002  460a              MOV      r2,r1
;;;152        uint32_t tmpreg;
;;;153        
;;;154        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;155    
;;;156        
;;;157        tmpreg = PWMx->PWM_DFR;
000004  6901              LDR      r1,[r0,#0x10]
;;;158    
;;;159        
;;;160        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDF );
000006  240f              MOVS     r4,#0xf
000008  0224              LSLS     r4,r4,#8
00000a  460b              MOV      r3,r1
00000c  43a3              BICS     r3,r3,r4
00000e  4619              MOV      r1,r3
;;;161    
;;;162        
;;;163        tmpreg |= ( uint32_t ) ( PWM_FallingDeadTime << PWM_DFR_PDF_Pos );
000010  0213              LSLS     r3,r2,#8
000012  4319              ORRS     r1,r1,r3
;;;164    
;;;165        
;;;166        PWMx->PWM_DFR = tmpreg;
000014  6101              STR      r1,[r0,#0x10]
;;;167    }
000016  bd10              POP      {r4,pc}
;;;168    
                          ENDP
                          AREA ||i.PWM_GetCycle||, CODE, READONLY, ALIGN=1
                  PWM_GetCycle PROC
;;;269     */
;;;270    uint16_t PWM_GetCycle ( PWM_TypeDef* PWMx )
000000  4601              MOV      r1,r0
;;;271    {
;;;272        
;;;273        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;274    
;;;275        
;;;276        return ( uint16_t ) PWMx->PWM_CYCLE;
000002  6988              LDR      r0,[r1,#0x18]
000004  b280              UXTH     r0,r0
;;;277    }
000006  4770              BX       lr
;;;278    
                          ENDP
                          AREA ||i.PWM_GetDuty||, CODE, READONLY, ALIGN=1
                  PWM_GetDuty PROC
;;;332     */
;;;333    uint16_t PWM_GetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel )
000000  b530              PUSH     {r4,r5,lr}
;;;334    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;335        uint8_t tmpvalue ;
;;;336        uint32_t tmpchannel;
;;;337        
;;;338        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;339        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;340    
;;;341        tmpchannel = 1;
000006  2301              MOVS     r3,#1
;;;342        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000008  2100              MOVS     r1,#0
00000a  e00c              B        |L9.38|
                  |L9.12|
;;;343        {
;;;344            if ( ( uint32_t ) PWM_Channel & tmpchannel )
00000c  4620              MOV      r0,r4
00000e  4018              ANDS     r0,r0,r3
000010  2800              CMP      r0,#0
000012  d005              BEQ      |L9.32|
;;;345            {
;;;346                return ( uint16_t ) ( PWMx->PWM_DT[tmpvalue] );
000014  008d              LSLS     r5,r1,#2
000016  4610              MOV      r0,r2
000018  3030              ADDS     r0,r0,#0x30
00001a  5940              LDR      r0,[r0,r5]
00001c  b280              UXTH     r0,r0
                  |L9.30|
;;;347            }
;;;348            tmpchannel = tmpchannel << 1;
;;;349        }
;;;350        return 0;
;;;351    }
00001e  bd30              POP      {r4,r5,pc}
                  |L9.32|
000020  005b              LSLS     r3,r3,#1              ;348
000022  1c48              ADDS     r0,r1,#1              ;342
000024  b2c1              UXTB     r1,r0                 ;342
                  |L9.38|
000026  2908              CMP      r1,#8                 ;342
000028  dbf0              BLT      |L9.12|
00002a  2000              MOVS     r0,#0                 ;350
00002c  e7f7              B        |L9.30|
;;;352    
                          ENDP
                          AREA ||i.PWM_GetFlagStatus||, CODE, READONLY, ALIGN=1
                  PWM_GetFlagStatus PROC
;;;480     */
;;;481    FlagStatus PWM_GetFlagStatus ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  4602              MOV      r2,r0
;;;482    {
;;;483        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;484        
;;;485        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;486        assert_param ( IS_PWM_FLAG ( PWM_FLAG ) );
;;;487    
;;;488        if ( ( PWMx->PWM_STS & PWM_FLAG ) != ( uint16_t ) RESET )
000004  6893              LDR      r3,[r2,#8]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L10.16|
;;;489        {
;;;490            bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;491        }
;;;492        else
;;;493        {
;;;494            bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;495        }
;;;496        return bitstatus;
;;;497    }
000012  4770              BX       lr
;;;498    
                          ENDP
                          AREA ||i.PWM_GetPrescaler||, CODE, READONLY, ALIGN=1
                  PWM_GetPrescaler PROC
;;;237     */
;;;238    PWM_Prescaler_TypeDef PWM_GetPrescaler ( PWM_TypeDef* PWMx )
000000  4601              MOV      r1,r0
;;;239    {
;;;240        
;;;241        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;242    
;;;243        
;;;244        return ( PWM_Prescaler_TypeDef ) ( PWMx->PWM_CON & PWM_CON_PWMCLK );
000002  6808              LDR      r0,[r1,#0]
000004  0740              LSLS     r0,r0,#29
000006  0f40              LSRS     r0,r0,#29
;;;245    }
000008  4770              BX       lr
;;;246    
                          ENDP
                          AREA ||i.PWM_ITConfig||, CODE, READONLY, ALIGN=1
                  PWM_ITConfig PROC
;;;451     */
;;;452    void PWM_ITConfig ( PWM_TypeDef* PWMx, uint16_t PWM_IT, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;453    {
;;;454        
;;;455        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;456        assert_param ( IS_PWM_IT ( PWM_IT ) );
;;;457        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;458    
;;;459        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L12.14|
;;;460        {
;;;461            
;;;462            PWMx->PWM_CON |= PWM_IT;
000006  6803              LDR      r3,[r0,#0]
000008  430b              ORRS     r3,r3,r1
00000a  6003              STR      r3,[r0,#0]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;463        }
;;;464        else
;;;465        {
;;;466            
;;;467            PWMx->PWM_CON &= ( uint16_t ) ~PWM_IT;
00000e  6803              LDR      r3,[r0,#0]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6003              STR      r3,[r0,#0]
                  |L12.24|
;;;468        }
;;;469    }
000018  bd10              POP      {r4,pc}
;;;470    
                          ENDP
                          AREA ||i.PWM_Init||, CODE, READONLY, ALIGN=1
                  PWM_Init PROC
;;;84      */
;;;85     void PWM_Init ( PWM_TypeDef* PWMx, PWM_InitTypeDef* PWM_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87         uint32_t tmpreg;
;;;88         
;;;89         assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;90     
;;;91         
;;;92         
;;;93         tmpreg = PWMx->PWM_CON;
000002  6802              LDR      r2,[r0,#0]
;;;94         
;;;95         tmpreg &= ( uint32_t ) ~ ( PWM_CON_PWMCLK | PWM_CON_PWMMD0 | PWM_CON_PWMMD1 );
000004  2467              MOVS     r4,#0x67
000006  4613              MOV      r3,r2
000008  43a3              BICS     r3,r3,r4
00000a  461a              MOV      r2,r3
;;;96         
;;;97         
;;;98         
;;;99         
;;;100        tmpreg |= ( uint32_t ) ( PWM_InitStruct->PWM_Prescaler | PWM_InitStruct->PWM_AlignedMode |
00000c  880b              LDRH     r3,[r1,#0]
00000e  884c              LDRH     r4,[r1,#2]
000010  4323              ORRS     r3,r3,r4
000012  888c              LDRH     r4,[r1,#4]
000014  4323              ORRS     r3,r3,r4
000016  431a              ORRS     r2,r2,r3
;;;101                                 PWM_InitStruct->PWM_WorkMode );
;;;102    
;;;103        
;;;104        PWMx->PWM_CON = tmpreg;
000018  6002              STR      r2,[r0,#0]
;;;105    
;;;106        
;;;107        PWMx->PWM_CHN = PWM_InitStruct->PWM_OutputChannel;
00001a  688b              LDR      r3,[r1,#8]
00001c  6043              STR      r3,[r0,#4]
;;;108    
;;;109        
;;;110        PWMx->PWM_INV = PWM_InitStruct->PWM_LowPolarityChannl;
00001e  68cb              LDR      r3,[r1,#0xc]
000020  60c3              STR      r3,[r0,#0xc]
;;;111    
;;;112        
;;;113        PWMx->PWM_CYCLE = PWM_InitStruct->PWM_Cycle;
000022  88cb              LDRH     r3,[r1,#6]
000024  6183              STR      r3,[r0,#0x18]
;;;114    }
000026  bd10              POP      {r4,pc}
;;;115    
                          ENDP
                          AREA ||i.PWM_RisingDeadTimeConfig||, CODE, READONLY, ALIGN=1
                  PWM_RisingDeadTimeConfig PROC
;;;123     */
;;;124    void PWM_RisingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_RisingDeadTime )
000000  460a              MOV      r2,r1
;;;125    {
;;;126        uint32_t tmpreg;
;;;127        
;;;128        assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;129    
;;;130        
;;;131        tmpreg = PWMx->PWM_DFR;
000002  6901              LDR      r1,[r0,#0x10]
;;;132    
;;;133        
;;;134        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDR );
000004  0909              LSRS     r1,r1,#4
000006  0109              LSLS     r1,r1,#4
;;;135    
;;;136        
;;;137        tmpreg |= ( uint32_t ) ( PWM_RisingDeadTime << PWM_DFR_PDR_Pos );
000008  460b              MOV      r3,r1
00000a  4313              ORRS     r3,r3,r2
00000c  4619              MOV      r1,r3
;;;138    
;;;139        
;;;140        PWMx->PWM_DFR = tmpreg;
00000e  6101              STR      r1,[r0,#0x10]
;;;141    }
000010  4770              BX       lr
;;;142    
                          ENDP
                          AREA ||i.PWM_SetCycle||, CODE, READONLY, ALIGN=1
                  PWM_SetCycle PROC
;;;254     */
;;;255    void PWM_SetCycle ( PWM_TypeDef* PWMx, uint32_t PWM_Cycle )
000000  6181              STR      r1,[r0,#0x18]
;;;256    {
;;;257        
;;;258        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;259    
;;;260        
;;;261        PWMx->PWM_CYCLE = PWM_Cycle;
;;;262    }
000002  4770              BX       lr
;;;263    
                          ENDP
                          AREA ||i.PWM_SetDuty||, CODE, READONLY, ALIGN=1
                  PWM_SetDuty PROC
;;;296     */
;;;297    void PWM_SetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel, uint16_t PWM_Duty )
000000  b570              PUSH     {r4-r6,lr}
;;;298    {
000002  4603              MOV      r3,r0
;;;299        uint8_t tmpvalue;
;;;300        uint32_t tmpchannel;
;;;301        
;;;302        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;303        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;304    
;;;305        tmpchannel = 1;
000004  2401              MOVS     r4,#1
;;;306        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000006  2000              MOVS     r0,#0
000008  e00a              B        |L16.32|
                  |L16.10|
;;;307        {
;;;308            if ( ( uint32_t ) PWM_Channel & tmpchannel )
00000a  460d              MOV      r5,r1
00000c  4025              ANDS     r5,r5,r4
00000e  2d00              CMP      r5,#0
000010  d003              BEQ      |L16.26|
;;;309            {
;;;310                PWMx->PWM_DT[tmpvalue] = PWM_Duty;
000012  0085              LSLS     r5,r0,#2
000014  461e              MOV      r6,r3
000016  3630              ADDS     r6,r6,#0x30
000018  5172              STR      r2,[r6,r5]
                  |L16.26|
;;;311            }
;;;312            tmpchannel = tmpchannel << 1;
00001a  0064              LSLS     r4,r4,#1
00001c  1c45              ADDS     r5,r0,#1              ;306
00001e  b2e8              UXTB     r0,r5                 ;306
                  |L16.32|
000020  2808              CMP      r0,#8                 ;306
000022  dbf2              BLT      |L16.10|
;;;313        }
;;;314    }
000024  bd70              POP      {r4-r6,pc}
;;;315    
                          ENDP
                          AREA ||i.PWM_SetPrescaler||, CODE, READONLY, ALIGN=2
                  PWM_SetPrescaler PROC
;;;210     */
;;;211    void PWM_SetPrescaler ( PWM_TypeDef* PWMx, PWM_Prescaler_TypeDef PWM_Prescaler )
000000  6802              LDR      r2,[r0,#0]
;;;212    {
;;;213        
;;;214        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;215        assert_param ( IS_PWM_PRESCALER ( PWM_Prescaler ) );
;;;216    
;;;217        
;;;218        PWMx->PWM_CON &= ( uint16_t ) ~ ( PWM_CON_PWMCLK );
000002  4b03              LDR      r3,|L17.16|
000004  401a              ANDS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;219    
;;;220        
;;;221        PWMx->PWM_CON |= PWM_Prescaler;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;222    }
00000e  4770              BX       lr
;;;223    
                          ENDP
                  |L17.16|
                          DCD      0x0000fff8
                          AREA ||i.PWM_StructInit||, CODE, READONLY, ALIGN=1
                  PWM_StructInit PROC
;;;65       */
;;;66     void PWM_StructInit ( PWM_InitTypeDef* PWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;67     {
;;;68         
;;;69         PWM_InitStruct->PWM_AlignedMode = PWM_AlignmentMode_Edge;
000002  8041              STRH     r1,[r0,#2]
;;;70         PWM_InitStruct->PWM_Cycle = 0x0000;
000004  80c1              STRH     r1,[r0,#6]
;;;71         PWM_InitStruct->PWM_LowPolarityChannl = PWMChannel_Less;
000006  60c1              STR      r1,[r0,#0xc]
;;;72         PWM_InitStruct->PWM_OutputChannel = PWMChannel_Less;
000008  6081              STR      r1,[r0,#8]
;;;73         PWM_InitStruct->PWM_Prescaler = PWM_PRESCALER_DIV1;
00000a  8001              STRH     r1,[r0,#0]
;;;74         PWM_InitStruct->PWM_WorkMode = PWM_WorkMode_Independent;
00000c  8081              STRH     r1,[r0,#4]
;;;75     }
00000e  4770              BX       lr
;;;76     
                          ENDP
;*** Start embedded assembler ***
#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16| PROC
#line 464
 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH|
#line 478
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH| PROC
#line 479
 revsh r0, r0
 bx lr
	ENDP
;*** End   embedded assembler ***
