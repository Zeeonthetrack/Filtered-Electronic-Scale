; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_op.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_op.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -IC:\KEIL_MDK\PACK\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_op.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_op.c]
                          THUMB

                          AREA ||i.OP_Cmd||, CODE, READONLY, ALIGN=2

                  OP_Cmd PROC
;;;125     */
;;;126    void OP_Cmd ( OP_TypeDef* OPx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;127    {
;;;128    #if defined (SC32f12xx)
;;;129        /* Check the parameters */
;;;130        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;131        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;132    
;;;133        if ( NewState != DISABLE )
000002  d004              BEQ      |L1.14|
;;;134        {
;;;135            /* Enable the OP Function */
;;;136            OPx->OP_CON |= OP_CON_ENOP;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L1.22|
                  |L1.14|
;;;137        }
;;;138        else
;;;139        {
;;;140            /* Disable the OP Function */
;;;141            OPx->OP_CON &= ( uint16_t ) ~OP_CON_ENOP;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L1.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L1.22|
;;;142        }
;;;143    
;;;144    #endif
;;;145    }
000016  4770              BX       lr
;;;146    
                          ENDP

                  |L1.24|
                          DCD      0x0000fffe

                          AREA ||i.OP_DeInit||, CODE, READONLY, ALIGN=2

                  OP_DeInit PROC
;;;48      */
;;;49     void OP_DeInit ( OP_TypeDef* OPx )
000000  4a03              LDR      r2,|L2.16|
;;;50     {
;;;51     #if defined (SC32f12xx) 
;;;52         uint32_t tmpreg;
;;;53         /* Check the parameters */
;;;54         assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;55     
;;;56         if ( OPx == OP )
000002  4290              CMP      r0,r2
000004  d102              BNE      |L2.12|
;;;57         {
;;;58             /* Get the OPx OP_CON value */
;;;59             tmpreg = OPx->OP_CON;
000006  6801              LDR      r1,[r0,#0]
;;;60     
;;;61             /* Set OPFS bit to OP_FreqSelect value */
;;;62             tmpreg &= 0x00000000;
000008  2100              MOVS     r1,#0
;;;63     
;;;64             /* Write to OPx OP_CON */
;;;65             OPx->OP_CON = ( uint32_t ) tmpreg;
00000a  6001              STR      r1,[r0,#0]
                  |L2.12|
;;;66         }
;;;67     
;;;68     #endif
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40022140

                          AREA ||i.OP_GainSelection||, CODE, READONLY, ALIGN=1

                  OP_GainSelection PROC
;;;199      */
;;;200    void OP_GainSelection ( OP_TypeDef* OPx, OP_PGAGain_TypeDef PGAGain )
000000  6802              LDR      r2,[r0,#0]
;;;201    {
;;;202    #if defined (SC32f12xx)
;;;203        /* Check the parameters */
;;;204        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;205        assert_param ( IS_OP_PGAGain ( PGAGain ) );
;;;206    
;;;207    
;;;208        OPx->OP_CON &= ~ ( OP_CON_PGAGAIN );
000002  2303              MOVS     r3,#3
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;209        OPx->OP_CON |= PGAGain;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;210    
;;;211    #endif
;;;212    
;;;213    }
000010  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.OP_Init||, CODE, READONLY, ALIGN=2

                  OP_Init PROC
;;;82      */
;;;83     void OP_Init ( OP_TypeDef* OPx, OP_InitTypeDef* OP_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;84     {
;;;85     #if defined (SC32f12xx)
;;;86         uint32_t tmpreg;
;;;87         /* Check the parameters */
;;;88         assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;89         assert_param ( IS_OP_Output ( Output ) );
;;;90         assert_param ( IS_OP_Negative ( Negative ) );
;;;91         assert_param ( IS_OP_Posittive ( Posittive ) );
;;;92         assert_param ( IS_OP_PGAGain ( PGAGain ) );
;;;93         assert_param ( IS_OP_FDBResisrance ( FDBResisrance ) );
;;;94         assert_param ( IS_OP_ShortCircuit ( ShortCircuit ) );
;;;95     
;;;96         /*---------------------------- OPx OP_CON Configuration ------------------------*/
;;;97         /* Get the OPx OP_CON value */
;;;98         tmpreg = OPx->OP_CON;
000002  6802              LDR      r2,[r0,#0]
;;;99     
;;;100        /* Clear OPFS bits */
;;;101        tmpreg &= ( uint32_t ) ~ ( OP_CON_OPOSEL | OP_CON_OPNSEL | OP_CON_OPPSEL
000004  4b07              LDR      r3,|L4.36|
000006  401a              ANDS     r2,r2,r3
;;;102                                   | OP_CON_PGAGAIN | OP_CON_FDBRSEL | OP_CON_PGAOFC );
;;;103        /* Set OPFS bit to OP_FreqSelect value */
;;;104        tmpreg |= ( uint32_t ) ( OP_InitStruct->OP_FDBResisrance | OP_InitStruct->OP_Negative | OP_InitStruct->OP_Output |
000008  888b              LDRH     r3,[r1,#4]
00000a  894c              LDRH     r4,[r1,#0xa]
00000c  4323              ORRS     r3,r3,r4
00000e  898c              LDRH     r4,[r1,#0xc]
000010  4323              ORRS     r3,r3,r4
000012  88cc              LDRH     r4,[r1,#6]
000014  4323              ORRS     r3,r3,r4
000016  890c              LDRH     r4,[r1,#8]
000018  4323              ORRS     r3,r3,r4
00001a  680c              LDR      r4,[r1,#0]
00001c  4323              ORRS     r3,r3,r4
00001e  431a              ORRS     r2,r2,r3
;;;105                                 OP_InitStruct->OP_PGAGain | OP_InitStruct->OP_Posittive | OP_InitStruct->OP_ShortCircuit );
;;;106    
;;;107        /* Write to OPx OP_CON */
;;;108        OPx->OP_CON = tmpreg;
000020  6002              STR      r2,[r0,#0]
;;;109    
;;;110    #endif
;;;111    }
000022  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  |L4.36|
                          DCD      0xff7fcc15

                          AREA ||i.OP_OffsetSet||, CODE, READONLY, ALIGN=2

                  OP_OffsetSet PROC
;;;250     */
;;;251    ErrorStatus OP_OffsetSet(OP_TypeDef* OPx)
000000  b5ff              PUSH     {r0-r7,lr}
;;;252    {
000002  4601              MOV      r1,r0
;;;253    		uint8_t OPx_Readoffset0,OPx_Readoffset1,OPx_Readoffset2,OPx_Readoffset3,OPx_Readoffset4,OPx_Readoffset5;
;;;254    	  uint16_t OPx_offsetchecksum0,OPx_offsetchecksum1;
;;;255    	  OPx_Readoffset0 =  *((uint8_t *)0X08C00000+0x480);
000004  4819              LDR      r0,|L5.108|
000006  7803              LDRB     r3,[r0,#0]
;;;256    	  OPx_Readoffset1 =  *((uint8_t *)0X08C00000+0x481);
000008  7844              LDRB     r4,[r0,#1]
;;;257    	  OPx_Readoffset2 =  *((uint8_t *)0X08C00000+0x482);
00000a  7880              LDRB     r0,[r0,#2]
00000c  9003              STR      r0,[sp,#0xc]
;;;258    	  OPx_Readoffset3 =  *((uint8_t *)0X08C00000+0x483);
00000e  4817              LDR      r0,|L5.108|
000010  78c5              LDRB     r5,[r0,#3]
;;;259    		OPx_Readoffset4 =  *((uint8_t *)0X08C00000+0x484);
000012  7900              LDRB     r0,[r0,#4]
000014  9002              STR      r0,[sp,#8]
;;;260    		OPx_Readoffset5 =  *((uint8_t *)0X08C00000+0x485);
000016  4815              LDR      r0,|L5.108|
000018  7940              LDRB     r0,[r0,#5]
00001a  9001              STR      r0,[sp,#4]
;;;261    	  OPx_offsetchecksum0 = (*((uint8_t *)0X08C00000+0x480))+(*((uint8_t *)0X08C00000+0x481))+(*((uint8_t *)0X08C00000+0x482))+(*((uint8_t *)0X08C00000+0x483));
00001c  4813              LDR      r0,|L5.108|
00001e  7800              LDRB     r0,[r0,#0]
000020  4a12              LDR      r2,|L5.108|
000022  7852              LDRB     r2,[r2,#1]
000024  1880              ADDS     r0,r0,r2
000026  4a11              LDR      r2,|L5.108|
000028  7892              LDRB     r2,[r2,#2]
00002a  1880              ADDS     r0,r0,r2
00002c  4a0f              LDR      r2,|L5.108|
00002e  78d2              LDRB     r2,[r2,#3]
000030  1886              ADDS     r6,r0,r2
;;;262    	  OPx_offsetchecksum1 = ((*((uint8_t *)0X08C00000+0x484))<<8)|(*((uint8_t *)0X08C00000+0x485));
000032  480e              LDR      r0,|L5.108|
000034  7900              LDRB     r0,[r0,#4]
000036  0200              LSLS     r0,r0,#8
000038  4a0c              LDR      r2,|L5.108|
00003a  7952              LDRB     r2,[r2,#5]
00003c  4310              ORRS     r0,r0,r2
00003e  9000              STR      r0,[sp,#0]
;;;263        if (( OPx_Readoffset0==0x55 )&&( OPx_Readoffset2==0x55 )&&(OPx_offsetchecksum0==OPx_offsetchecksum1))
000040  2b55              CMP      r3,#0x55
000042  d111              BNE      |L5.104|
000044  9803              LDR      r0,[sp,#0xc]
000046  2855              CMP      r0,#0x55
000048  d10e              BNE      |L5.104|
00004a  9800              LDR      r0,[sp,#0]
00004c  4286              CMP      r6,r0
00004e  d10b              BNE      |L5.104|
;;;264        {
;;;265    	      uint32_t tmpreg = 0;
000050  2200              MOVS     r2,#0
;;;266            /*!< Get the OPAMPx_CSR register value */
;;;267           tmpreg = OPx->OP_CON;
000052  680a              LDR      r2,[r1,#0]
;;;268    
;;;269           /*!< Clear the trimming bits */
;;;270           tmpreg &= ( uint32_t ) ~ ( ( OP_CON_TRIMOFFSETN | OP_CON_TRIMOFFSETP ) );
000054  4806              LDR      r0,|L5.112|
000056  4002              ANDS     r2,r2,r0
;;;271    
;;;272           /*!< Configure the new trimming value */
;;;273           tmpreg |= ( uint32_t ) ( ( OPx_Readoffset3 << OP_CON_TRIMOFFSETN_Pos ) | ( OPx_Readoffset1 << OP_CON_TRIMOFFSETP_Pos ) );
000058  0628              LSLS     r0,r5,#24
00005a  0427              LSLS     r7,r4,#16
00005c  4338              ORRS     r0,r0,r7
00005e  4302              ORRS     r2,r2,r0
;;;274    
;;;275           /*!< Write to OPAMPx_CSR register */
;;;276            OPx->OP_CON = tmpreg;
000060  600a              STR      r2,[r1,#0]
;;;277            return SUCCESS;
000062  2000              MOVS     r0,#0
                  |L5.100|
;;;278        }
;;;279        else
;;;280        {
;;;281            return ERROR;
;;;282        }
;;;283    }
000064  b004              ADD      sp,sp,#0x10
000066  bdf0              POP      {r4-r7,pc}
                  |L5.104|
000068  2001              MOVS     r0,#1                 ;281
00006a  e7fb              B        |L5.100|
;;;284    
                          ENDP

                  |L5.108|
                          DCD      0x08c00480
                  |L5.112|
                          DCD      0xe0e0ffff

                          AREA ||i.OP_OffsetTrimConfig||, CODE, READONLY, ALIGN=2

                  OP_OffsetTrimConfig PROC
;;;158      */
;;;159    void OP_OffsetTrimConfig ( OP_TypeDef* OPx,  uint32_t OP_TrimValueH, uint32_t OP_TrimValueL )
000000  b530              PUSH     {r4,r5,lr}
;;;160    {
000002  460b              MOV      r3,r1
;;;161    #if defined (SC32f12xx)
;;;162        uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;163    
;;;164        /* Check the parameters */
;;;165        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;166    
;;;167    
;;;168        /*!< Get the OPAMPx_CSR register value */
;;;169        tmpreg = OPx->OP_CON;
000006  6801              LDR      r1,[r0,#0]
;;;170    
;;;171        /*!< Clear the trimming bits */
;;;172        tmpreg &= ( uint32_t ) ~ ( ( OP_CON_TRIMOFFSETP | OP_CON_TRIMOFFSETN ) );
000008  4c03              LDR      r4,|L6.24|
00000a  4021              ANDS     r1,r1,r4
;;;173    
;;;174        /*!< Configure the new trimming value */
;;;175        tmpreg |= ( uint32_t ) ( ( OP_TrimValueL << OP_CON_TRIMOFFSETP_Pos ) | ( OP_TrimValueH << OP_CON_TRIMOFFSETN_Pos ) );
00000c  0414              LSLS     r4,r2,#16
00000e  061d              LSLS     r5,r3,#24
000010  432c              ORRS     r4,r4,r5
000012  4321              ORRS     r1,r1,r4
;;;176    
;;;177        /*!< Write to OPAMPx_CSR register */
;;;178        OPx->OP_CON = tmpreg;
000014  6001              STR      r1,[r0,#0]
;;;179    
;;;180    #endif
;;;181    }
000016  bd30              POP      {r4,r5,pc}
;;;182    
                          ENDP

                  |L6.24|
                          DCD      0xe0e0ffff

                          AREA ||i.OP_OutputSelection||, CODE, READONLY, ALIGN=1

                  OP_OutputSelection PROC
;;;230      */
;;;231    void OP_OutputSelection ( OP_TypeDef* OPx, OP_Output_TypeDef OPOutput )
000000  6802              LDR      r2,[r0,#0]
;;;232    {
;;;233    #if defined (SC32f12xx)
;;;234        /* Check the parameters */
;;;235        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;236        assert_param ( IS_OP_Output ( OPOutput ) );
;;;237    
;;;238    
;;;239        OPx->OP_CON &= ~ ( OP_CON_OPOSEL );
000002  2302              MOVS     r3,#2
000004  439a              BICS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;240        OPx->OP_CON |= OPOutput;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;241    
;;;242    #endif
;;;243    }
00000e  4770              BX       lr
;;;244    #if defined (SC32f12xx)
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_op.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_sc32f1xxx_op_c_e58096f1____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___14_sc32f1xxx_op_c_e58096f1____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_sc32f1xxx_op_c_e58096f1____REVSH|
#line 478
|__asm___14_sc32f1xxx_op_c_e58096f1____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
