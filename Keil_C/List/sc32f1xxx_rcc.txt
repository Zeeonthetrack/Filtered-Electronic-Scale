; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_rcc.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_rcc.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -IC:\KEIL_MDK\PACK\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_rcc.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;763      */
;;;764    void RCC_AHBPeriphClockCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;765    {
;;;766        /* Check the parameters */
;;;767        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;768    
;;;769        if ( NewState != DISABLE )
000002  d005              BEQ      |L1.16|
;;;770        {
;;;771            RCCAHB->AHB_CFG |= RCC_AHBPeriph;
000004  4a05              LDR      r2,|L1.28|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L1.28|
00000c  601a              STR      r2,[r3,#0]
00000e  e004              B        |L1.26|
                  |L1.16|
;;;772        }
;;;773        else
;;;774        {
;;;775            RCCAHB->AHB_CFG &= ~RCC_AHBPeriph;
000010  4a02              LDR      r2,|L1.28|
000012  6812              LDR      r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L1.28|
000018  601a              STR      r2,[r3,#0]
                  |L1.26|
;;;776        }
;;;777    }
00001a  4770              BX       lr
;;;778    
                          ENDP

                  |L1.28|
                          DCD      0x40003000

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;900     */
;;;901    void RCC_AHBPeriphResetCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;902    {
;;;903        /* Check the parameters */
;;;904        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;905    
;;;906        if ( NewState != DISABLE )
000002  d005              BEQ      |L2.16|
;;;907        {
;;;908            RCCAHB->AHB_RST |= RCC_AHBPeriph;
000004  4a05              LDR      r2,|L2.28|
000006  6852              LDR      r2,[r2,#4]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L2.28|
00000c  605a              STR      r2,[r3,#4]
00000e  e004              B        |L2.26|
                  |L2.16|
;;;909        }
;;;910        else
;;;911        {
;;;912            RCCAHB->AHB_RST &= ~RCC_AHBPeriph;
000010  4a02              LDR      r2,|L2.28|
000012  6852              LDR      r2,[r2,#4]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L2.28|
000018  605a              STR      r2,[r3,#4]
                  |L2.26|
;;;913        }
;;;914    }
00001a  4770              BX       lr
;;;915    
                          ENDP

                  |L2.28|
                          DCD      0x40003000

                          AREA ||i.RCC_APB0Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0Cmd PROC
;;;274      */
;;;275    void RCC_APB0Cmd ( FunctionalState NewState )
000000  2800              CMP      r0,#0
;;;276    {
;;;277        /* Check the parameters */
;;;278        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;279    
;;;280        if ( NewState != DISABLE )
000002  d007              BEQ      |L3.20|
;;;281        {
;;;282            RCCAPB0->APB0_CFG |= APB0_CFG_ENAPB;
000004  4907              LDR      r1,|L3.36|
000006  6809              LDR      r1,[r1,#0]
000008  2201              MOVS     r2,#1
00000a  05d2              LSLS     r2,r2,#23
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L3.36|
000010  6011              STR      r1,[r2,#0]
000012  e006              B        |L3.34|
                  |L3.20|
;;;283        }
;;;284        else
;;;285        {
;;;286            RCCAPB0->APB0_CFG &= ~APB0_CFG_ENAPB;
000014  4903              LDR      r1,|L3.36|
000016  6809              LDR      r1,[r1,#0]
000018  2201              MOVS     r2,#1
00001a  05d2              LSLS     r2,r2,#23
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L3.36|
000020  6011              STR      r1,[r2,#0]
                  |L3.34|
;;;287        }
;;;288    }
000022  4770              BX       lr
;;;289    
                          ENDP

                  |L3.36|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0Config||, CODE, READONLY, ALIGN=2

                  RCC_APB0Config PROC
;;;533     */
;;;534    void RCC_APB0Config ( RCC_PCLK_TypeDef RCC_APB0CLK )
000000  4905              LDR      r1,|L4.24|
;;;535    {
;;;536        /* Check the parameters */
;;;537        assert_param ( IS_RCC_PCLK ( RCC_APB0CLK ) );
;;;538    
;;;539        RCCAPB0->APB0_CFG &= ~ ( ( uint32_t ) APB0_CFG_CLKDIV );
000002  6809              LDR      r1,[r1,#0]
000004  2207              MOVS     r2,#7
000006  0512              LSLS     r2,r2,#20
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L4.24|
00000c  6011              STR      r1,[r2,#0]
;;;540        RCCAPB0->APB0_CFG |= RCC_APB0CLK;
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;541    }
000016  4770              BX       lr
;;;542    
                          ENDP

                  |L4.24|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphClockCmd PROC
;;;801      */
;;;802    void RCC_APB0PeriphClockCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;803    {
;;;804        /* Check the parameters */
;;;805        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;806    
;;;807        if ( NewState != DISABLE )
000002  d005              BEQ      |L5.16|
;;;808        {
;;;809            RCCAPB0->APB0_CFG |= RCC_APB0Periph;
000004  4a05              LDR      r2,|L5.28|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L5.28|
00000c  601a              STR      r2,[r3,#0]
00000e  e004              B        |L5.26|
                  |L5.16|
;;;810        }
;;;811        else
;;;812        {
;;;813            RCCAPB0->APB0_CFG &= ~RCC_APB0Periph;
000010  4a02              LDR      r2,|L5.28|
000012  6812              LDR      r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L5.28|
000018  601a              STR      r2,[r3,#0]
                  |L5.26|
;;;814        }
;;;815    }
00001a  4770              BX       lr
;;;816    
                          ENDP

                  |L5.28|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphResetCmd PROC
;;;938     */
;;;939    void RCC_APB0PeriphResetCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;940    {
;;;941        /* Check the parameters */
;;;942        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;943    
;;;944        if ( NewState != DISABLE )
000002  d005              BEQ      |L6.16|
;;;945        {
;;;946            RCCAPB0->APB0_RST |= RCC_APB0Periph;
000004  4a05              LDR      r2,|L6.28|
000006  6852              LDR      r2,[r2,#4]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L6.28|
00000c  605a              STR      r2,[r3,#4]
00000e  e004              B        |L6.26|
                  |L6.16|
;;;947        }
;;;948        else
;;;949        {
;;;950            RCCAPB0->APB0_RST &= ~RCC_APB0Periph;
000010  4a02              LDR      r2,|L6.28|
000012  6852              LDR      r2,[r2,#4]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L6.28|
000018  605a              STR      r2,[r3,#4]
                  |L6.26|
;;;951        }
;;;952    }
00001a  4770              BX       lr
;;;953    
                          ENDP

                  |L6.28|
                          DCD      0x40020000

                          AREA ||i.RCC_APB1Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1Cmd PROC
;;;296      */
;;;297    void RCC_APB1Cmd ( FunctionalState NewState )
000000  2800              CMP      r0,#0
;;;298    {
;;;299        /* Check the parameters */
;;;300        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;301    
;;;302        if ( NewState != DISABLE )
000002  d007              BEQ      |L7.20|
;;;303        {
;;;304            RCCAPB1->APB1_CFG |= APB1_CFG_ENAPB;
000004  4907              LDR      r1,|L7.36|
000006  6809              LDR      r1,[r1,#0]
000008  2201              MOVS     r2,#1
00000a  05d2              LSLS     r2,r2,#23
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L7.36|
000010  6011              STR      r1,[r2,#0]
000012  e006              B        |L7.34|
                  |L7.20|
;;;305        }
;;;306        else
;;;307        {
;;;308            RCCAPB1->APB1_CFG &= ~APB1_CFG_ENAPB;
000014  4903              LDR      r1,|L7.36|
000016  6809              LDR      r1,[r1,#0]
000018  2201              MOVS     r2,#1
00001a  05d2              LSLS     r2,r2,#23
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L7.36|
000020  6011              STR      r1,[r2,#0]
                  |L7.34|
;;;309        }
;;;310    }
000022  4770              BX       lr
;;;311    
                          ENDP

                  |L7.36|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1Config||, CODE, READONLY, ALIGN=2

                  RCC_APB1Config PROC
;;;555     */
;;;556    void RCC_APB1Config ( RCC_PCLK_TypeDef RCC_APB1CLK )
000000  4905              LDR      r1,|L8.24|
;;;557    {
;;;558        /* Check the parameters */
;;;559        assert_param ( IS_RCC_PCLK ( RCC_APB1CLK ) );
;;;560    
;;;561        RCCAPB1->APB1_CFG &= ~ ( ( uint32_t ) APB1_CFG_CLKDIV );
000002  6809              LDR      r1,[r1,#0]
000004  2207              MOVS     r2,#7
000006  0512              LSLS     r2,r2,#20
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L8.24|
00000c  6011              STR      r1,[r2,#0]
;;;562        RCCAPB1->APB1_CFG |= RCC_APB1CLK;
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;563    }
000016  4770              BX       lr
;;;564    
                          ENDP

                  |L8.24|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;838      */
;;;839    void RCC_APB1PeriphClockCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;840    {
;;;841        /* Check the parameters */
;;;842        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;843    
;;;844        if ( NewState != DISABLE )
000002  d005              BEQ      |L9.16|
;;;845        {
;;;846            RCCAPB1->APB1_CFG |= RCC_APB1Periph;
000004  4a05              LDR      r2,|L9.28|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L9.28|
00000c  601a              STR      r2,[r3,#0]
00000e  e004              B        |L9.26|
                  |L9.16|
;;;847        }
;;;848        else
;;;849        {
;;;850            RCCAPB1->APB1_CFG &= ~RCC_APB1Periph;
000010  4a02              LDR      r2,|L9.28|
000012  6812              LDR      r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L9.28|
000018  601a              STR      r2,[r3,#0]
                  |L9.26|
;;;851        }
;;;852    }
00001a  4770              BX       lr
;;;853    
                          ENDP

                  |L9.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;975     */
;;;976    void RCC_APB1PeriphResetCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;977    {
;;;978        /* Check the parameters */
;;;979        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;980    
;;;981        if ( NewState != DISABLE )
000002  d005              BEQ      |L10.16|
;;;982        {
;;;983            RCCAPB1->APB1_RST |= RCC_APB1Periph;
000004  4a05              LDR      r2,|L10.28|
000006  6852              LDR      r2,[r2,#4]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L10.28|
00000c  605a              STR      r2,[r3,#4]
00000e  e004              B        |L10.26|
                  |L10.16|
;;;984        }
;;;985        else
;;;986        {
;;;987            RCCAPB1->APB1_RST &= ~RCC_APB1Periph;
000010  4a02              LDR      r2,|L10.28|
000012  6852              LDR      r2,[r2,#4]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L10.28|
000018  605a              STR      r2,[r3,#4]
                  |L10.26|
;;;988        }
;;;989    }
00001a  4770              BX       lr
;;;990    
                          ENDP

                  |L10.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2Cmd PROC
;;;318      */
;;;319    void RCC_APB2Cmd ( FunctionalState NewState )
000000  2800              CMP      r0,#0
;;;320    {
;;;321        /* Check the parameters */
;;;322        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;323    
;;;324        if ( NewState != DISABLE )
000002  d007              BEQ      |L11.20|
;;;325        {
;;;326            RCCAPB2->APB2_CFG |= APB2_CFG_ENAPB;
000004  4907              LDR      r1,|L11.36|
000006  6809              LDR      r1,[r1,#0]
000008  2201              MOVS     r2,#1
00000a  05d2              LSLS     r2,r2,#23
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L11.36|
000010  6011              STR      r1,[r2,#0]
000012  e006              B        |L11.34|
                  |L11.20|
;;;327        }
;;;328        else
;;;329        {
;;;330            RCCAPB2->APB2_CFG &= ~APB2_CFG_ENAPB;
000014  4903              LDR      r1,|L11.36|
000016  6809              LDR      r1,[r1,#0]
000018  2201              MOVS     r2,#1
00001a  05d2              LSLS     r2,r2,#23
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L11.36|
000020  6011              STR      r1,[r2,#0]
                  |L11.34|
;;;331        }
;;;332    }
000022  4770              BX       lr
;;;333    
                          ENDP

                  |L11.36|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2Config||, CODE, READONLY, ALIGN=2

                  RCC_APB2Config PROC
;;;577     */
;;;578    void RCC_APB2Config ( RCC_PCLK_TypeDef RCC_APB2CLK )
000000  4905              LDR      r1,|L12.24|
;;;579    {
;;;580        /* Check the parameters */
;;;581        assert_param ( IS_RCC_PCLK ( RCC_APB2CLK ) );
;;;582    
;;;583        RCCAPB2->APB2_CFG &= ~ ( ( uint32_t ) APB2_CFG_CLKDIV );
000002  6809              LDR      r1,[r1,#0]
000004  2207              MOVS     r2,#7
000006  0512              LSLS     r2,r2,#20
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L12.24|
00000c  6011              STR      r1,[r2,#0]
;;;584        RCCAPB2->APB2_CFG |= RCC_APB2CLK;
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;585    }
000016  4770              BX       lr
;;;586    
                          ENDP

                  |L12.24|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;870      */
;;;871    void RCC_APB2PeriphClockCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;872    {
;;;873        /* Check the parameters */
;;;874        assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;875    
;;;876        if ( NewState != DISABLE )
000002  d005              BEQ      |L13.16|
;;;877        {
;;;878            RCCAPB2->APB2_CFG |= RCC_APB2Periph;
000004  4a05              LDR      r2,|L13.28|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L13.28|
00000c  601a              STR      r2,[r3,#0]
00000e  e004              B        |L13.26|
                  |L13.16|
;;;879        }
;;;880        else
;;;881        {
;;;882            RCCAPB2->APB2_CFG &= ~RCC_APB2Periph;
000010  4a02              LDR      r2,|L13.28|
000012  6812              LDR      r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L13.28|
000018  601a              STR      r2,[r3,#0]
                  |L13.26|
;;;883        }
;;;884    }
00001a  4770              BX       lr
;;;885    
                          ENDP

                  |L13.28|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1007    */
;;;1008   void RCC_APB2PeriphResetCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;1009   {
;;;1010       /* Check the parameters */
;;;1011       assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;1012   
;;;1013       if ( NewState != DISABLE )
000002  d005              BEQ      |L14.16|
;;;1014       {
;;;1015           RCCAPB2->APB2_RST |= RCC_APB2Periph;
000004  4a05              LDR      r2,|L14.28|
000006  6852              LDR      r2,[r2,#4]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L14.28|
00000c  605a              STR      r2,[r3,#4]
00000e  e004              B        |L14.26|
                  |L14.16|
;;;1016       }
;;;1017       else
;;;1018       {
;;;1019           RCCAPB2->APB2_RST &= ~RCC_APB2Periph;
000010  4a02              LDR      r2,|L14.28|
000012  6852              LDR      r2,[r2,#4]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L14.28|
000018  605a              STR      r2,[r3,#4]
                  |L14.26|
;;;1020       }
;;;1021   }
00001a  4770              BX       lr
;;;1022   
                          ENDP

                  |L14.28|
                          DCD      0x40022000

                          AREA ||i.RCC_BTMCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_BTMCLKConfig PROC
;;;737     */
;;;738    void RCC_BTMCLKConfig ( RCC_BTMCLKSource_TypeDef RCC_BTMCLKSource )
000000  b500              PUSH     {lr}
;;;739    {
000002  4602              MOV      r2,r0
;;;740        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;741        /* Check the parameters */
;;;742        assert_param ( RCC_BTMCLKSOURCE ( RCC_BTMCLKSource ) );
;;;743    
;;;744        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_BTMCLKSEL );
00000a  4805              LDR      r0,|L15.32|
00000c  6980              LDR      r0,[r0,#0x18]
00000e  0840              LSRS     r0,r0,#1
000010  0040              LSLS     r0,r0,#1
000012  4903              LDR      r1,|L15.32|
000014  6188              STR      r0,[r1,#0x18]
;;;745        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_BTMCLKSource );
000016  4608              MOV      r0,r1
000018  6980              LDR      r0,[r0,#0x18]
00001a  4310              ORRS     r0,r0,r2
00001c  6188              STR      r0,[r1,#0x18]
;;;746    }
00001e  bd00              POP      {pc}
;;;747    
                          ENDP

                  |L15.32|
                          DCD      0x40003000

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1221    */
;;;1222   void RCC_ClearFlag ( uint32_t RCC_FLAG )
000000  4902              LDR      r1,|L16.12|
;;;1223   {
;;;1224       /* Check the parameters */
;;;1225       assert_param ( IS_GET_RCC_FLAG ( RCC_FLAG ) );
;;;1226   
;;;1227       /* Clear the flags */
;;;1228       RCC->RCC_STS |= ( uint32_t ) RCC_FLAG;
000002  6a09              LDR      r1,[r1,#0x20]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L16.12|
000008  6211              STR      r1,[r2,#0x20]
;;;1229   }
00000a  4770              BX       lr
;;;1230   #endif
                          ENDP

                  |L16.12|
                          DCD      0x40003000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;62      */
;;;63     void RCC_DeInit ( void )
000000  2040              MOVS     r0,#0x40
;;;64     {
;;;65         /*	RCC Reg Unlock = 0 */
;;;66         RCC->RCC_KEY = 0x40;
000002  4904              LDR      r1,|L17.20|
000004  60c8              STR      r0,[r1,#0xc]
;;;67     
;;;68         /* Reset RCC_CFG0 register */
;;;69         RCC->RCC_CFG0 = ( uint32_t ) 0x00001040;
000006  2041              MOVS     r0,#0x41
000008  0180              LSLS     r0,r0,#6
00000a  6148              STR      r0,[r1,#0x14]
;;;70     
;;;71         /* Reset RCC_CFG1 register */
;;;72         RCC->RCC_CFG1 = ( uint32_t ) 0x00000000;
00000c  2000              MOVS     r0,#0
00000e  6188              STR      r0,[r1,#0x18]
;;;73     
;;;74     #if defined(SC32f10xx)
;;;75         /* Reset PLL_CFG register */
;;;76         RCC->PLL_CFG = ( uint32_t ) 0x00000000;
;;;77     #endif
;;;78     
;;;79         /* Reset PLL_CFG register */
;;;80         RCC->NMI_CFG = ( uint32_t ) 0x00000000;
000010  62c8              STR      r0,[r1,#0x2c]
;;;81     
;;;82     }
000012  4770              BX       lr
;;;83     
                          ENDP

                  |L17.20|
                          DCD      0x40003000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;592      */
;;;593    void RCC_GetClocksFreq ( RCC_ClocksTypeDef* RCC_Clocks )
000000  4a25              LDR      r2,|L18.152|
;;;594    {
;;;595        uint32_t  tmp;
;;;596    
;;;597    #if defined(SC32f10xx)
;;;598        uint32_t  pllp, pllsource, pllm, plln;
;;;599    #endif
;;;600    
;;;601        /* Get SYSCLK source -------------------------------------------------------*/
;;;602        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
000002  6952              LDR      r2,[r2,#0x14]
000004  2380              MOVS     r3,#0x80
000006  401a              ANDS     r2,r2,r3
000008  2a00              CMP      r2,#0
00000a  d102              BNE      |L18.18|
;;;603        {
;;;604    #if defined(SC32f10xx) || defined(SC32f12xx)
;;;605           RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE / 2;      
00000c  4a23              LDR      r2,|L18.156|
00000e  6002              STR      r2,[r0,#0]
000010  e022              B        |L18.88|
                  |L18.18|
;;;606    #endif
;;;607        }
;;;608        else
;;;609        {
;;;610            switch ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL )
000012  4a21              LDR      r2,|L18.152|
000014  6952              LDR      r2,[r2,#0x14]
000016  2303              MOVS     r3,#3
000018  021b              LSLS     r3,r3,#8
00001a  401a              ANDS     r2,r2,r3
00001c  2a00              CMP      r2,#0
00001e  d00f              BEQ      |L18.64|
000020  3aff              SUBS     r2,r2,#0xff
000022  3a01              SUBS     r2,#1
000024  2a00              CMP      r2,#0
000026  d008              BEQ      |L18.58|
000028  3aff              SUBS     r2,r2,#0xff
00002a  3a01              SUBS     r2,#1
00002c  2a00              CMP      r2,#0
00002e  d00f              BEQ      |L18.80|
000030  3aff              SUBS     r2,r2,#0xff
000032  3a01              SUBS     r2,#1
000034  2a00              CMP      r2,#0
000036  d10e              BNE      |L18.86|
000038  e006              B        |L18.72|
                  |L18.58|
;;;611            {
;;;612    #if defined(SC32f12xx)
;;;613            case RCC_SYSCLKSource_HXT:   /* HXT used as system clock source */
;;;614                RCC_Clocks->SYSCLK_Frequency = HXT_VALUE;
00003a  4a19              LDR      r2,|L18.160|
00003c  6002              STR      r2,[r0,#0]
;;;615                break;
00003e  e00a              B        |L18.86|
                  |L18.64|
;;;616    #endif
;;;617            case RCC_SYSCLKSource_LIRC:   /* LIRC used as system clock source */
;;;618                RCC_Clocks->SYSCLK_Frequency = LIRC_VALUE;
000040  227d              MOVS     r2,#0x7d
000042  0212              LSLS     r2,r2,#8
000044  6002              STR      r2,[r0,#0]
;;;619                break;
000046  e006              B        |L18.86|
                  |L18.72|
;;;620            case RCC_SYSCLKSource_LXT:   /* LXT used as system clock source */
;;;621                RCC_Clocks->SYSCLK_Frequency = LXT_VALUE;
000048  2201              MOVS     r2,#1
00004a  03d2              LSLS     r2,r2,#15
00004c  6002              STR      r2,[r0,#0]
;;;622                break;
00004e  e002              B        |L18.86|
                  |L18.80|
;;;623    #if defined(SC32f12xx)
;;;624            case RCC_SYSCLKSource_HIRC:   /* HIRC used as system clock source */
;;;625                RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE;
000050  4a14              LDR      r2,|L18.164|
000052  6002              STR      r2,[r0,#0]
;;;626                break;
000054  bf00              NOP      
                  |L18.86|
000056  bf00              NOP                            ;615
                  |L18.88|
;;;627    #elif defined(SC32f10xx)
;;;628            case RCC_SYSCLKSource_PLLRCLK:   /* PLL used as system clock source */
;;;629                if ( ( RCC->PLL_CFG & PLL_CFG_PLLCLKSEL ) == RESET ) /* HXT used as PLL clock source */
;;;630                {
;;;631                    pllsource = HIRC_VALUE;
;;;632                }
;;;633                else   /* HIRC used as PLL clock source */
;;;634                {
;;;635                    pllsource = HXT_VALUE;
;;;636                }
;;;637    
;;;638                pllm = ( ( RCC->PLL_CFG & PLL_CFG_MDIVM ) >> PLL_CFG_MDIVM_Pos );
;;;639                plln = ( ( RCC->PLL_CFG & PLL_CFG_NDIVN ) >> PLL_CFG_NDIVN_Pos );
;;;640                pllp = ( ( RCC->PLL_CFG & PLL_CFG_PDIVP ) >> PLL_CFG_PDIVP_Pos );
;;;641    
;;;642                RCC_Clocks->SYSCLK_Frequency = ( ( ( pllsource / pllm ) * plln ) >> ( pllp + 1 ) );
;;;643                break;
;;;644    #endif
;;;645            }
;;;646        }
;;;647    
;;;648        /* Get AHB source -------------------------------------------------------*/
;;;649        tmp = ( ( RCCAHB->AHB_CFG & AHB_CFG_CLKDIV ) >> AHB_CFG_CLKDIV_Pos );
000058  4a0f              LDR      r2,|L18.152|
00005a  6812              LDR      r2,[r2,#0]
00005c  2307              MOVS     r3,#7
00005e  051b              LSLS     r3,r3,#20
000060  401a              ANDS     r2,r2,r3
000062  0d11              LSRS     r1,r2,#20
;;;650        RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> tmp;
000064  6802              LDR      r2,[r0,#0]
000066  40ca              LSRS     r2,r2,r1
000068  6042              STR      r2,[r0,#4]
;;;651    
;;;652        /* Get APB source -------------------------------------------------------*/
;;;653        tmp = ( ( RCCAPB0->APB0_CFG & APB0_CFG_CLKDIV ) >> APB0_CFG_CLKDIV_Pos );
00006a  4a0f              LDR      r2,|L18.168|
00006c  6812              LDR      r2,[r2,#0]
00006e  401a              ANDS     r2,r2,r3
000070  0d11              LSRS     r1,r2,#20
;;;654        RCC_Clocks->PCLK0_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
000072  6842              LDR      r2,[r0,#4]
000074  40ca              LSRS     r2,r2,r1
000076  6082              STR      r2,[r0,#8]
;;;655    
;;;656        /* Get AHB source -------------------------------------------------------*/
;;;657        tmp = ( ( RCCAPB1->APB1_CFG & APB1_CFG_CLKDIV ) >> APB1_CFG_CLKDIV_Pos );
000078  4a0c              LDR      r2,|L18.172|
00007a  6812              LDR      r2,[r2,#0]
00007c  401a              ANDS     r2,r2,r3
00007e  0d11              LSRS     r1,r2,#20
;;;658        RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
000080  6842              LDR      r2,[r0,#4]
000082  40ca              LSRS     r2,r2,r1
000084  60c2              STR      r2,[r0,#0xc]
;;;659    
;;;660        /* Get AHB source -------------------------------------------------------*/
;;;661        tmp = ( ( RCCAPB2->APB2_CFG & APB2_CFG_CLKDIV ) >> APB2_CFG_CLKDIV_Pos );
000086  4a0a              LDR      r2,|L18.176|
000088  6812              LDR      r2,[r2,#0]
00008a  401a              ANDS     r2,r2,r3
00008c  0d11              LSRS     r1,r2,#20
;;;662        RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
00008e  6842              LDR      r2,[r0,#4]
000090  40ca              LSRS     r2,r2,r1
000092  6102              STR      r2,[r0,#0x10]
;;;663    }
000094  4770              BX       lr
;;;664    
                          ENDP

000096  0000              DCW      0x0000
                  |L18.152|
                          DCD      0x40003000
                  |L18.156|
                          DCD      0x01e84800
                  |L18.160|
                          DCD      0x00f42400
                  |L18.164|
                          DCD      0x03d09000
                  |L18.168|
                          DCD      0x40020000
                  |L18.172|
                          DCD      0x40021000
                  |L18.176|
                          DCD      0x40022000

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1202    */
;;;1203   FlagStatus RCC_GetFlagStatus ( uint32_t RCC_FLAG )
000000  4601              MOV      r1,r0
;;;1204   {
;;;1205       /* Check the parameters */
;;;1206       assert_param ( IS_GET_RCC_FLAG ( RCC_FLAG ) );
;;;1207   
;;;1208       if( ( RCC->RCC_STS & RCC_FLAG ) != ( uint32_t ) RESET )
000002  4804              LDR      r0,|L19.20|
000004  6a00              LDR      r0,[r0,#0x20]
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L19.16|
;;;1209       {
;;;1210           return ( SET );
00000c  2001              MOVS     r0,#1
                  |L19.14|
;;;1211       }
;;;1212       return ( RESET );
;;;1213   }
00000e  4770              BX       lr
                  |L19.16|
000010  2000              MOVS     r0,#0                 ;1212
000012  e7fc              B        |L19.14|
;;;1214   
                          ENDP

                  |L19.20|
                          DCD      0x40003000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;484      */
;;;485    RCC_SYSCLKSource_TypeDef RCC_GetSYSCLKSource ( void )
000000  4806              LDR      r0,|L20.28|
;;;486    {
;;;487        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
000002  6940              LDR      r0,[r0,#0x14]
000004  2180              MOVS     r1,#0x80
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d005              BEQ      |L20.24|
;;;488        {
;;;489            return ( ( RCC_SYSCLKSource_TypeDef ) ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL ) );
00000c  4803              LDR      r0,|L20.28|
00000e  6940              LDR      r0,[r0,#0x14]
000010  2103              MOVS     r1,#3
000012  0209              LSLS     r1,r1,#8
000014  4008              ANDS     r0,r0,r1
                  |L20.22|
;;;490        }
;;;491        else
;;;492        {
;;;493    #if defined (SC32f10xx)
;;;494            return RCC_SYSCLKSource_HIRC;
;;;495    #elif  defined (SC32f12xx)
;;;496            return RCC_SYSCLKSource_HIRC_2;
;;;497    #endif
;;;498        }
;;;499    
;;;500    }
000016  4770              BX       lr
                  |L20.24|
000018  4801              LDR      r0,|L20.32|
00001a  e7fc              B        |L20.22|
;;;501    
                          ENDP

                  |L20.28|
                          DCD      0x40003000
                  |L20.32|
                          DCD      0x0000ff7f

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;511     */
;;;512    void RCC_HCLKConfig ( RCC_HCLK_TypeDef RCC_HCLK )
000000  4905              LDR      r1,|L21.24|
;;;513    {
;;;514        /* Check the parameters */
;;;515        assert_param ( IS_RCC_HCLK ( RCC_HCLK ) );
;;;516    
;;;517        RCCAHB->AHB_CFG &= ( uint32_t ) ~ ( AHB_CFG_CLKDIV );
000002  6809              LDR      r1,[r1,#0]
000004  2207              MOVS     r2,#7
000006  0512              LSLS     r2,r2,#20
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L21.24|
00000c  6011              STR      r1,[r2,#0]
;;;518        RCCAHB->AHB_CFG |= RCC_HCLK;
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;519    }
000016  4770              BX       lr
;;;520    
                          ENDP

                  |L21.24|
                          DCD      0x40003000

                          AREA ||i.RCC_HIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_HIRCCmd PROC
;;;135      */
;;;136    void RCC_HIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;137    {
000002  4602              MOV      r2,r0
;;;138        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;139        if ( NewState != DISABLE )
00000a  2a00              CMP      r2,#0
00000c  d006              BEQ      |L22.28|
;;;140        {
;;;141            /* Enable the selected HIRC peripheral */
;;;142            RCC->RCC_CFG0 |= RCC_CFG0_HIRCEN;
00000e  4807              LDR      r0,|L22.44|
000010  6940              LDR      r0,[r0,#0x14]
000012  2140              MOVS     r1,#0x40
000014  4308              ORRS     r0,r0,r1
000016  4905              LDR      r1,|L22.44|
000018  6148              STR      r0,[r1,#0x14]
00001a  e005              B        |L22.40|
                  |L22.28|
;;;143        }
;;;144        else
;;;145        {
;;;146            /* Disable the selected HIRC peripheral */
;;;147            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HIRCEN );
00001c  4803              LDR      r0,|L22.44|
00001e  6940              LDR      r0,[r0,#0x14]
000020  2140              MOVS     r1,#0x40
000022  4388              BICS     r0,r0,r1
000024  4901              LDR      r1,|L22.44|
000026  6148              STR      r0,[r1,#0x14]
                  |L22.40|
;;;148        }
;;;149    }
000028  bd00              POP      {pc}
;;;150    
                          ENDP

00002a  0000              DCW      0x0000
                  |L22.44|
                          DCD      0x40003000

                          AREA ||i.RCC_HIRCDIV1Cmd||, CODE, READONLY, ALIGN=2

                  RCC_HIRCDIV1Cmd PROC
;;;252    
;;;253    void RCC_HIRCDIV1Cmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;254    {
000002  4602              MOV      r2,r0
;;;255        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;256        if ( NewState != DISABLE )
00000a  2a00              CMP      r2,#0
00000c  d007              BEQ      |L23.30|
;;;257        {
;;;258            /* Enable the selected HIRCDIV1 peripheral */
;;;259            RCC->RCC_CFG0 |= RCC_CFG0_HIRCDIV1;
00000e  4808              LDR      r0,|L23.48|
000010  6940              LDR      r0,[r0,#0x14]
000012  2101              MOVS     r1,#1
000014  0389              LSLS     r1,r1,#14
000016  4308              ORRS     r0,r0,r1
000018  4905              LDR      r1,|L23.48|
00001a  6148              STR      r0,[r1,#0x14]
00001c  e006              B        |L23.44|
                  |L23.30|
;;;260        }
;;;261        else
;;;262        {
;;;263            /* Disable the selected HIRCDIV1 peripheral */
;;;264            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HIRCDIV1 );
00001e  4804              LDR      r0,|L23.48|
000020  6940              LDR      r0,[r0,#0x14]
000022  2101              MOVS     r1,#1
000024  0389              LSLS     r1,r1,#14
000026  4388              BICS     r0,r0,r1
000028  4901              LDR      r1,|L23.48|
00002a  6148              STR      r0,[r1,#0x14]
                  |L23.44|
;;;265        }
;;;266    }
00002c  bd00              POP      {pc}
;;;267    #endif
                          ENDP

00002e  0000              DCW      0x0000
                  |L23.48|
                          DCD      0x40003000

                          AREA ||i.RCC_HXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_HXTCmd PROC
;;;113      */
;;;114    void RCC_HXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;115    {
000002  4602              MOV      r2,r0
;;;116        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;117        if ( NewState != DISABLE )
00000a  2a00              CMP      r2,#0
00000c  d006              BEQ      |L24.28|
;;;118        {
;;;119            /* Enable the selected HXT peripheral */
;;;120            RCC->RCC_CFG0 |= RCC_CFG0_HXTEN;
00000e  4807              LDR      r0,|L24.44|
000010  6940              LDR      r0,[r0,#0x14]
000012  2120              MOVS     r1,#0x20
000014  4308              ORRS     r0,r0,r1
000016  4905              LDR      r1,|L24.44|
000018  6148              STR      r0,[r1,#0x14]
00001a  e005              B        |L24.40|
                  |L24.28|
;;;121        }
;;;122        else
;;;123        {
;;;124            /* Disable the selected HXT peripheral */
;;;125            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HXTEN );
00001c  4803              LDR      r0,|L24.44|
00001e  6940              LDR      r0,[r0,#0x14]
000020  2120              MOVS     r1,#0x20
000022  4388              BICS     r0,r0,r1
000024  4901              LDR      r1,|L24.44|
000026  6148              STR      r0,[r1,#0x14]
                  |L24.40|
;;;126        }
;;;127    }
000028  bd00              POP      {pc}
;;;128    
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      0x40003000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1176     */
;;;1177   void RCC_ITConfig ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;1178   {
000002  4602              MOV      r2,r0
;;;1179       RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;1180       if ( NewState != DISABLE )
00000a  2a00              CMP      r2,#0
00000c  d007              BEQ      |L25.30|
;;;1181       {
;;;1182           RCC->RCC_CFG0 |= RCC_CFG0_INTEN;
00000e  4808              LDR      r0,|L25.48|
000010  6940              LDR      r0,[r0,#0x14]
000012  2101              MOVS     r1,#1
000014  03c9              LSLS     r1,r1,#15
000016  4308              ORRS     r0,r0,r1
000018  4905              LDR      r1,|L25.48|
00001a  6148              STR      r0,[r1,#0x14]
00001c  e006              B        |L25.44|
                  |L25.30|
;;;1183       }
;;;1184       else
;;;1185       {
;;;1186           RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_INTEN );
00001e  4804              LDR      r0,|L25.48|
000020  6940              LDR      r0,[r0,#0x14]
000022  2101              MOVS     r1,#1
000024  03c9              LSLS     r1,r1,#15
000026  4388              BICS     r0,r0,r1
000028  4901              LDR      r1,|L25.48|
00002a  6148              STR      r0,[r1,#0x14]
                  |L25.44|
;;;1187       }
;;;1188   }
00002c  bd00              POP      {pc}
;;;1189   
                          ENDP

00002e  0000              DCW      0x0000
                  |L25.48|
                          DCD      0x40003000

                          AREA ||i.RCC_LCDLEDCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_LCDLEDCLKConfig PROC
;;;720     */
;;;721    void RCC_LCDLEDCLKConfig ( RCC_LCDLEDCLKSource_TypeDef RCC_LCDLEDCLKSource )
000000  b500              PUSH     {lr}
;;;722    {
000002  4602              MOV      r2,r0
;;;723        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;724        /* Check the parameters */
;;;725        assert_param ( RCC_LCDLEDCLKSOURCE ( RCC_LCDLEDCLKSource ) );
;;;726    
;;;727        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_LCDCLKSEL );
00000a  4805              LDR      r0,|L26.32|
00000c  6980              LDR      r0,[r0,#0x18]
00000e  2102              MOVS     r1,#2
000010  4388              BICS     r0,r0,r1
000012  4903              LDR      r1,|L26.32|
000014  6188              STR      r0,[r1,#0x18]
;;;728        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_LCDLEDCLKSource );
000016  4608              MOV      r0,r1
000018  6980              LDR      r0,[r0,#0x18]
00001a  4310              ORRS     r0,r0,r2
00001c  6188              STR      r0,[r1,#0x18]
;;;729    }
00001e  bd00              POP      {pc}
;;;730    #endif
                          ENDP

                  |L26.32|
                          DCD      0x40003000

                          AREA ||i.RCC_LIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_LIRCCmd PROC
;;;179      */
;;;180    void RCC_LIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;181    {
000002  4602              MOV      r2,r0
;;;182        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;183        if ( NewState != DISABLE )
00000a  2a00              CMP      r2,#0
00000c  d006              BEQ      |L27.28|
;;;184        {
;;;185            /* Enable the selected LIRC peripheral */
;;;186            RCC->RCC_CFG0 |= RCC_CFG0_LIRCEN;
00000e  4807              LDR      r0,|L27.44|
000010  6940              LDR      r0,[r0,#0x14]
000012  2102              MOVS     r1,#2
000014  4308              ORRS     r0,r0,r1
000016  4905              LDR      r1,|L27.44|
000018  6148              STR      r0,[r1,#0x14]
00001a  e005              B        |L27.40|
                  |L27.28|
;;;187        }
;;;188        else
;;;189        {
;;;190            /* Disable the selected LIRC peripheral */
;;;191            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LIRCEN );
00001c  4803              LDR      r0,|L27.44|
00001e  6940              LDR      r0,[r0,#0x14]
000020  2102              MOVS     r1,#2
000022  4388              BICS     r0,r0,r1
000024  4901              LDR      r1,|L27.44|
000026  6148              STR      r0,[r1,#0x14]
                  |L27.40|
;;;192        }
;;;193    }
000028  bd00              POP      {pc}
;;;194    
                          ENDP

00002a  0000              DCW      0x0000
                  |L27.44|
                          DCD      0x40003000

                          AREA ||i.RCC_LXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_LXTCmd PROC
;;;157      */
;;;158    void RCC_LXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;159    {
000002  4602              MOV      r2,r0
;;;160        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;161        if ( NewState != DISABLE )
00000a  2a00              CMP      r2,#0
00000c  d006              BEQ      |L28.28|
;;;162        {
;;;163            /* Enable the selected LXT peripheral */
;;;164            RCC->RCC_CFG0 |= RCC_CFG0_LXTEN;
00000e  4807              LDR      r0,|L28.44|
000010  6940              LDR      r0,[r0,#0x14]
000012  2101              MOVS     r1,#1
000014  4308              ORRS     r0,r0,r1
000016  4905              LDR      r1,|L28.44|
000018  6148              STR      r0,[r1,#0x14]
00001a  e005              B        |L28.40|
                  |L28.28|
;;;165        }
;;;166        else
;;;167        {
;;;168            /* Disable the selected LXT peripheral */
;;;169            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LXTEN );
00001c  4803              LDR      r0,|L28.44|
00001e  6940              LDR      r0,[r0,#0x14]
000020  0840              LSRS     r0,r0,#1
000022  0040              LSLS     r0,r0,#1
000024  4901              LDR      r1,|L28.44|
000026  6148              STR      r0,[r1,#0x14]
                  |L28.40|
;;;170        }
;;;171    }
000028  bd00              POP      {pc}
;;;172    
                          ENDP

00002a  0000              DCW      0x0000
                  |L28.44|
                          DCD      0x40003000

                          AREA ||i.RCC_NMICmd||, CODE, READONLY, ALIGN=2

                  RCC_NMICmd PROC
;;;1041    */
;;;1042   void RCC_NMICmd ( uint32_t RCC_NMIPeriph, FunctionalState NewState )
000000  4602              MOV      r2,r0
;;;1043   {
;;;1044       uint32_t temp;
;;;1045       /* Check the parameters */
;;;1046       assert_param ( IS_RCC_NMIPeriph ( RCC_NMIPeriph ) );
;;;1047   
;;;1048       temp = RCC->NMI_CFG;
000002  4b08              LDR      r3,|L29.36|
000004  6ad8              LDR      r0,[r3,#0x2c]
;;;1049   
;;;1050       temp &= ( ~RCC_NMIPeriph );
000006  4603              MOV      r3,r0
000008  4393              BICS     r3,r3,r2
00000a  4618              MOV      r0,r3
;;;1051   
;;;1052       if ( NewState != DISABLE )
00000c  2900              CMP      r1,#0
00000e  d003              BEQ      |L29.24|
;;;1053       {
;;;1054           temp |= 0xA05F0000 | RCC_NMIPeriph;
000010  4b05              LDR      r3,|L29.40|
000012  4313              ORRS     r3,r3,r2
000014  4318              ORRS     r0,r0,r3
000016  e001              B        |L29.28|
                  |L29.24|
;;;1055       }
;;;1056       else
;;;1057       {
;;;1058           temp |= 0xA05F0000;
000018  4b03              LDR      r3,|L29.40|
00001a  4318              ORRS     r0,r0,r3
                  |L29.28|
;;;1059       }
;;;1060       RCC->NMI_CFG = temp;
00001c  4b01              LDR      r3,|L29.36|
00001e  62d8              STR      r0,[r3,#0x2c]
;;;1061   }
000020  4770              BX       lr
;;;1062   /* End of RCC_Group3.	*/
                          ENDP

000022  0000              DCW      0x0000
                  |L29.36|
                          DCD      0x40003000
                  |L29.40|
                          DCD      0xa05f0000

                          AREA ||i.RCC_PWM0CLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_PWM0CLKConfig PROC
;;;702     */
;;;703    void RCC_PWM0CLKConfig ( RCC_PWM0CLKSource_TypeDef RCC_PWM0CLKSource )
000000  b500              PUSH     {lr}
;;;704    {
000002  4602              MOV      r2,r0
;;;705        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;706        /* Check the parameters */
;;;707        assert_param ( RCC_PWM0CLKSOURCE ( RCC_PWM0CLKSource ) );
;;;708    
;;;709        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_PWM0CLKSEL );
00000a  4805              LDR      r0,|L30.32|
00000c  6980              LDR      r0,[r0,#0x18]
00000e  2104              MOVS     r1,#4
000010  4388              BICS     r0,r0,r1
000012  4903              LDR      r1,|L30.32|
000014  6188              STR      r0,[r1,#0x18]
;;;710        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_PWM0CLKSource );
000016  4608              MOV      r0,r1
000018  6980              LDR      r0,[r0,#0x18]
00001a  4310              ORRS     r0,r0,r2
00001c  6188              STR      r0,[r1,#0x18]
;;;711    }
00001e  bd00              POP      {pc}
;;;712    #endif
                          ENDP

                  |L30.32|
                          DCD      0x40003000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;390     */
;;;391    ErrorStatus RCC_SYSCLKConfig ( RCC_SYSCLKSource_TypeDef RCC_SYSCLKSource )
000000  b500              PUSH     {lr}
;;;392    {
000002  4603              MOV      r3,r0
;;;393        uint32_t tmpreg;
;;;394        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;395    
;;;396        /* Check the parameters */
;;;397        assert_param ( IS_RCC_SYSCLKSOURCE ( RCC_SYSCLKSource ) );
;;;398    	
;;;399    		tmpreg = RCC->RCC_CFG0;
00000a  482b              LDR      r0,|L31.184|
00000c  6942              LDR      r2,[r0,#0x14]
;;;400    	
;;;401    		tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
00000e  2103              MOVS     r1,#3
000010  0309              LSLS     r1,r1,#12
000012  4610              MOV      r0,r2
000014  4388              BICS     r0,r0,r1
000016  4602              MOV      r2,r0
;;;402    	
;;;403    		tmpreg |= ( uint32_t ) RCC_WAIT_3;
000018  4608              MOV      r0,r1
00001a  4302              ORRS     r2,r2,r0
;;;404    	
;;;405    		RCC->RCC_CFG0 = tmpreg;
00001c  4826              LDR      r0,|L31.184|
00001e  6142              STR      r2,[r0,#0x14]
;;;406    	
;;;407        if ( RCC_SYSCLKSource != ( ( uint16_t ) ( ~RCC_CFG0_SYSCLKSW ) ) )
000020  4826              LDR      r0,|L31.188|
000022  4283              CMP      r3,r0
000024  d02b              BEQ      |L31.126|
;;;408        {
;;;409    		    RCC_Unlock ( 0xFF );
000026  20ff              MOVS     r0,#0xff
000028  f7fffffe          BL       RCC_Unlock
;;;410    				
;;;411            tmpreg = RCC->RCC_CFG0;
00002c  4822              LDR      r0,|L31.184|
00002e  6942              LDR      r2,[r0,#0x14]
;;;412    
;;;413            tmpreg &= ( uint32_t ) ~ ( RCC_CFG0_SYSCLKSEL | RCC_CFG0_SYSCLKSW );
000030  2107              MOVS     r1,#7
000032  01c9              LSLS     r1,r1,#7
000034  4610              MOV      r0,r2
000036  4388              BICS     r0,r0,r1
000038  4602              MOV      r2,r0
;;;414    
;;;415            tmpreg |= ( uint32_t ) RCC_SYSCLKSource;
00003a  4610              MOV      r0,r2
00003c  4318              ORRS     r0,r0,r3
00003e  4602              MOV      r2,r0
;;;416    
;;;417            RCC->RCC_CFG0 = tmpreg;
000040  481d              LDR      r0,|L31.184|
000042  6142              STR      r2,[r0,#0x14]
;;;418    
;;;419            RCC->RCC_CFG0 |= RCC_CFG0_SYSCLKSW;
000044  6940              LDR      r0,[r0,#0x14]
000046  2180              MOVS     r1,#0x80
000048  4308              ORRS     r0,r0,r1
00004a  491b              LDR      r1,|L31.184|
00004c  6148              STR      r0,[r1,#0x14]
;;;420    
;;;421            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
00004e  4608              MOV      r0,r1
000050  6940              LDR      r0,[r0,#0x14]
000052  2180              MOVS     r1,#0x80
000054  4008              ANDS     r0,r0,r1
000056  2800              CMP      r0,#0
000058  d00f              BEQ      |L31.122|
;;;422    				{
;;;423    #if defined(SC32f12xx)
;;;424    						if ( RCC_SYSCLKSource == RCC_SYSCLKSource_HIRC )
00005a  0088              LSLS     r0,r1,#2
00005c  4283              CMP      r3,r0
00005e  d10a              BNE      |L31.118|
;;;425    						{
;;;426    								tmpreg = RCC->RCC_CFG0;
000060  4815              LDR      r0,|L31.184|
000062  6942              LDR      r2,[r0,#0x14]
;;;427    								tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
000064  2103              MOVS     r1,#3
000066  0309              LSLS     r1,r1,#12
000068  4610              MOV      r0,r2
00006a  4388              BICS     r0,r0,r1
00006c  4602              MOV      r2,r0
;;;428    								tmpreg |= ( uint32_t ) RCC_WAIT_2;
00006e  0118              LSLS     r0,r3,#4
000070  4302              ORRS     r2,r2,r0
;;;429    								RCC->RCC_CFG0 = tmpreg;
000072  4811              LDR      r0,|L31.184|
000074  6142              STR      r2,[r0,#0x14]
                  |L31.118|
;;;430    						}
;;;431    #elif defined(SC32f10xx)
;;;432    						uint32_t Multioperator = 1;
;;;433    						for ( int i = 1; i <= ((RCC->PLL_CFG &0x03) + 1 ); i++ )
;;;434    						{
;;;435    								Multioperator *=  2;
;;;436    						}
;;;437    						if ( ( ( 2 * ((RCC->PLL_CFG &0xFF00)>>8) ) / Multioperator ) >= 64 )
;;;438    						{
;;;439    								tmpreg = RCC->RCC_CFG0;
;;;440    								tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
;;;441    								tmpreg |= ( uint32_t ) RCC_WAIT_1;
;;;442    							  RCC->RCC_CFG0 = tmpreg;
;;;443    						}
;;;444    #endif
;;;445    						return SUCCESS;
000076  2000              MOVS     r0,#0
                  |L31.120|
;;;446    					}
;;;447    					else
;;;448    					{
;;;449    						 return ERROR;
;;;450    					}
;;;451        }
;;;452        else
;;;453        {
;;;454            RCC->RCC_CFG0 &= ( uint32_t ) ~RCC_CFG0_SYSCLKSW;
;;;455    
;;;456            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
;;;457    				{
;;;458    						tmpreg = RCC->RCC_CFG0;
;;;459    						tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
;;;460    						tmpreg |= ( uint32_t ) RCC_WAIT_1;
;;;461    						RCC->RCC_CFG0 = tmpreg;
;;;462    					
;;;463    						return SUCCESS;
;;;464    				}
;;;465            else
;;;466    				{
;;;467                return ERROR;
;;;468    				}
;;;469        }
;;;470    }
000078  bd00              POP      {pc}
                  |L31.122|
00007a  2001              MOVS     r0,#1                 ;449
00007c  e7fc              B        |L31.120|
                  |L31.126|
00007e  480e              LDR      r0,|L31.184|
000080  6940              LDR      r0,[r0,#0x14]         ;454
000082  2180              MOVS     r1,#0x80              ;454
000084  4388              BICS     r0,r0,r1              ;454
000086  490c              LDR      r1,|L31.184|
000088  6148              STR      r0,[r1,#0x14]         ;454
00008a  4608              MOV      r0,r1                 ;456
00008c  6940              LDR      r0,[r0,#0x14]         ;456
00008e  2180              MOVS     r1,#0x80              ;456
000090  4008              ANDS     r0,r0,r1              ;456
000092  2800              CMP      r0,#0                 ;456
000094  d10d              BNE      |L31.178|
000096  4808              LDR      r0,|L31.184|
000098  6942              LDR      r2,[r0,#0x14]         ;458
00009a  2103              MOVS     r1,#3                 ;459
00009c  0309              LSLS     r1,r1,#12             ;459
00009e  4610              MOV      r0,r2                 ;459
0000a0  4388              BICS     r0,r0,r1              ;459
0000a2  4602              MOV      r2,r0                 ;459
0000a4  2001              MOVS     r0,#1                 ;460
0000a6  0300              LSLS     r0,r0,#12             ;460
0000a8  4302              ORRS     r2,r2,r0              ;460
0000aa  4803              LDR      r0,|L31.184|
0000ac  6142              STR      r2,[r0,#0x14]         ;461
0000ae  2000              MOVS     r0,#0                 ;463
0000b0  e7e2              B        |L31.120|
                  |L31.178|
0000b2  2001              MOVS     r0,#1                 ;467
0000b4  e7e0              B        |L31.120|
;;;471    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L31.184|
                          DCD      0x40003000
                  |L31.188|
                          DCD      0x0000ff7f

                          AREA ||i.RCC_SystickCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SystickCLKConfig PROC
;;;1085    */
;;;1086   void RCC_SystickCLKConfig ( RCC_SysTickSource_TypeDef RCC_SysTickSource )
000000  b500              PUSH     {lr}
;;;1087   {
000002  4602              MOV      r2,r0
;;;1088   
;;;1089       /* Check the parameters */
;;;1090       assert_param ( IS_RCC_SYSTICKSOURCE ( RCC_SysTickSource ) );
;;;1091   
;;;1092       if ( RCC_SysTickSource == RCC_SysTickSource_HCLK )
000004  2a01              CMP      r2,#1
000006  d106              BNE      |L32.22|
;;;1093       {
;;;1094           SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000008  480d              LDR      r0,|L32.64|
00000a  6900              LDR      r0,[r0,#0x10]
00000c  2104              MOVS     r1,#4
00000e  4308              ORRS     r0,r0,r1
000010  490b              LDR      r1,|L32.64|
000012  6108              STR      r0,[r1,#0x10]
000014  e012              B        |L32.60|
                  |L32.22|
;;;1095       }
;;;1096       else
;;;1097       {
;;;1098           RCC_Unlock ( 0xFF );
000016  20ff              MOVS     r0,#0xff
000018  f7fffffe          BL       RCC_Unlock
;;;1099           SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
00001c  4808              LDR      r0,|L32.64|
00001e  6900              LDR      r0,[r0,#0x10]
000020  2104              MOVS     r1,#4
000022  4388              BICS     r0,r0,r1
000024  4906              LDR      r1,|L32.64|
000026  6108              STR      r0,[r1,#0x10]
;;;1100           RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_STCLKSEL );
000028  4806              LDR      r0,|L32.68|
00002a  6980              LDR      r0,[r0,#0x18]
00002c  21e0              MOVS     r1,#0xe0
00002e  4388              BICS     r0,r0,r1
000030  4904              LDR      r1,|L32.68|
000032  6188              STR      r0,[r1,#0x18]
;;;1101           RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_SysTickSource );
000034  4608              MOV      r0,r1
000036  6980              LDR      r0,[r0,#0x18]
000038  4310              ORRS     r0,r0,r2
00003a  6188              STR      r0,[r1,#0x18]
                  |L32.60|
;;;1102       }
;;;1103   }
00003c  bd00              POP      {pc}
;;;1104   /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L32.64|
                          DCD      0xe000e000
                  |L32.68|
                          DCD      0x40003000

                          AREA ||i.RCC_SystickCmd||, CODE, READONLY, ALIGN=2

                  RCC_SystickCmd PROC
;;;1123     */
;;;1124   void RCC_SystickCmd ( FunctionalState NewState )
000000  2800              CMP      r0,#0
;;;1125   {
;;;1126       /* Check the parameters */
;;;1127       assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;1128   
;;;1129       if ( NewState != DISABLE )
000002  d006              BEQ      |L33.18|
;;;1130       {
;;;1131           SysTick->CTRL |= ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk ); /* Enable SysTick IRQ and SysTick Timer */
000004  4906              LDR      r1,|L33.32|
000006  6909              LDR      r1,[r1,#0x10]
000008  2203              MOVS     r2,#3
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L33.32|
00000e  6111              STR      r1,[r2,#0x10]
000010  e005              B        |L33.30|
                  |L33.18|
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135           SysTick->CTRL &= ~ ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk );
000012  4903              LDR      r1,|L33.32|
000014  6909              LDR      r1,[r1,#0x10]
000016  0889              LSRS     r1,r1,#2
000018  0089              LSLS     r1,r1,#2
00001a  4a01              LDR      r2,|L33.32|
00001c  6111              STR      r1,[r2,#0x10]
                  |L33.30|
;;;1136       }
;;;1137   }
00001e  4770              BX       lr
;;;1138   /**
                          ENDP

                  |L33.32|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickGetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_SystickGetFlagStatus PROC
;;;1144    */
;;;1145   FlagStatus RCC_SystickGetFlagStatus ( void )
000000  4805              LDR      r0,|L34.24|
;;;1146   {
;;;1147       if ( ( SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk ) != ( uint32_t ) RESET )
000002  6900              LDR      r0,[r0,#0x10]
000004  2101              MOVS     r1,#1
000006  0409              LSLS     r1,r1,#16
000008  4008              ANDS     r0,r0,r1
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L34.18|
;;;1148       {
;;;1149           return ( SET );
00000e  2001              MOVS     r0,#1
                  |L34.16|
;;;1150       }
;;;1151       return ( RESET );
;;;1152   }
000010  4770              BX       lr
                  |L34.18|
000012  2000              MOVS     r0,#0                 ;1151
000014  e7fc              B        |L34.16|
;;;1153   /**
                          ENDP

000016  0000              DCW      0x0000
                  |L34.24|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickSetCounter||, CODE, READONLY, ALIGN=2

                  RCC_SystickSetCounter PROC
;;;1108    */
;;;1109   void RCC_SystickSetCounter ( uint32_t Counter )
000000  1e41              SUBS     r1,r0,#1
;;;1110   {
;;;1111       if ( ( Counter - 1UL ) <= SysTick_LOAD_RELOAD_Msk ) /* Reload value possible */
000002  4a04              LDR      r2,|L35.20|
000004  4291              CMP      r1,r2
000006  d803              BHI      |L35.16|
;;;1112       {
;;;1113           SysTick->LOAD = ( uint32_t ) ( Counter - 1UL ); /* set reload register */
000008  4a03              LDR      r2,|L35.24|
00000a  6151              STR      r1,[r2,#0x14]
;;;1114           SysTick->VAL  = 0UL;   /* Load the SysTick Counter Value */
00000c  2100              MOVS     r1,#0
00000e  6191              STR      r1,[r2,#0x18]
                  |L35.16|
;;;1115       }
;;;1116   }
000010  4770              BX       lr
;;;1117   /**
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      0x00ffffff
                  |L35.24|
                          DCD      0xe000e000

                          AREA ||i.RCC_Unlock||, CODE, READONLY, ALIGN=2

                  RCC_Unlock PROC
;;;93      */
;;;94     ErrorStatus RCC_Unlock ( uint8_t TimeLimit )
000000  4601              MOV      r1,r0
;;;95     {
;;;96         if ( TimeLimit >= 0x40 )
000002  2940              CMP      r1,#0x40
000004  db03              BLT      |L36.14|
;;;97         {
;;;98             RCC->RCC_KEY = TimeLimit;
000006  4803              LDR      r0,|L36.20|
000008  60c1              STR      r1,[r0,#0xc]
;;;99             return SUCCESS;
00000a  2000              MOVS     r0,#0
                  |L36.12|
;;;100        }
;;;101        else
;;;102        {
;;;103            return ERROR;
;;;104        }
;;;105    }
00000c  4770              BX       lr
                  |L36.14|
00000e  2001              MOVS     r0,#1                 ;103
000010  e7fc              B        |L36.12|
;;;106    
                          ENDP

000012  0000              DCW      0x0000
                  |L36.20|
                          DCD      0x40003000

                          AREA ||i.RCC_WaitConfig||, CODE, READONLY, ALIGN=2

                  RCC_WaitConfig PROC
;;;673     */
;;;674    void RCC_WaitConfig ( RCC_Wait_TypeDef RCC_Wait )
000000  b500              PUSH     {lr}
;;;675    {
000002  4602              MOV      r2,r0
;;;676        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;677        /* Check the parameters */
;;;678        assert_param ( IS_RCC_Wait ( RCC_Wait ) );
;;;679    
;;;680        RCC->RCC_CFG0 &= ~RCC_CFG0_WAIT_Msk;
00000a  4806              LDR      r0,|L37.36|
00000c  6940              LDR      r0,[r0,#0x14]
00000e  2103              MOVS     r1,#3
000010  0309              LSLS     r1,r1,#12
000012  4388              BICS     r0,r0,r1
000014  4903              LDR      r1,|L37.36|
000016  6148              STR      r0,[r1,#0x14]
;;;681        RCC->RCC_CFG0 |= RCC_Wait;
000018  4608              MOV      r0,r1
00001a  6940              LDR      r0,[r0,#0x14]
00001c  4310              ORRS     r0,r0,r2
00001e  6148              STR      r0,[r1,#0x14]
;;;682    
;;;683    }
000020  bd00              POP      {pc}
;;;684    /** @defgroup RCC_Group3 Peripheral clocks configuration functions
                          ENDP

000022  0000              DCW      0x0000
                  |L37.36|
                          DCD      0x40003000

                          AREA ||i.SC_Delay||, CODE, READONLY, ALIGN=2

                  SC_Delay PROC
;;;1268     */
;;;1269   void SC_Delay(uint32_t ms_Delay)
000000  4602              MOV      r2,r0
;;;1270   {
;;;1271   		uint32_t tickstart = uwTick;
000002  4b0a              LDR      r3,|L38.44|
000004  6818              LDR      r0,[r3,#0]  ; uwTick
;;;1272   		uint32_t tickend = tickstart + ms_Delay;
000006  1881              ADDS     r1,r0,r2
;;;1273   		if(tickend < tickstart)
000008  4281              CMP      r1,r0
00000a  d209              BCS      |L38.32|
;;;1274   		{
;;;1275   			while(uwTick >= tickstart || uwTick < tickend);
00000c  bf00              NOP      
                  |L38.14|
00000e  4b07              LDR      r3,|L38.44|
000010  681b              LDR      r3,[r3,#0]  ; uwTick
000012  4283              CMP      r3,r0
000014  d2fb              BCS      |L38.14|
000016  4b05              LDR      r3,|L38.44|
000018  681b              LDR      r3,[r3,#0]  ; uwTick
00001a  428b              CMP      r3,r1
00001c  d3f7              BCC      |L38.14|
00001e  e004              B        |L38.42|
                  |L38.32|
;;;1276   		}
;;;1277   		else
;;;1278   		{
;;;1279   			while (uwTick < tickend);
000020  bf00              NOP      
                  |L38.34|
000022  4b02              LDR      r3,|L38.44|
000024  681b              LDR      r3,[r3,#0]  ; uwTick
000026  428b              CMP      r3,r1
000028  d3fb              BCC      |L38.34|
                  |L38.42|
;;;1280   		}
;;;1281   }
00002a  4770              BX       lr
;;;1282   
                          ENDP

                  |L38.44|
                          DCD      uwTick

                          AREA ||i.SC_Delay_us||, CODE, READONLY, ALIGN=2

                  SC_Delay_us PROC
;;;1298     */
;;;1299   void SC_Delay_us(uint32_t us_Delay,uint32_t Sys_freq)
000000  b570              PUSH     {r4-r6,lr}
;;;1300   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1301   		if(us_Delay < SC_MAX_DELAY && us_Delay >= 10)
000006  1c60              ADDS     r0,r4,#1
000008  2800              CMP      r0,#0
00000a  d013              BEQ      |L39.52|
00000c  2c0a              CMP      r4,#0xa
00000e  d311              BCC      |L39.52|
;;;1302   		{
;;;1303   			SysTick->LOAD = ( uint32_t ) ((us_Delay-2)* (Sys_freq/1000000));
000010  4909              LDR      r1,|L39.56|
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       __aeabi_uidivmod
000018  1ea1              SUBS     r1,r4,#2
00001a  4348              MULS     r0,r1,r0
00001c  4907              LDR      r1,|L39.60|
00001e  6148              STR      r0,[r1,#0x14]
;;;1304   			SysTick->VAL=0UL;
000020  2000              MOVS     r0,#0
000022  6188              STR      r0,[r1,#0x18]
;;;1305   			uint32_t tickstart = uwTick;
000024  4806              LDR      r0,|L39.64|
000026  6806              LDR      r6,[r0,#0]  ; uwTick
;;;1306   			while(uwTick==tickstart);
000028  bf00              NOP      
                  |L39.42|
00002a  4805              LDR      r0,|L39.64|
00002c  6800              LDR      r0,[r0,#0]  ; uwTick
00002e  42b0              CMP      r0,r6
000030  d0fb              BEQ      |L39.42|
;;;1307   		}
000032  bf00              NOP      
                  |L39.52|
;;;1308   }
000034  bd70              POP      {r4-r6,pc}
;;;1309   
                          ENDP

000036  0000              DCW      0x0000
                  |L39.56|
                          DCD      0x000f4240
                  |L39.60|
                          DCD      0xe000e000
                  |L39.64|
                          DCD      uwTick

                          AREA ||i.SC_IncTick||, CODE, READONLY, ALIGN=2

                  SC_IncTick PROC
;;;1253     */
;;;1254   void SC_IncTick(void)
000000  4802              LDR      r0,|L40.12|
;;;1255   {
;;;1256     uwTick++;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L40.12|
000008  6008              STR      r0,[r1,#0]  ; uwTick
;;;1257   }
00000a  4770              BX       lr
;;;1258   
                          ENDP

                  |L40.12|
                          DCD      uwTick

                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_rcc_c_49e27980____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH|
#line 478
|__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
