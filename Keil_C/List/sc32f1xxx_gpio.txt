; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_gpio.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_gpio.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -IC:\KEIL_MDK\PACK\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_gpio.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_gpio.c]
                          THUMB

                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=1

                  GPIO_DeInit PROC
;;;53      */
;;;54     void GPIO_DeInit ( GPIO_TypeDef* GPIOx )
000000  6a01              LDR      r1,[r0,#0x20]
;;;55     {
;;;56         /* Check the parameters */
;;;57         assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;58     
;;;59         /* Deinitializes the GPIOx PXCON register to their default reset values. */
;;;60         GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_PIN_All );
000002  0c09              LSRS     r1,r1,#16
000004  0409              LSLS     r1,r1,#16
000006  6201              STR      r1,[r0,#0x20]
;;;61         /* Deinitializes the GPIOx PXPH register to their default reset values. */
;;;62         GPIOx->PXPH &= ( uint32_t ) ( ~GPIO_PIN_All );
000008  6c01              LDR      r1,[r0,#0x40]
00000a  0c09              LSRS     r1,r1,#16
00000c  0409              LSLS     r1,r1,#16
00000e  6401              STR      r1,[r0,#0x40]
;;;63         /* Deinitializes the GPIOx PIN register to their default reset values. */
;;;64         GPIOx->PIN &= ( uint32_t ) ( ~GPIO_PIN_All );
000010  6801              LDR      r1,[r0,#0]
000012  0c09              LSRS     r1,r1,#16
000014  0409              LSLS     r1,r1,#16
000016  6001              STR      r1,[r0,#0]
;;;65         /* Deinitializes the GPIOx PXLEV register to their default reset values. */
;;;66         GPIOx->PXLEV &= ( uint32_t ) 0x00000000;
000018  6e01              LDR      r1,[r0,#0x60]
00001a  2100              MOVS     r1,#0
00001c  6601              STR      r1,[r0,#0x60]
;;;67     }
00001e  4770              BX       lr
;;;68     
                          ENDP


                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;80      */
;;;81     void GPIO_Init ( GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct )
000000  b570              PUSH     {r4-r6,lr}
;;;82     {
;;;83         uint32_t tmppin, tmppos, tmpreg;
;;;84     
;;;85         /* Check the parameters */
;;;86         assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;87         assert_param ( IS_GPIO_PIN ( GPIO_InitStruct->GPIO_Pin ) );
;;;88         assert_param ( IS_GPIO_MODE ( GPIO_InitStruct->GPIO_Mode ) );
;;;89     
;;;90         if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT_PP )
000002  884d              LDRH     r5,[r1,#2]
000004  2d02              CMP      r5,#2
000006  d104              BNE      |L2.18|
;;;91         {
;;;92             /* Configure Pins to High-resistance output mode */
;;;93             GPIOx->PXCON |= ( uint32_t ) GPIO_InitStruct->GPIO_Pin;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  880e              LDRH     r6,[r1,#0]
00000c  4335              ORRS     r5,r5,r6
00000e  6205              STR      r5,[r0,#0x20]
000010  e016              B        |L2.64|
                  |L2.18|
;;;94         }
;;;95         else if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IN_PU )
000012  884d              LDRH     r5,[r1,#2]
000014  2d01              CMP      r5,#1
000016  d108              BNE      |L2.42|
;;;96         {
;;;97             /* Configure Pins to Pull-up input mode */
;;;98             GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
000018  6a05              LDR      r5,[r0,#0x20]
00001a  880e              LDRH     r6,[r1,#0]
00001c  43b5              BICS     r5,r5,r6
00001e  6205              STR      r5,[r0,#0x20]
;;;99             GPIOx->PXPH |= ( uint32_t ) GPIO_InitStruct->GPIO_Pin;
000020  6c05              LDR      r5,[r0,#0x40]
000022  880e              LDRH     r6,[r1,#0]
000024  4335              ORRS     r5,r5,r6
000026  6405              STR      r5,[r0,#0x40]
000028  e00a              B        |L2.64|
                  |L2.42|
;;;100        }
;;;101        else if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IN_HI )
00002a  884d              LDRH     r5,[r1,#2]
00002c  2d00              CMP      r5,#0
00002e  d107              BNE      |L2.64|
;;;102        {
;;;103            /* Configure Pin to High-resistance intput mode */
;;;104            GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
000030  6a05              LDR      r5,[r0,#0x20]
000032  880e              LDRH     r6,[r1,#0]
000034  43b5              BICS     r5,r5,r6
000036  6205              STR      r5,[r0,#0x20]
;;;105            GPIOx->PXPH &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
000038  6c05              LDR      r5,[r0,#0x40]
00003a  880e              LDRH     r6,[r1,#0]
00003c  43b5              BICS     r5,r5,r6
00003e  6405              STR      r5,[r0,#0x40]
                  |L2.64|
;;;106        }
;;;107    
;;;108        /* Get GPIOx PXLEV value */
;;;109        tmpreg = GPIOx->PXLEV;
000040  6e03              LDR      r3,[r0,#0x60]
;;;110        /* Query the Pins that needs to be manipulated */
;;;111        for ( tmppos = 0; tmppos < 16; tmppos++ )
000042  2200              MOVS     r2,#0
000044  e010              B        |L2.104|
                  |L2.70|
;;;112        {
;;;113            tmppin = ( uint32_t ) ( 0x01 << tmppos );
000046  2401              MOVS     r4,#1
000048  4094              LSLS     r4,r4,r2
;;;114            if ( ( tmppin & GPIO_InitStruct->GPIO_Pin ) != RESET )
00004a  880d              LDRH     r5,[r1,#0]
00004c  4025              ANDS     r5,r5,r4
00004e  2d00              CMP      r5,#0
000050  d009              BEQ      |L2.102|
;;;115            {
;;;116                /* Clear the LEVx bits */
;;;117                tmpreg &= ( uint32_t ) ~ ( GPIO_DriveLevel_3 << ( tmppos * 2 ) );
000052  0056              LSLS     r6,r2,#1
000054  2503              MOVS     r5,#3
000056  40b5              LSLS     r5,r5,r6
000058  461e              MOV      r6,r3
00005a  43ae              BICS     r6,r6,r5
00005c  4633              MOV      r3,r6
;;;118                /* Set LEVx bits according to Drive Level value */
;;;119                tmpreg |= ( uint32_t ) ( GPIO_InitStruct->GPIO_DriveLevel << ( tmppos * 2 ) );
00005e  888d              LDRH     r5,[r1,#4]
000060  0056              LSLS     r6,r2,#1
000062  40b5              LSLS     r5,r5,r6
000064  432b              ORRS     r3,r3,r5
                  |L2.102|
000066  1c52              ADDS     r2,r2,#1              ;111
                  |L2.104|
000068  2a10              CMP      r2,#0x10              ;111
00006a  d3ec              BCC      |L2.70|
;;;120            }
;;;121        }
;;;122        /* Store GPIOx PXLEV the new value */
;;;123        GPIOx->PXLEV = tmpreg;
00006c  6603              STR      r3,[r0,#0x60]
;;;124    }
00006e  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP


                          AREA ||i.GPIO_ReadData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadData PROC
;;;230     */
;;;231    uint16_t GPIO_ReadData ( GPIO_TypeDef* GPIOx )
000000  4601              MOV      r1,r0
;;;232    {
;;;233        /* Check the parameters */
;;;234        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;235    
;;;236        return ( uint16_t ) ( GPIOx->PIN );
000002  6808              LDR      r0,[r1,#0]
000004  b280              UXTH     r0,r0
;;;237    }
000006  4770              BX       lr
;;;238    
                          ENDP


                          AREA ||i.GPIO_ReadDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadDataBit PROC
;;;271     */
;;;272    BitAction GPIO_ReadDataBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  4602              MOV      r2,r0
;;;273    {
;;;274        BitAction bitstatus;
;;;275        /* Check the parameters */
;;;276        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;277        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;278    
;;;279        if ( GPIOx->PIN & GPIO_Pin )
000002  6813              LDR      r3,[r2,#0]
000004  400b              ANDS     r3,r3,r1
000006  2b00              CMP      r3,#0
000008  d001              BEQ      |L4.14|
;;;280        {
;;;281            bitstatus = Bit_SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L4.16|
                  |L4.14|
;;;282        }
;;;283        else
;;;284        {
;;;285            bitstatus = Bit_RESET;
00000e  2000              MOVS     r0,#0
                  |L4.16|
;;;286        }
;;;287    
;;;288        return bitstatus;
;;;289    }
000010  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;369     */
;;;370    void GPIO_ResetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  b508              PUSH     {r3,lr}
;;;371    {
;;;372        /* Check the parameters */
;;;373        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;374        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;375    
;;;376        __IO uint32_t tmpreg = ( uint32_t ) GPIOx;
000002  9000              STR      r0,[sp,#0]
;;;377    
;;;378        while ( GPIO_Pin != 0 )
000004  e00a              B        |L5.28|
                  |L5.6|
;;;379        {
;;;380            if ( GPIO_Pin & 0x0001 )
000006  07ca              LSLS     r2,r1,#31
000008  0fd2              LSRS     r2,r2,#31
00000a  2a00              CMP      r2,#0
00000c  d002              BEQ      |L5.20|
;;;381            {
;;;382                ( * ( ( uint8_t* ) ( tmpreg ) ) ) = 0;
00000e  2200              MOVS     r2,#0
000010  9b00              LDR      r3,[sp,#0]
000012  701a              STRB     r2,[r3,#0]
                  |L5.20|
;;;383            }
;;;384            GPIO_Pin = GPIO_Pin >> 1;
000014  1049              ASRS     r1,r1,#1
;;;385            tmpreg++;
000016  9a00              LDR      r2,[sp,#0]
000018  1c52              ADDS     r2,r2,#1
00001a  9200              STR      r2,[sp,#0]
                  |L5.28|
00001c  2900              CMP      r1,#0                 ;378
00001e  d1f2              BNE      |L5.6|
;;;386        }
;;;387    }
000020  bd08              POP      {r3,pc}
;;;388    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;321     */
;;;322    void GPIO_SetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  b508              PUSH     {r3,lr}
;;;323    {
;;;324        /* Check the parameters */
;;;325        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;326        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;327        __IO uint32_t tmpreg = ( uint32_t ) GPIOx;
000002  9000              STR      r0,[sp,#0]
;;;328        while ( GPIO_Pin != 0 )
000004  e00a              B        |L6.28|
                  |L6.6|
;;;329        {
;;;330            if ( GPIO_Pin & 0x0001 )
000006  07ca              LSLS     r2,r1,#31
000008  0fd2              LSRS     r2,r2,#31
00000a  2a00              CMP      r2,#0
00000c  d002              BEQ      |L6.20|
;;;331            {
;;;332                ( * ( ( uint8_t* ) ( tmpreg ) ) ) = 1;
00000e  2201              MOVS     r2,#1
000010  9b00              LDR      r3,[sp,#0]
000012  701a              STRB     r2,[r3,#0]
                  |L6.20|
;;;333            }
;;;334            GPIO_Pin = GPIO_Pin >> 1;
000014  1049              ASRS     r1,r1,#1
;;;335            tmpreg++;
000016  9a00              LDR      r2,[sp,#0]
000018  1c52              ADDS     r2,r2,#1
00001a  9200              STR      r2,[sp,#0]
                  |L6.28|
00001c  2900              CMP      r1,#0                 ;328
00001e  d1f2              BNE      |L6.6|
;;;336        }
;;;337    }
000020  bd08              POP      {r3,pc}
;;;338    
                          ENDP


                          AREA ||i.GPIO_SetDriveLevel||, CODE, READONLY, ALIGN=1

                  GPIO_SetDriveLevel PROC
;;;161     */
;;;162    void GPIO_SetDriveLevel ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_DriveLevel_TypeDef GPIO_DriveLevel )
000000  b5f0              PUSH     {r4-r7,lr}
;;;163    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;164        uint32_t tmppin, tmppos, tmpreg;
;;;165        /* Get GPIOx PXLEV value */
;;;166        tmpreg = GPIOx->PXLEV;
000006  6e19              LDR      r1,[r3,#0x60]
;;;167        /* Query the Pins that needs to be manipulated */
;;;168        for ( tmppos = 0; tmppos < 16; tmppos++ )
000008  2000              MOVS     r0,#0
00000a  e010              B        |L7.46|
                  |L7.12|
;;;169        {
;;;170            tmppin = ( uint32_t ) ( 0x01 << tmppos );
00000c  2501              MOVS     r5,#1
00000e  4085              LSLS     r5,r5,r0
;;;171            if ( ( tmppin & GPIO_Pin ) != RESET )
000010  462e              MOV      r6,r5
000012  4026              ANDS     r6,r6,r4
000014  2e00              CMP      r6,#0
000016  d009              BEQ      |L7.44|
;;;172            {
;;;173                /* Clear the LEVx bits */
;;;174                tmpreg &= ( uint32_t ) ~ ( GPIO_DriveLevel_3 << ( tmppos * 2 ) );
000018  0047              LSLS     r7,r0,#1
00001a  2603              MOVS     r6,#3
00001c  40be              LSLS     r6,r6,r7
00001e  460f              MOV      r7,r1
000020  43b7              BICS     r7,r7,r6
000022  4639              MOV      r1,r7
;;;175                /* Set LEVx bits according to Drive Level value */
;;;176                tmpreg |= ( uint32_t ) ( GPIO_DriveLevel << ( tmppos * 2 ) );
000024  0047              LSLS     r7,r0,#1
000026  4616              MOV      r6,r2
000028  40be              LSLS     r6,r6,r7
00002a  4331              ORRS     r1,r1,r6
                  |L7.44|
00002c  1c40              ADDS     r0,r0,#1              ;168
                  |L7.46|
00002e  2810              CMP      r0,#0x10              ;168
000030  d3ec              BCC      |L7.12|
;;;177            }
;;;178        }
;;;179        /* Store GPIOx PXLEV the new value */
;;;180        GPIOx->PXLEV = tmpreg;
000032  6619              STR      r1,[r3,#0x60]
;;;181    
;;;182    }
000034  bdf0              POP      {r4-r7,pc}
;;;183    
                          ENDP


                          AREA ||i.GPIO_TogglePins||, CODE, READONLY, ALIGN=1

                  GPIO_TogglePins PROC
;;;493     */
;;;494    void GPIO_TogglePins ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  b518              PUSH     {r3,r4,lr}
;;;495    {
;;;496        /* Check the parameters */
;;;497        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;498        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;499        __IO uint32_t tmpreg = ( uint32_t ) GPIOx + ( 0x00000010UL );
000002  4603              MOV      r3,r0
000004  3310              ADDS     r3,r3,#0x10
000006  9300              STR      r3,[sp,#0]
;;;500        uint32_t temp = 0;
000008  2200              MOVS     r2,#0
;;;501        /* Set the GPIOx PIN value  */
;;;502        while ( GPIO_Pin != 0 )
00000a  e00c              B        |L8.38|
                  |L8.12|
;;;503        {
;;;504    
;;;505            if ( GPIO_Pin & 0x0001 )
00000c  07cb              LSLS     r3,r1,#31
00000e  0fdb              LSRS     r3,r3,#31
000010  2b00              CMP      r3,#0
000012  d004              BEQ      |L8.30|
;;;506            {
;;;507                temp = ~ ( * ( ( uint8_t* ) ( tmpreg ) ) );
000014  9b00              LDR      r3,[sp,#0]
000016  781b              LDRB     r3,[r3,#0]
000018  43da              MVNS     r2,r3
;;;508                ( * ( ( uint8_t* ) ( tmpreg ) ) ) = temp;
00001a  9c00              LDR      r4,[sp,#0]
00001c  7022              STRB     r2,[r4,#0]
                  |L8.30|
;;;509            }
;;;510            GPIO_Pin = GPIO_Pin >> 1;
00001e  1049              ASRS     r1,r1,#1
;;;511            tmpreg++;
000020  9b00              LDR      r3,[sp,#0]
000022  1c5b              ADDS     r3,r3,#1
000024  9300              STR      r3,[sp,#0]
                  |L8.38|
000026  2900              CMP      r1,#0                 ;502
000028  d1f0              BNE      |L8.12|
;;;512        }
;;;513    }
00002a  bd18              POP      {r3,r4,pc}
;;;514    
                          ENDP


                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;401     */
;;;402    void GPIO_Write ( GPIO_TypeDef* GPIOx, uint16_t PortVal )
000000  6001              STR      r1,[r0,#0]
;;;403    {
;;;404        /* Check the parameters */
;;;405        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;406    
;;;407        /*  */
;;;408        GPIOx->PIN = PortVal;
;;;409    }
000002  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;445      */
;;;446    void GPIO_WriteBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal )
000000  2a00              CMP      r2,#0
;;;447    {
;;;448        /* Check the parameters */
;;;449        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;450        assert_param ( IS_GET_GPIO_PIN ( GPIO_Pin ) );
;;;451        assert_param ( IS_GPIO_BITACTION ( BitVal ) );
;;;452    
;;;453        if ( BitVal != Bit_RESET )
000002  d003              BEQ      |L10.12|
;;;454        {
;;;455            GPIOx->PIN |= GPIO_Pin;
000004  6803              LDR      r3,[r0,#0]
000006  430b              ORRS     r3,r3,r1
000008  6003              STR      r3,[r0,#0]
00000a  e002              B        |L10.18|
                  |L10.12|
;;;456        }
;;;457        else
;;;458        {
;;;459            GPIOx->PIN &= ( ~GPIO_Pin ) ;
00000c  6803              LDR      r3,[r0,#0]
00000e  438b              BICS     r3,r3,r1
000010  6003              STR      r3,[r0,#0]
                  |L10.18|
;;;460        }
;;;461    }
000012  4770              BX       lr
;;;462    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REVSH|
#line 478
|__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
