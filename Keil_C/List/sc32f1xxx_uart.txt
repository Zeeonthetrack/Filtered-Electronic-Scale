; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_uart.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_uart.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\SOC_DebugTouchKey_Lib -IC:\KEIL_MDK\PACK\Keil\SC32F1xxx_DFP\1.1.7\Device\SC32F12xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=543 -DSC32f12xx -DSC32f12xx -DPrintfEable --omf_browse=..\output\sc32f1xxx_uart.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_uart.c]
                          THUMB

                          AREA ||i.LINCalChecksum||, CODE, READONLY, ALIGN=1

                  LINCalChecksum PROC
;;;664     */
;;;665    uint8_t LINCalChecksum ( uint8_t id, uint8_t *data, uint8_t len )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;666    {
000002  460e              MOV      r6,r1
000004  4617              MOV      r7,r2
;;;667        uint32_t sum = LIN_CalID ( id );
000006  9800              LDR      r0,[sp,#0]
000008  f7fffffe          BL       LIN_CalID
00000c  4604              MOV      r4,r0
;;;668        uint8_t i;
;;;669    
;;;670        for ( i = 0; i < len; i++ )
00000e  2500              MOVS     r5,#0
000010  e00a              B        |L1.40|
                  |L1.18|
;;;671        {
;;;672            sum += data[i];
000012  5d70              LDRB     r0,[r6,r5]
000014  1904              ADDS     r4,r0,r4
;;;673            if ( sum & 0xFF00 )
000016  20ff              MOVS     r0,#0xff
000018  0200              LSLS     r0,r0,#8
00001a  4020              ANDS     r0,r0,r4
00001c  2800              CMP      r0,#0
00001e  d001              BEQ      |L1.36|
;;;674            {
;;;675                sum = ( sum & 0x00FF ) + 1;
000020  b2e0              UXTB     r0,r4
000022  1c44              ADDS     r4,r0,#1
                  |L1.36|
000024  1c68              ADDS     r0,r5,#1              ;670
000026  b2c5              UXTB     r5,r0                 ;670
                  |L1.40|
000028  42bd              CMP      r5,r7                 ;670
00002a  dbf2              BLT      |L1.18|
;;;676            }
;;;677        }
;;;678    
;;;679        sum ^= 0x00FF;
00002c  20ff              MOVS     r0,#0xff
00002e  4044              EORS     r4,r4,r0
;;;680        return ( uint8_t ) sum;
000030  b2e0              UXTB     r0,r4
;;;681    }
000032  bdfe              POP      {r1-r7,pc}
;;;682    #endif
                          ENDP


                          AREA ||i.LIN_CalID||, CODE, READONLY, ALIGN=1

                  LIN_CalID PROC
;;;645     */
;;;646    uint8_t LIN_CalID ( uint8_t id )
000000  b530              PUSH     {r4,r5,lr}
;;;647    {
000002  4601              MOV      r1,r0
;;;648        uint8_t parity, p0, p1;
;;;649    
;;;650        parity = id;
000004  4608              MOV      r0,r1
;;;651        p0 = ( BIT ( parity, 0 ) ^ BIT ( parity, 1 ) ^ BIT ( parity, 2 ) ^ BIT ( parity, 4 ) ) << 6;
000006  07c4              LSLS     r4,r0,#31
000008  0fe4              LSRS     r4,r4,#31
00000a  0785              LSLS     r5,r0,#30
00000c  0fed              LSRS     r5,r5,#31
00000e  406c              EORS     r4,r4,r5
000010  0745              LSLS     r5,r0,#29
000012  0fed              LSRS     r5,r5,#31
000014  406c              EORS     r4,r4,r5
000016  06c5              LSLS     r5,r0,#27
000018  0fed              LSRS     r5,r5,#31
00001a  406c              EORS     r4,r4,r5
00001c  01a2              LSLS     r2,r4,#6
;;;652        p1 = ( ! ( BIT ( parity, 1 ) ^ BIT ( parity, 3 ) ^ BIT ( parity, 4 ) ^ BIT ( parity, 5 ) ) ) << 7;
00001e  0784              LSLS     r4,r0,#30
000020  0fe4              LSRS     r4,r4,#31
000022  0705              LSLS     r5,r0,#28
000024  0fed              LSRS     r5,r5,#31
000026  406c              EORS     r4,r4,r5
000028  06c5              LSLS     r5,r0,#27
00002a  0fed              LSRS     r5,r5,#31
00002c  406c              EORS     r4,r4,r5
00002e  0685              LSLS     r5,r0,#26
000030  0fed              LSRS     r5,r5,#31
000032  406c              EORS     r4,r4,r5
000034  2501              MOVS     r5,#1
000036  406c              EORS     r4,r4,r5
000038  01e3              LSLS     r3,r4,#7
;;;653    
;;;654        parity |= ( p0 | p1 );
00003a  4614              MOV      r4,r2
00003c  431c              ORRS     r4,r4,r3
00003e  4320              ORRS     r0,r0,r4
;;;655    
;;;656        return parity;
;;;657    }
000040  bd30              POP      {r4,r5,pc}
;;;658    /**
                          ENDP


                          AREA ||i.Printf_UartInit||, CODE, READONLY, ALIGN=2

                  Printf_UartInit PROC
;;;713     */
;;;714    __attribute__((weak)) void Printf_UartInit ( UART_TypeDef* UARTx )
000000  4901              LDR      r1,|L3.8|
;;;715    {
;;;716    
;;;717        Printf_Uart = UARTx;
000002  6008              STR      r0,[r1,#0]  ; Printf_Uart
;;;718    }
000004  4770              BX       lr
;;;719    /*printf mapping function*/
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      Printf_Uart

                          AREA ||i.UART_ClearFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearFlag PROC
;;;454     */
;;;455    void UART_ClearFlag ( UART_TypeDef* UARTx, uint16_t UART_FLAG )
000000  6041              STR      r1,[r0,#4]
;;;456    {
;;;457        /* Check the parameters */
;;;458        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;459    
;;;460        /* Clear the flags */
;;;461        UARTx->UART_STS = ( uint16_t ) UART_FLAG;
;;;462    }
000002  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;479     */
;;;480    void UART_DMACmd ( UART_TypeDef* UARTx, uint16_t UART_DMAReq, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;481    {
;;;482        /* Check the parameters */
;;;483        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;484        assert_param ( IS_UART_DMAREQ ( UART_DMAReq ) );
;;;485        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;486    
;;;487        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L5.14|
;;;488        {
;;;489            /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;490               DMAR bits in the UART IDE register */
;;;491            UARTx->UART_IDE |= UART_DMAReq;
000006  6903              LDR      r3,[r0,#0x10]
000008  430b              ORRS     r3,r3,r1
00000a  6103              STR      r3,[r0,#0x10]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;492        }
;;;493        else
;;;494        {
;;;495            /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;496               DMAR bits in the UART IDE register */
;;;497            UARTx->UART_IDE &= ( uint16_t ) ~UART_DMAReq;
00000e  6903              LDR      r3,[r0,#0x10]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6103              STR      r3,[r0,#0x10]
                  |L5.24|
;;;498        }
;;;499    }
000018  bd10              POP      {r4,pc}
;;;500    /* End of UART_Group3.	*/
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;51      */
;;;52     void UART_DeInit ( UART_TypeDef* UARTx )
000000  b510              PUSH     {r4,lr}
;;;53     {
000002  4604              MOV      r4,r0
;;;54         assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;55     
;;;56         if ( UARTx == UART0 )
000004  4824              LDR      r0,|L6.152|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L6.28|
;;;57         {
;;;58             /* Enable UART0 reset state */
;;;59             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;60             /* Release UART0 from reset state */
;;;61             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, DISABLE );
000012  2100              MOVS     r1,#0
000014  2040              MOVS     r0,#0x40
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
00001a  e023              B        |L6.100|
                  |L6.28|
;;;62         }
;;;63         else if ( UARTx == UART1 )
00001c  481e              LDR      r0,|L6.152|
00001e  3060              ADDS     r0,r0,#0x60
000020  4284              CMP      r4,r0
000022  d108              BNE      |L6.54|
;;;64         {
;;;65             /* Enable UART1 reset state */
;;;66             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, ENABLE );
000024  2101              MOVS     r1,#1
000026  2080              MOVS     r0,#0x80
000028  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;67             /* Release UART1 from reset state */
;;;68             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, DISABLE );
00002c  2100              MOVS     r1,#0
00002e  2080              MOVS     r0,#0x80
000030  f7fffffe          BL       RCC_APB0PeriphResetCmd
000034  e016              B        |L6.100|
                  |L6.54|
;;;69         }
;;;70         else if ( UARTx == UART2 )
000036  4819              LDR      r0,|L6.156|
000038  4284              CMP      r4,r0
00003a  d108              BNE      |L6.78|
;;;71         {
;;;72             /* Enable UART2 reset state */
;;;73             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, ENABLE );
00003c  2101              MOVS     r1,#1
00003e  2080              MOVS     r0,#0x80
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;74             /* Release UART2 from reset state */
;;;75             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, DISABLE );
000044  2100              MOVS     r1,#0
000046  2080              MOVS     r0,#0x80
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004c  e00a              B        |L6.100|
                  |L6.78|
;;;76         }
;;;77         else if ( UARTx == UART3 )
00004e  4814              LDR      r0,|L6.160|
000050  4284              CMP      r4,r0
000052  d107              BNE      |L6.100|
;;;78         {
;;;79             /* Enable UART3 reset state */
;;;80             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, ENABLE );
000054  2101              MOVS     r1,#1
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;81             /* Release UART3 from reset state */
;;;82             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, DISABLE );
00005c  2100              MOVS     r1,#0
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L6.100|
;;;83         }
;;;84     
;;;85     #if  defined(SC32f12xx)
;;;86         if ( UARTx == UART4 )
000064  480d              LDR      r0,|L6.156|
000066  3060              ADDS     r0,r0,#0x60
000068  4284              CMP      r4,r0
00006a  d108              BNE      |L6.126|
;;;87         {
;;;88             /* Enable UART0 reset state */
;;;89             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, ENABLE );
00006c  2101              MOVS     r1,#1
00006e  2040              MOVS     r0,#0x40
000070  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;90             /* Release UART0 from reset state */
;;;91             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, DISABLE );
000074  2100              MOVS     r1,#0
000076  2040              MOVS     r0,#0x40
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007c  e00b              B        |L6.150|
                  |L6.126|
;;;92         }
;;;93         else if ( UARTx == UART5 )
00007e  4806              LDR      r0,|L6.152|
000080  3080              ADDS     r0,r0,#0x80
000082  4284              CMP      r4,r0
000084  d107              BNE      |L6.150|
;;;94         {
;;;95             /* Enable UART5 reset state */
;;;96             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, ENABLE );
000086  2101              MOVS     r1,#1
000088  1540              ASRS     r0,r0,#21
00008a  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;97             /* Release UART5 from reset state */
;;;98             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, DISABLE );
00008e  2100              MOVS     r1,#0
000090  1560              ASRS     r0,r4,#21
000092  f7fffffe          BL       RCC_APB0PeriphResetCmd
                  |L6.150|
;;;99         }
;;;100    #endif
;;;101    }
000096  bd10              POP      {r4,pc}
;;;102    
                          ENDP

                  |L6.152|
                          DCD      0x40020020
                  |L6.156|
                          DCD      0x40021020
                  |L6.160|
                          DCD      0x40022020

                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;414     */
;;;415    FlagStatus UART_GetFlagStatus ( UART_TypeDef* UARTx, UART_FLAG_TypeDef UART_FLAG )
000000  4602              MOV      r2,r0
;;;416    {
;;;417        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;418        /* Check the parameters */
;;;419        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;420        assert_param ( IS_GET_UART_FLAG ( UART_FLAG ) );
;;;421    
;;;422        if ( ( UARTx->UART_STS & UART_FLAG ) != ( uint16_t ) RESET )
000004  6853              LDR      r3,[r2,#4]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L7.16|
;;;423        {
;;;424            bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;425        }
;;;426        else
;;;427        {
;;;428            bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;429        }
;;;430        return bitstatus;
;;;431    }
000012  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;375     */
;;;376    void UART_ITConfig ( UART_TypeDef* UARTx, uint16_t UART_IT, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;377    {
;;;378        /* Check the parameters */
;;;379        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;380        assert_param ( IS_UART_IT ( UART_IT ) );
;;;381        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;382    
;;;383        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L8.14|
;;;384        {
;;;385            /* Enable the Interrupt sources */
;;;386            UARTx->UART_IDE |= UART_IT;
000006  6903              LDR      r3,[r0,#0x10]
000008  430b              ORRS     r3,r3,r1
00000a  6103              STR      r3,[r0,#0x10]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;387        }
;;;388        else
;;;389        {
;;;390            /* Disable the Interrupt sources */
;;;391            UARTx->UART_IDE &= ( uint16_t ) ~UART_IT;
00000e  6903              LDR      r3,[r0,#0x10]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6103              STR      r3,[r0,#0x10]
                  |L8.24|
;;;392        }
;;;393    }
000018  bd10              POP      {r4,pc}
;;;394    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;118     */
;;;119    void UART_Init ( UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct )
000000  b570              PUSH     {r4-r6,lr}
;;;120    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;121        uint32_t tmpreg;
;;;122        /* Check the parameters */
;;;123        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;124        assert_param ( IS_UART_Mode ( UART_InitStruct->UART_Mode ) );
;;;125    
;;;126        tmpreg = UARTx->UART_CON;
000006  6825              LDR      r5,[r4,#0]
;;;127        tmpreg &= ( uint32_t ) ~ ( UART_CON_SM01 | UART_CON_SM2 );
000008  08ed              LSRS     r5,r5,#3
00000a  00ed              LSLS     r5,r5,#3
;;;128        tmpreg |= ( uint32_t ) ( UART_InitStruct->UART_Mode );
00000c  68b0              LDR      r0,[r6,#8]
00000e  4305              ORRS     r5,r5,r0
;;;129        UARTx->UART_CON = tmpreg;
000010  6025              STR      r5,[r4,#0]
;;;130    
;;;131        if ( UART_InitStruct->UART_Mode == UART_Mode_8B )
000012  68b0              LDR      r0,[r6,#8]
000014  2800              CMP      r0,#0
000016  d107              BNE      |L9.40|
;;;132        {
;;;133            assert_param ( IS_UART_PRESCALER ( UART_InitStruct->UART_BaudRate ) );
;;;134    
;;;135            UARTx->UART_CON &= ~ ( uint32_t ) UART_CON_PERSCALER;
000018  6820              LDR      r0,[r4,#0]
00001a  2110              MOVS     r1,#0x10
00001c  4388              BICS     r0,r0,r1
00001e  6020              STR      r0,[r4,#0]
;;;136            UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
000020  6820              LDR      r0,[r4,#0]
000022  4308              ORRS     r0,r0,r1
000024  6020              STR      r0,[r4,#0]
000026  e00d              B        |L9.68|
                  |L9.40|
;;;137        }
;;;138        else
;;;139        {
;;;140            tmpreg = ( UART_InitStruct->UART_ClockFrequency / UART_InitStruct->UART_BaudRate );
000028  6871              LDR      r1,[r6,#4]
00002a  6830              LDR      r0,[r6,#0]
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  4605              MOV      r5,r0
;;;141            if ( tmpreg > 65535 )
000032  4805              LDR      r0,|L9.72|
000034  4285              CMP      r5,r0
000036  d904              BLS      |L9.66|
;;;142            {
;;;143                UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
000038  6820              LDR      r0,[r4,#0]
00003a  2110              MOVS     r1,#0x10
00003c  4308              ORRS     r0,r0,r1
00003e  6020              STR      r0,[r4,#0]
;;;144                tmpreg = tmpreg / 16;
000040  092d              LSRS     r5,r5,#4
                  |L9.66|
;;;145            }
;;;146            UARTx->UART_BAUD = tmpreg;
000042  60a5              STR      r5,[r4,#8]
                  |L9.68|
;;;147        }
;;;148    }
000044  bd70              POP      {r4-r6,pc}
;;;149    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      0x0000ffff

                          AREA ||i.UART_LIN_BKSIZE||, CODE, READONLY, ALIGN=2

                  UART_LIN_BKSIZE PROC
;;;548     */
;;;549    void UART_LIN_BKSIZE ( UART_TypeDef* UARTx, UART_BKSIZE_TypeDef BKSIZE )
000000  b510              PUSH     {r4,lr}
;;;550    {
000002  4602              MOV      r2,r0
;;;551        uint32_t temp;
;;;552        /* Check the parameters */
;;;553        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;554        assert_param ( IS_UART_BKSIZE ( BKSIZE ) );
;;;555    
;;;556        if ( UARTx == UART2 )
000004  4b08              LDR      r3,|L10.40|
000006  429a              CMP      r2,r3
000008  d10c              BNE      |L10.36|
;;;557        {
;;;558            temp = UART2->UART_CON;
00000a  4b07              LDR      r3,|L10.40|
00000c  3b20              SUBS     r3,r3,#0x20
00000e  6a18              LDR      r0,[r3,#0x20]
;;;559            temp &= ~UART_CON_BKSIZE;
000010  0554              LSLS     r4,r2,#21
000012  4603              MOV      r3,r0
000014  43a3              BICS     r3,r3,r4
000016  4618              MOV      r0,r3
;;;560            temp |= BKSIZE;
000018  4603              MOV      r3,r0
00001a  430b              ORRS     r3,r3,r1
00001c  4618              MOV      r0,r3
;;;561            /**/
;;;562            UART2->UART_CON = temp;
00001e  4b02              LDR      r3,|L10.40|
000020  3b20              SUBS     r3,r3,#0x20
000022  6218              STR      r0,[r3,#0x20]
                  |L10.36|
;;;563        }
;;;564    
;;;565    }
000024  bd10              POP      {r4,pc}
;;;566    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_LBDL||, CODE, READONLY, ALIGN=2

                  UART_LIN_LBDL PROC
;;;620     */
;;;621    void UART_LIN_LBDL ( UART_TypeDef* UARTx, UART_LBDL_TypeDef LBDL )
000000  b510              PUSH     {r4,lr}
;;;622    {
000002  4602              MOV      r2,r0
;;;623        uint32_t temp;
;;;624        /* Check the parameters */
;;;625        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;626        assert_param ( IS_UART_LBDL ( LBDL ) );
;;;627    
;;;628        if ( UARTx == UART2 )
000004  4b08              LDR      r3,|L11.40|
000006  429a              CMP      r2,r3
000008  d10d              BNE      |L11.38|
;;;629        {
;;;630            temp = UART2->UART_CON;
00000a  4b07              LDR      r3,|L11.40|
00000c  3b20              SUBS     r3,r3,#0x20
00000e  6a18              LDR      r0,[r3,#0x20]
;;;631            temp &= ~UART_CON_LBDL;
000010  2401              MOVS     r4,#1
000012  04a4              LSLS     r4,r4,#18
000014  4603              MOV      r3,r0
000016  43a3              BICS     r3,r3,r4
000018  4618              MOV      r0,r3
;;;632            temp |= LBDL;
00001a  4603              MOV      r3,r0
00001c  430b              ORRS     r3,r3,r1
00001e  4618              MOV      r0,r3
;;;633            UART2->UART_CON = temp;
000020  4b01              LDR      r3,|L11.40|
000022  3b20              SUBS     r3,r3,#0x20
000024  6218              STR      r0,[r3,#0x20]
                  |L11.38|
;;;634        }
;;;635    
;;;636    
;;;637    
;;;638    
;;;639    }
000026  bd10              POP      {r4,pc}
;;;640    
                          ENDP

                  |L11.40|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_MODE||, CODE, READONLY, ALIGN=2

                  UART_LIN_MODE PROC
;;;524    
;;;525    void UART_LIN_MODE ( UART_TypeDef* UARTx, UART_LINMODE_TypeDef UART_LINMODE )
000000  4602              MOV      r2,r0
;;;526    {
;;;527        uint32_t temp;
;;;528        /* Check the parameters */
;;;529        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;530        assert_param ( IS_UART_LINMODE ( UART_LINMODE ) );
;;;531    
;;;532        if ( UARTx == UART2 )
000002  4b07              LDR      r3,|L12.32|
000004  429a              CMP      r2,r3
000006  d10a              BNE      |L12.30|
;;;533        {
;;;534            temp = UART2->UART_CON;
000008  4b05              LDR      r3,|L12.32|
00000a  3b20              SUBS     r3,r3,#0x20
00000c  6a18              LDR      r0,[r3,#0x20]
;;;535            temp &= ~ ( UART_CON_SLVEN | UART_CON_FUNCSEL );
00000e  4b05              LDR      r3,|L12.36|
000010  4018              ANDS     r0,r0,r3
;;;536            temp |= UART_LINMODE;
000012  4603              MOV      r3,r0
000014  430b              ORRS     r3,r3,r1
000016  4618              MOV      r0,r3
;;;537            UART2->UART_CON = temp;
000018  4b01              LDR      r3,|L12.32|
00001a  3b20              SUBS     r3,r3,#0x20
00001c  6218              STR      r0,[r3,#0x20]
                  |L12.30|
;;;538        }
;;;539    }
00001e  4770              BX       lr
;;;540    /**
                          ENDP

                  |L12.32|
                          DCD      0x40021020
                  |L12.36|
                          DCD      0xfffefeff

                          AREA ||i.UART_LIN_SLVARENE||, CODE, READONLY, ALIGN=2

                  UART_LIN_SLVARENE PROC
;;;585     */
;;;586    void UART_LIN_SLVARENE ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  4a0c              LDR      r2,|L13.52|
;;;587    {
;;;588    
;;;589        /* Check the parameters */
;;;590        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;591    
;;;592        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d114              BNE      |L13.48|
;;;593        {
;;;594            if ( NewState != DISABLE )
000006  2900              CMP      r1,#0
000008  d009              BEQ      |L13.30|
;;;595            {
;;;596                /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;597                   DMAR bits in the UART IDE register */
;;;598                UART2->UART_CON |= UART_CON_SLVAREN;
00000a  4a0a              LDR      r2,|L13.52|
00000c  3a20              SUBS     r2,r2,#0x20
00000e  6a12              LDR      r2,[r2,#0x20]
000010  2301              MOVS     r3,#1
000012  045b              LSLS     r3,r3,#17
000014  431a              ORRS     r2,r2,r3
000016  4b07              LDR      r3,|L13.52|
000018  3b20              SUBS     r3,r3,#0x20
00001a  621a              STR      r2,[r3,#0x20]
00001c  e008              B        |L13.48|
                  |L13.30|
;;;599            }
;;;600            else
;;;601            {
;;;602                /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;603                   DMAR bits in the UART IDE register */
;;;604                UART2->UART_CON &= ( uint32_t ) ~UART_CON_SLVAREN;
00001e  4a05              LDR      r2,|L13.52|
000020  3a20              SUBS     r2,r2,#0x20
000022  6a12              LDR      r2,[r2,#0x20]
000024  2301              MOVS     r3,#1
000026  045b              LSLS     r3,r3,#17
000028  439a              BICS     r2,r2,r3
00002a  4b02              LDR      r3,|L13.52|
00002c  3b20              SUBS     r3,r3,#0x20
00002e  621a              STR      r2,[r3,#0x20]
                  |L13.48|
;;;605            }
;;;606    
;;;607    
;;;608        }
;;;609    
;;;610    }
000030  4770              BX       lr
;;;611    
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      0x40021020

                          AREA ||i.UART_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  UART_PinRemapConfig PROC
;;;308     */
;;;309    void UART_PinRemapConfig ( UART_TypeDef* UARTx, UART_PinRemap_TypeDef UART_Remap )
000000  b510              PUSH     {r4,lr}
;;;310    {
000002  460a              MOV      r2,r1
;;;311        uint32_t tmpreg;
;;;312    
;;;313        /* Check the parameters */
;;;314    #if defined(SC32f10xx)
;;;315        if ( UARTx == UART2 )
;;;316        {
;;;317            tmpreg = UARTx->UART_CON;
;;;318    
;;;319            tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
;;;320    
;;;321            tmpreg |= UART_Remap;
;;;322    
;;;323            UARTx->UART_CON = tmpreg;
;;;324        }
;;;325    
;;;326    #elif defined(SC32f12xx)
;;;327        tmpreg = UARTx->UART_CON;
000004  6801              LDR      r1,[r0,#0]
;;;328    
;;;329        tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
000006  2403              MOVS     r4,#3
000008  03a4              LSLS     r4,r4,#14
00000a  460b              MOV      r3,r1
00000c  43a3              BICS     r3,r3,r4
00000e  4619              MOV      r1,r3
;;;330    
;;;331        tmpreg |= UART_Remap;
000010  460b              MOV      r3,r1
000012  4313              ORRS     r3,r3,r2
000014  4619              MOV      r1,r3
;;;332    
;;;333        UARTx->UART_CON = tmpreg;
000016  6001              STR      r1,[r0,#0]
;;;334    #endif
;;;335    }
000018  bd10              POP      {r4,pc}
;;;336    
                          ENDP


                          AREA ||i.UART_RXCmd||, CODE, READONLY, ALIGN=2

                  UART_RXCmd PROC
;;;199     */
;;;200    void UART_RXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;201    {
;;;202        /* Check the parameters */
;;;203        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;204        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;205    
;;;206        if ( NewState != DISABLE )
000002  d004              BEQ      |L15.14|
;;;207        {
;;;208            /* Enable the UART RX Function */
;;;209            UARTx->UART_CON |= UART_CON_RXEN;
000004  6802              LDR      r2,[r0,#0]
000006  2340              MOVS     r3,#0x40
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L15.22|
                  |L15.14|
;;;210        }
;;;211        else
;;;212        {
;;;213            /* Disable the UART RX Function */
;;;214            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_RXEN;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L15.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L15.22|
;;;215        }
;;;216    }
000016  4770              BX       lr
;;;217    
                          ENDP

                  |L15.24|
                          DCD      0x0000ffbf

                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;268     */
;;;269    uint16_t UART_ReceiveData ( UART_TypeDef* UARTx )
000000  4601              MOV      r1,r0
;;;270    {
;;;271        /* Check the parameters */
;;;272        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;273    
;;;274        /* Receive Data */
;;;275        return ( uint16_t ) ( UARTx->UART_DATA & ( uint16_t ) 0x01FF );
000002  68c8              LDR      r0,[r1,#0xc]
000004  05c0              LSLS     r0,r0,#23
000006  0dc0              LSRS     r0,r0,#23
;;;276    }
000008  4770              BX       lr
;;;277    
                          ENDP


                          AREA ||i.UART_SendBreak||, CODE, READONLY, ALIGN=2

                  UART_SendBreak PROC
;;;570     */
;;;571    void UART_SendBreak()
000000  4803              LDR      r0,|L17.16|
;;;572    {
;;;573        UART2->UART_CON |= UART_CON_BKTR;
000002  6a00              LDR      r0,[r0,#0x20]
000004  2101              MOVS     r1,#1
000006  0609              LSLS     r1,r1,#24
000008  4308              ORRS     r0,r0,r1
00000a  4901              LDR      r1,|L17.16|
00000c  6208              STR      r0,[r1,#0x20]
;;;574    }
00000e  4770              BX       lr
;;;575    
                          ENDP

                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;246     */
;;;247    void UART_SendData ( UART_TypeDef* UARTx, uint16_t Data )
000000  05ca              LSLS     r2,r1,#23
;;;248    {
;;;249        /* Check the parameters */
;;;250        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;251    
;;;252        /* Transmit Data */
;;;253        UARTx->UART_DATA = ( Data & ( uint16_t ) 0x01FF );
000002  0dd2              LSRS     r2,r2,#23
000004  60c2              STR      r2,[r0,#0xc]
;;;254    }
000006  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i.UART_TXCmd||, CODE, READONLY, ALIGN=2

                  UART_TXCmd PROC
;;;165     */
;;;166    void UART_TXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;167    {
;;;168        /* Check the parameters */
;;;169        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;170        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;171    
;;;172        if ( NewState != DISABLE )
000002  d004              BEQ      |L19.14|
;;;173        {
;;;174            /* Enable the UART TX Function */
;;;175            UARTx->UART_CON |= UART_CON_TXEN;
000004  6802              LDR      r2,[r0,#0]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L19.22|
                  |L19.14|
;;;176        }
;;;177        else
;;;178        {
;;;179            /* Disable the UART TX Function */
;;;180            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_TXEN;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L19.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L19.22|
;;;181        }
;;;182    }
000016  4770              BX       lr
;;;183    
                          ENDP

                  |L19.24|
                          DCD      0x0000ff7f

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;698    //    _sys_exit() Ա   ʹ ð     ģʽ
;;;699    void _sys_exit ( int x )
000000  bf00              NOP      
;;;700    {
;;;701        x = x;
;;;702    }
000002  4770              BX       lr
;;;703    #endif
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;720    #if defined (__ARMCC_VERSION)||defined (__ICCARM__)
;;;721    __attribute__((weak)) int fputc ( int c, FILE* f )
000000  b530              PUSH     {r4,r5,lr}
;;;722    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;723        UART_SendData ( Printf_Uart, ( uint8_t ) c );
000006  b2e1              UXTB     r1,r4
000008  4809              LDR      r0,|L21.48|
00000a  6800              LDR      r0,[r0,#0]  ; Printf_Uart
00000c  f7fffffe          BL       UART_SendData
;;;724        while ( !UART_GetFlagStatus ( Printf_Uart, UART_Flag_TX ) );
000010  bf00              NOP      
                  |L21.18|
000012  2102              MOVS     r1,#2
000014  4806              LDR      r0,|L21.48|
000016  6800              LDR      r0,[r0,#0]  ; Printf_Uart
000018  f7fffffe          BL       UART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f8              BEQ      |L21.18|
;;;725        UART_ClearFlag ( Printf_Uart, UART_Flag_TX );
000020  2102              MOVS     r1,#2
000022  4803              LDR      r0,|L21.48|
000024  6800              LDR      r0,[r0,#0]  ; Printf_Uart
000026  f7fffffe          BL       UART_ClearFlag
;;;726        return c;
00002a  4620              MOV      r0,r4
;;;727    }
00002c  bd30              POP      {r4,r5,pc}
;;;728    #elif defined (__GNUC__)
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      Printf_Uart

                          AREA ||.data||, DATA, ALIGN=2

                  Printf_Uart
                          DCD      0x00000000
                  __stdout
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___16_sc32f1xxx_uart_c_c95a8597____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH|
#line 478
|__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
